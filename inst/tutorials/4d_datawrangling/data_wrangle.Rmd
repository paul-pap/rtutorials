---
title: "Data Wrangling"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Mit Daten ringen. Insbesondere dplyr Funktionen werden eingef√ºhrt und ge√ºbt. 
resource_files:
- css/boxes.css
tutorial:
      id: datawrangle
      version: 1
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(learnr)
library(rtutorials)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE)
```

## Inhalt

Im wissenschaftlichen Prozess steht die Daten-Aufbereitung
logischerweise vor der Visualisierung und Auswertung. Die Daten werden
so arrangiert, dass Sie sp√§ter im richtigen Format f√ºr die Auswertung
vorliegen. Dabei werden unter anderem auch Ausrei√üer analysiert und
fehlende Werte betrachtet.

![](images/prozess.png){width="80%"}

## Lernziele

In diesem Tutorial lernst du:

-   <input type="checkbox" unchecked> Was das *tidyverse* ist</input>
-   <input type="checkbox" unchecked> Wie *saubere* Daten ausssehen
    </input>
-   <input type="checkbox" unchecked> Wie du Daten arrangierst </input>

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verf√ºgbaren R
Tutorial namens [*DoSStoolkit*](https://dosstoolkit.com/) [@rohan2023].
Wir haben die Reihenfolge ge√§ndert, Sachen √ºbersetzt und paraphrasiert
und unsere eigenen Gedanken hinzugef√ºgt.

Es ist in vielen Teilen ausf√ºhrlicher als dieses Tutorial und Allen, die
vor englischer Sprache nicht zur√ºckstrecken, w√§rmstens zu empfehlen dort
einen Blick hinein zu werfen.

<hr>

## Tidyverse

Wenn unsere Welt mal wieder im Chaos versinkt, gibt es einen
R√ºckzugsort, wo die Welt noch in *Ordnung* ist: das **tidyverse**.

![](images/messy_tidy.jpg){width="100%"}

Was ist das **tidyverse**? Es ist ein Universum von Paketen, die sich
einem bestimmten Ziel widmen, n√§mlich R f√ºr *Data Science* zu nutzen.
Dazu geh√∂rt vor allem die Arbeit mit Tabellen und Daten.

Dabei hat sich eine Art Dialekt gebildet, der das Ziel hat,
√ºbersichtlich zu sein, konsistent und nutzerfreundlich. In den meisten
F√§llen werden *tidyverse*-Funktionen diesem Anspruch gerecht und
deswegen macht es auch Sinn, sie zu nutzen.

::: gelb
Trotzdem *ein Wort der Warnung*: Alles, was mit *tidyverse*-Paketen
m√∂glich ist, l√§sst sich auch mit `base R` erreichen. Es w√§re nicht so
schlau, die "Basis" zu vergessen, und nur noch *tidyverse* zu lernen.
*Tidyverse* schreibt selbst auf seiner
[Website](https://www.tidyverse.org/), es sei ein ‚Äûopinionated R
Package". Das hei√üt, es vertritt eine klare Meinung dar√ºber, was
eigentlich *tidy*, also aufger√§umt sein, f√ºr R bedeutet. Letztlich kann
das *tidyverse* nicht alles und nicht alle sind √ºberzeugt davon. Manche
R-Kurse entscheiden sich, um nicht zu verwirrend zu sein, nur noch
*tidyverse* zu lehren, beispielsweise @ismay2022 oder @wickham2016.
:::

</br>

Folgende Pakete geh√∂ren zum *tidyverse*:

-   `ggplot2`: konsistente *Grammar of Graphs* f√ºr Visualisierungen
    (kannst du ja sogar schon üëè)

![](images/ggplot.png){width="20%"}

-   `tidyr`: Daten in ein *tidy*-Format bringen

![](images/tidyr.png){width="20%"}

-   `dplyr`: *Data Plyers* "Datenzange"

![](images/dplyr.png){width="20%"}

-   ... und noch einige mehr, unter anderem `tibble`, `readr` and
    `purrr`.

Alle diese Pakete k√∂nnen entweder einzeln installiert werden oder alle
auf einmal, indem das Schirmpaket `tidyverse` installiert wird.

Ein Beispiel f√ºr die Design-Richtlinien, nach denen sich
*tidyverse*-Funktionen richten m√ºssen, ist keine Punkte zu verwenden in
Funktionsnamen (wie z.B. `base R`: `as.data.frame()`), sondern
Unterstriche wie in `as_tibble()`. Das ist ein klassisches Zeichen, dass
wir uns im *tidyverse* bewegen. Au√üerdem ist dort alles *lowercase*,
also kleingeschrieben, damit es nicht zu Verwirrungen wegen Gro√ü- und
Kleinschreibung kommt.

## Von der Datenerhebung zur Analyse

Es klingt banal, aber wenn die Daten aufger√§umt sind, ist bereits die
gr√∂√üte H√ºrde geschafft. Einen Gro√üteil der Zeit von Datenanalyse
verbringen Forschende damit, Daten in die richtige Form zu bringen. Die
Auswertung selbst geht dann oft vergleichsweise schnell.

Den ganzen Aufr√§umprozess kannst du erleichtern, wenn du die Daten von
Anfang an so organisierst, dass R gut damit umgehen kann.

Aber was gibt es eigentlich f√ºr Formen in denen Daten vorliegen k√∂nnen?

Gleiche Daten, aber anders organisiert:

```{r}
df <- trees |> tibble::rowid_to_column(var = "id")

df |> pivot_longer(cols = !id, names_to = "variable")

df |> arrange(Height) |> pivot_wider(id_cols = "id", 
                                     names_from = "Height",
                                     names_prefix = "Height=", values_from = "Volume")
```

## Datenerhebung

Im Falle unseres Beispieldatensatzes `einkaufen` haben 8 Studierende
sich vor Biol√§den in und um Kassel gestellt und den Kund_innen Fragen
gestellt - zum Beispiel zum Lieblingsessen, wie oft sie selbst kochen
und wie weit der Weg bis zum Laden war.

Die Antworten wurden mitgeschrieben und sp√§ter in Excel oder OpenOffice
eingetippt. Damit die Analyse in R sp√§ter gut funktioniert, m√ºssen die
Daten in dieser speziellen Form eingegeben werden:

```{r}
knitr::include_graphics(path = "images/clean.png")
```

::: grau-nb
Merke: Beobachtungen sind immer die Zeilen, und Variablen immer die
Spalten.
:::

##### Variablen

Variablen sind die unterschiedlichen Fragen, die wir gestellt haben. Zum
Beispiel:

-   Wie alt sind Sie? -\> Variable: Alter

-   Wie weit war Ihr Weg in km? -\> Variable: Weg

##### Beobachtungen

Beobachtungen sind hier die einzelnen Personen, denen die Fragen
gestellt wurden. Eine Person ist dabei eine Beobachtung.

##### tidy data

Das oben vorgestellte Konzept wurde unter dem Namen "*tidy data"*
formalisiert.

Hier sind drei wichtige Grundregeln f√ºr *tidy data* nach @wickham2016:

<div>

> 1.  Jede Variable braucht ihre eigene Spalte.
>
> 2.  Jede Beobachtung braucht ihre eigene Zeile.
>
> 3.  Jeder Wert braucht seine eigene Zelle.

</div>

grafisch dargestellt: ![](images/tidy_tableview.png){width="90%"}

Source: [R for Data Science, H. Wickham, M. Cetinkaya-Rundel, G.
Grolemund](https://r4ds.hadley.nz/data-tidy)

Mit diesen drei Grundregeln wirst du weniger Kopfschmerzen bei der
Analyse von Daten mit R bekommen.

<!-- ## tidyr -->

<!-- ![](images/tidyr.png){width="20%"} -->

<!-- Das tidyr Paket hilft uns dabei unsere Daten in ein *tidy*-Format zu bringen. Die Hauptfunktionen von *tidyr* sind: -->

<!-- - *Pivoting*: Dies erm√∂glicht die Umwandlung zwischen der langen und breiten Form eines Data Frames. In diesem Kapitel werden die Funktionen `pivot_wider()` und `pivot_longer()` vorgestellt.  -->

<!-- - Umgang mit *fehlenden Werten*: Du kannst NA-Werte mit der Funktion `drop_na()` entfernen oder du kannst `replace_na()` verwenden, um die NA-Werte durch einen bestimmten Wert zu ersetzen. -->

Stelle bei der Erhebung sicher, dass deine Daten in diesem Format
vorliegen, dann kannst du sie mithilfe des *tidyverse* nach deinen
W√ºnschen arrangieren. Im folgenden stellen wir dir daf√ºr dir das Pakete
`dplyr` und dessen Funktionen vor.

## dplyr

Das `dplyr`-Paket wird verwendet, um einen Datensatz zu manipulieren.

```         
select() erm√∂glicht es dir, Variablen anhand ihrer Namen auszuw√§hlen.
filter() erm√∂glicht es dir, F√§lle basierend auf ihren Werten auszuw√§hlen.
summarise() fasst mehrere Werte zu einer einzigen Zusammenfassung zusammen.
arrange() erm√∂glicht es dir, die Reihenfolge der Zeilen zu √§ndern.
group_by() erm√∂glicht es dir, die Mutation gruppenweise durchzuf√ºhren.
```

Das sind einige gute Beispiele f√ºr Funktionen, die du im Modul lernen
wirst.

Jetzt ist auch die Zeit, in der dein Wissen und K√∂nnen zum Thema
Pipe-Operator `|>` n√ºtzlich wird. Diesen werden wir heute umfassend
nutzen. Falls du im Internet Code findest der diese Pipe `%>%`
verwendet, die stammt ebenfalls aus dem *tidyverse*. Erinnere dich
daran, dass du die Pipe ganz easy mit der Tastenkombination
`strg bzw. Cmd + shift + M` hinzuf√ºgen kannst.

## select

In dieser Lektion werden wir lernen, wie man die Funktion `select()`
verwendet.

Wenn du mit Daten arbeitest, stellst du m√∂glicherweise fest, dass es zu
viele Variablen gibt, und vielleicht fragst du dich, wie du nur die
Variablen ausw√§hlen kannst, die du f√ºr die Analyse verwenden m√∂chtest.
Nun, es gibt eine super einfache M√∂glichkeit, die von dir ausgew√§hlten
Variablen zu sehen, indem du dich auf Variablen anhand des Namens der
Spalte beziehst, und das mit nur einer einfachen Funktion.

`select()` ist eine Funktion, die nur die von dir angegebenen Variablen
beh√§lt.

Die Ausgabe der Funktion ist eine Teilmenge der Eingabedaten (Spalten),
m√∂glicherweise in einer anderen Reihenfolge. Die Funktion select()
ver√§ndert jedoch nicht den Originaldatensatz/die Originalspalten. Wenn
du also die neuen ausgew√§hlten Spalten verwenden m√∂chtest, musst du den
Wert einer neuen Variable zuweisen.

### Vorausgesetzte F√§higkeiten sind:

-   Du solltest ein gutes Verst√§ndnis von Daten (Spalte, Zeile,
    Variable) und davon haben, wie man Daten importiert.

-   Du solltest auch wissen, wie man den Pipe-Operator (%\>%) verwendet.

Hier ist ein einfacher Datensatz mit durchschnittlichen Temperaturen f√ºr
jede Jahreszeit. Wie du im Ergebnis sehen kannst, gibt es 3
Beobachtungen (Zeilen) und 4 Variablen (Spalten) im Datensatz.

```{r temperature, exercise = TRUE}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 
temperature_data
```

Nehmen wir an, wir m√∂chten nur die Temperaturen im Fr√ºhling sehen. Um
dies zu tun, w√§hle die Variablen aus, die du behalten m√∂chtest, indem du
den Variablennamen mit der Funktion select in den Parameter einf√ºgst.
M√∂chten wir nur die Spalte "spring" sehen, sieht der Code daf√ºr so aus:

```{r select1, exercise = TRUE, exercise.setup = "temperature"}
select(temperature_data, spring)
```

Es ist jedoch wichtig zu wissen, dass sich die Daten in
`temperature_data` nicht ge√§ndert haben, wie du sehen kannst. Die
Funktion ver√§ndert den Originaldatensatz nicht.

```{r select2, exercise = TRUE, exercise.setup = "temperature"}
temperature_data
```

Wenn du den neuen Datensatz mit der Variable "spring" verwenden
m√∂chtest, musst du die ausgew√§hlte(n) Spalte(n) einer neuen Variable
zuweisen:

```{r select3, exercise = TRUE, exercise.setup = "temperature"}
new_data <- select(temperature_data, spring)
new_data
```

Du kannst auch **mehrere Variablen durch Kommas getrennt ausw√§hlen**,
solange der Datensatz der erste Input der Funktion ist. Geanu hier ist
dann auch die Pipe n√ºtzlich, da wir das damit sicherstellen.

```{r select4, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |>
  select(summer, winter)
```

### Operatoren:

Jetzt wissen wir, wie die Funktion `select()` funktioniert. Es gibt
dar√ºber hinaus noch verschiedene M√∂glichkeiten, die Funktion mit diesen
hilfreichen Operatoren zu erweitern:

-   `!` eine Aussage oder eine Spalte **negieren**
-   `|` **ODER**-Operator
-   `&` **UND**-Operator
-   `-` eine Spalte **ausschlie√üen**
-   `:` eine Reihe **aufeinanderfolgender Variablen ausw√§hlen**

**.Der Operator `!`** verneint eine Auswahl:

```{r select5, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |>
select(!winter)
select(temperature_data, !winter & !summer)
```

**die Operatoren `|` und `&`** w√§hlen die Vereinigung (`|`) oder eine
Schnittmenge (`&`) der Auswahlen aus.

```{r select6, exercise = TRUE, exercise.setup = "temperature"}
# ODER OPERATOR
temperature_data |>
select(winter | summer)
```

::: gelb
Beachte: `select(temperature_data, winter & summer)` w√ºrde hingegen
einen Fehler verursachen, da es keine Werte geben kann, die eine
Schnittmenge aus Winter und Sommer sind. `&` ist besser daf√ºr geeignet
nach Bedingungen zu filtern, wie du es vielleicht noch vom Indizieren
her kennst.
:::

**4.Der Operator `:`** w√§hlt einen Bereich aufeinanderfolgender
Variablen aus, beginnend mit der Variable links des Doppelpunkts bis zur
Variable rechts des Doppelpunkts.

```{r select7, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |> 
  select(summer:winter)
```

**5.Der Operator `-`** schlie√üt eine Spalte aus.

Wenn du die meisten Spalten im Datensatz ausw√§hlen m√∂chtest und nur
einige Spalten ausschlie√üen m√∂chtest, gibt es eine einfachere
M√∂glichkeit. Du kannst einfach - vor den Namen der Spalte setzen, die du
ausschlie√üen m√∂chtest. Zum Beispiel m√∂chte ich die Spalten "summer" und
"winter" ausschlie√üen, dann setze ich einfach ein - vor die Spalten:

```{r select8, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |> 
  select(-summer, -winter)
```

Jetzt bist du dran!

::: aufgabe
*1.* Lasse dir vom Datensatz `einkaufen` nur die Variablen
`verkehrsmittel` und `alter` ausgeben.
:::

```{r q1_select, exercise = TRUE}

```

```{r q1_select-hint}
# f√ºge der Funktion select die entsprechenden Variablen hinzu
einkaufen |>
   select() 
```

```{r q1_select-solution}
einkaufen |>
   select(verkehrsmittel, alter) 
```

::: aufgabe
*2.* Lasse dir vom Datensatz `einkaufen` alle Variablen bis auf `id` und
`datum` ausgeben.
:::

```{r q2_select, exercise = TRUE}

```

```{r q2_select-hint}
# f√ºge der Funktion select die entsprechenden Variablen hinzu
einkaufen |>
   select() 
```

```{r q2_select-solution}
einkaufen |>
   select(-id, -datum) 
```

```{r q3_select}
question_checkbox("Es gibt Variablen 'id', 'gpa', 'age', 'height', 'weight' in einem Datensatz 'data'. Du m√∂chtest nur die Variablen 'id', 'height' und 'weight' ausw√§hlen. Was solltest du schreiben? (W√§hle alle zutreffenden Optionen aus)",
  answer("data |> select(id, height, weight)", 
         correct = TRUE),
  answer("data select(id & height & weight)", 
         message = "Bei dem & Operator ist es etwas tricky. Erinnere dich, dass alle Bedingungen TRUE sein m√ºssen, damit die Bedingung erf√ºllt ist. Es gibt logischerweise keine Variable, die sowohl id, height und weight  beinhaltet."),
  answer("data |> select(id | height | weight)", 
         correct = TRUE),
  answer("data |> select(id | height:weight)", 
         correct = TRUE),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = "Versuche es erneut. Du schaffst das!"
)
```

Super, das sitzt! üëå Dann kann es jetzt zur n√§chsten dplyr Funktion
weitergehen.

## filter

Die `filter()`-Funktion wird verwendet, um Zeilen aus einem gegebenen
Data Frame basierend auf bestimmten Kriterien zu extrahieren. Alle
Zeilen, die diese Kriterien nicht erf√ºllen, werden verworfen.

Diese Kriterien werden in Form von logischen Bedingungen geschrieben,
die ausgewertet werden k√∂nnen. Zum Beispiel k√∂nnen wir, wenn ein
DataFrame `ToothGrowth` eine Variable namens `len` f√ºr *length* hat,
alle Zeilen extrahieren, bei denen `len` gleich 22 ist, mit dem Ausdruck
`len == 22.0`. Es k√∂nnen eine einzelne Bedingung oder mehrere
Bedingungen vorhanden sein.

Einige n√ºtzliche Funktionen und Operatoren sind:

-   `==`, `>`, `<`, `>=`, `<=`
-   `&`, `|`, `!`, `xor()`
-   \`is.na()

`filter()` funktioniert dabei √§hnlich wie das Indizieren anhand von
eckigen Klammern `[]` in `Base R`. Allerdings, falls beim Auswerten
unserer Bedingungen auf einer Zeile NAs auftreten, verwirft `filter()`
diese Zeilen, w√§hrend `[]` diese weiterhin extrahiert. Das solltest du
also unbedingt im Kopf behalten.

### Welche Argumente nimmt `filter()`?

-   `.data`: den Data Frame, mit dem wir arbeiten
-   `...`: die Bedingungen f√ºr die zu extrahierenden Zeilen
-   `.preserve`: ob wir die Gruppierung des Data Frames erhalten m√∂chten

### Welchen Wert gibt `filter()` zur√ºck?

`filter()` gibt einen Data Frame zur√ºck, der eine Teilmenge der Zeilen
des Data Frames basierend auf den definierten Bedingungen oder Kriterien
enh√§lt. Dabei bleiben die Spalten unver√§ndert und die Reihenfolge der
Zeilen bleibt ebenfalls gleich. Aber schauen wir es uns doch einfach mal
an.

Angenommen, wir interessieren uns nur f√ºr die Antworten von Menschen,
deren Lieblingsessen "Pasta" ist. So k√∂nnten wir mit dem folgenden Code
entsprechend nur jene Zeilen ausgeben lassen, bei denen die Befragten
"Pasta" als Lieblingsessen angaben.

```{r filter1, exercise = TRUE}
einkaufen |> 
filter(essen == "Pasta")
```

::: aufgabe
√Ñndere den Code so um, dass stattdessen nach dem Verkehrsmittel
"Fahrrad" gefiltert wird.
:::

```{r filter2, exercise = TRUE}
einkaufen |> 
filter(essen == "Pasta")
```

```{r filter2-solution, exercise = TRUE}
einkaufen |> 
filter(verkehrsmittel == "Fahrrad")
```

Das hat doch schon mal super geklappt! Gehen wir also einen Schritt
weiter.

::: aufgabe
√Ñndere den Code so um, dass sowohl nach dem Verkehrsmittel "Fahrrad" als
auch einer Wegl√§nge (`weg`) von √ºber `5`km gefiltert wird.
:::

```{r filter3, exercise = TRUE}
einkaufen |> 
filter()
```

```{r filter3-hint, exercise = TRUE}
# f√ºge der ersten Filterbedingung mit dem &-Operator eine weitere Bedingung f√ºr weg √ºber 5 hinzu.
einkaufen |> 
filter(verkehrsmittel == "Fahrrad")
```

```{r filter3-solution, exercise = TRUE}
einkaufen |> 
filter(verkehrsmittel == "Fahrrad" & weg > 5)
```

Noch eine kurze √úbung zu den NAs. Wie du oben bereits gelesen hast,
werden als default NAs in deiner zu filternden Variable herausgefiltert.
M√∂chtest du dir hingegen nur die NAs einer Variable anzeigen lassen, so
ist auch das mit der `filter()` Funktion m√∂glich. Daf√ºr nutzen wir die
Funktion `is.na(*variable*)` innerhalb der `filter()` Funktion. Das
sieht dann so aus:

```{r filter4, exercise = TRUE}
einkaufen |> 
filter(is.na(ort))
```

```{r q1_filter}
question_radio("Welche der folgenden Codes sind korrekt? (W√§hle alle zutreffenden Optionen aus)",
  answer("data |> filter(id & weight)", 
         message = "`filter()` braucht spezifische Bedingungen, die mittels Operatoren bewerkstelligt werden. M√∂chtest du nur die Variablen ausw√§hlen, kannst du daf√ºr `select()` nutzen.") ,
  answer("data |> filter(weight = 60)", 
         message = "`=` ist kein g√ºltiger Operator. Nutze daf√ºr `==`"),
  answer("data |> filter(height <= 1,80)", 
         correct = TRUE),
  answer("data |> filter(farbe == gr√ºn)", 
         message = "String-Variablen m√ºssen in Anf√ºhrungszeichen geschrieben werden, damit R sie nicht als eine Variable interpretiert."),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de")
)
```

Super, auch das hast du gemeistert! Weiter geht¬¥s!

## mutate()

Die `mutate()`-Funktion in R, die durch das Paket dplyr bereitgestellt
wird, erm√∂glicht es, neue Spalten zu deinem Data Frame hinzuzuf√ºgen oder
vorhandene Spalten zu ver√§ndern, basierend auf bestimmten Berechnungen
oder Transformationen. Dies ist besonders n√ºtzlich, um neue
Informationen aus vorhandenen Daten zu generieren oder um bestehende
Daten zu modifizieren.

Um `mutate()` zu nutzen, m√ºssen wir angeben, welcher Data Frame
bearbeitet werden soll, gefolgt von der Definition der neuen oder zu
ver√§ndernden Spalte(n). Die Syntax lautet:

`mutate(.data, new_column = expression)`

-.data: Das DataFrame, das bearbeitet werden soll. - new_column: Der
Name der neuen Spalte oder einer vorhandenen Spalte, die modifiziert
werden soll. - expression: Die Berechnung oder Transformation, die auf
die Daten angewendet werden soll.

Mutate ist somit eine *window function*, das bedeutet, die Funktion
nimmt als Input einen Vektor und gibt auch wieder einen gleichlangen
Vektor aus. ![](images/windowfunc.png){width="70%"} [Source - dplyr
cheat
sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

### Beispiel

Angenommen, wir wollen f√ºr unseren Data Frame `einkaufen` den Weg nicht
nur in km sondern auch in Meter verf√ºgbar haben. Um eine neue Spalte
`weg_m` zu berechnen, k√∂nnten wir folgenden Code verwenden:

```{r mutate1, exercise = TRUE}
# nur weg ausw√§hlen, um den data frame zur Veranschaulichung klein zu halten
einkaufen |> 
  select(weg) |> 
  mutate(weg_m = weg*1000)
```

Willst du die neue Variable jedoch deinem Data Frame hinzuf√ºgen, so
musst du diese mit dem Assignment auch noch zuweisen:

```{r mutate2, exercise = TRUE}
einkaufen <-  einkaufen |> 
  mutate(weg_m = weg*1000)
```

::: gelb
Vorsicht, benutzt du bei dem Assignment in der Pipe auch die
`select()`-Funktion, so verlierst du dabei die anderen Variablen deines
Datensatzes. F√ºr solche F√§lle kannst du besser einen neuen Data Frame
erstellen.
:::

Das Ergebnis, kannst du dir grafisch so vorstellen:

![](images/dfmutate.png){width="80%"} [Source - dplyr cheat
sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

Aber `mutate()` kann noch vieles mehr als eine neue Variable berechnen.
Schau dir daf√ºr gerne auch das [cheat sheet vom Paket
dyplr](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
an.

### Expertenlevel

Eine sehr interessante M√∂glichkeiten von `mutate()` ist die bedingte
Mutation. Hier k√∂nnen Spalten basierend auf bestimmten Bedingungen
erstellt werden.

Nehmen wir an, wir wollen eine unserer metrischen Variablen in selbst
gew√§hlte Kategorien aufteilen. Daf√ºr nutzen wir die Funktion
`ifelse(B, y, z)` in `mutate()`. Damit sagen wir R, wenn Bedingung `B`,
dann `x` ansonsten `y`.

In einem Beispiel ist dies bestimmt leichter zu verstehen:

```{r ifelse, exercise = TRUE}
einkaufen <- einkaufen |> 
  mutate(weglaenge = ifelse(weg > 5, "weit", "nah"))

einkaufen |>  
  select(weg, weglaenge)
```

Hier haben wir eine neue Spalte weglaenge erstellt, die basierend auf
der Bedingung, ob der Weg "gr√∂√üer" als 5km ist, den Wert "weit" oder
ansonsten "nah" enth√§lt. Ziemlich cool, wenn man verstanden hat wie es
funktionert.

Wenn du magst, probiere es doch gleich mal selbst aus:

::: aufgabe
Erstelle eine neue kategoriale Variable `alterskategorien` aus `alter`.
W√§hle dabei nach deinem Ermessen was du f√ºr "jung" und "alt" h√§lst, denn
das ist nicht objektiv, wie es bei einer metrischen Variable w√§re.

Zur Hilfe: `ifelse(Bedingung, "erf√ºllt", "nicht_erf√ºllt")`
:::

```{r jungundalt, exercise = TRUE}

```

```{r jungundalt-hint}
einkaufen_alter <-  einkaufen |> 
  select(alter) |> 
  mutate(alterskategorien = 
           ifelse(Bedingung, "erf√ºllt", "nicht_erf√ºllt")
         )
```

```{r jungundalt-solution}
# f√ºr mich sind Menschen unter 18 jung und dar√ºber alt
einkaufen_alter <-  einkaufen |> 
  select(alter) |> 
  mutate(alterskategorien = 
           ifelse(alter > 18, "alt", "jung")) 

# wir k√∂nnen uns dar√ºber hinaus auch die Kategorien z√§hlen lassen:
einkaufen_alter |>  count(alterskategorien)
```

Wow, das war wirklich nicht leicht! Dann sind die folgenden Frage f√ºr
dich kein Problem:

```{r q1_mutate}
quiz(caption = "Teste dein Wissen zu `mutate()`!",
     
  question_radio("Welche Aussage √ºber `mutate()` ist korrekt?",
    answer("Die durch `mutate()` neu berechnete Variable hat gleich viele Zeilen wie die Variable aus der sie berechnet wurde",
         correct = TRUE),
    answer("Die durch `mutate()` neu berechnete Variable kann auch mehr Zeilen als die Variable aus der sie berechnet wurde", 
         message = "Das die neu berechnete Variable mehr Zeilen hat ist rechnerisch nicht m√∂glich, da sie sich ja aus den bestehenden Werten berechnet"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de")),
  
  question_radio("Welche Aussage √ºber `mutate()` ist korrekt?",
    answer("Um die neu berechnete Variable zu speichern, muss der Assignment Operator genutzt werden",
         correct = TRUE),
    answer("Die neu berechnete Variable wird in dem Data Frame gespeichert", 
         message = "Du siehst beim Ausf√ºhren von `mutate()` zwar das Ergebnis, aber zum tats√§chlichen Speichern wird wie immer der `<-` Assignment Pfeil ben√∂tigt"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de"))
  
)
```

## group_by()

Ein wichtiger Teil der Datenanalyse besteht darin, zu sehen, wie **deine
Daten in bestimmten Gruppen** aussehen, und die `group_by()` Funktion
ist dabei sehr hilfreich. Die `group_by()` Funktion nimmt einen
Datensatz und erm√∂glicht es dir, andere Funktionen zu verwenden, um eine
Vorstellung davon zu bekommen, wie diese Gruppen aussehen.

Wenn du beispielsweise einen Datensatz mit den H√∂hen und Gewichten
verschiedener Tiere hast, ist die `group_by()` Funktion n√ºtzlich, um
Dinge wie das durchschnittliche Gewicht jedes Tiertyps im Datensatz zu
finden. Die Funktion `ungroup()` wird verwendet, um die Gruppierung
durch die `group_by()` Funktion aufzuheben.

Normalerweise wird die `group_by()` Funktion mit anderen
dplyr-Funktionen kombiniert, um deine Analyse durchzuf√ºhren.

Zusammengefasst:

-   Die `group_by` Funktion erm√∂glicht es dir, Datens√§tze nach von dir
    ausgew√§hlten Variablen zu gruppieren.
-   `group_by` funktioniert am besten, wenn es mit anderen
    dplyr-Funktionen kombiniert wird, um entweder die Anzahl der
    Elemente in einer Gruppe zu z√§hlen oder neue Variablen aus den
    Gruppen zu erstellen.
-   m√∂chtest du die Gruppierung wieder aufheben, nutzt du die Funktion
    `ungroup()`.

Grafisch kannst du dir das Gruppieren so vorstellen:

![](images/groupby1.png){width="80%"} [Source: Cheat
Sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

### Argumente

-   **`group_by()`**: Die beiden Hauptargumente f√ºr `group_by` sind die
    **Daten**, die du analysieren m√∂chtest, und die **Variablen, nach
    denen du gruppieren m√∂chtest**.

-   **`ungroup()`**: Die Funktion `ungroup()` nimmt **ein Argument**
    entgegen, den gruppierten **Datensatz**, den du aufheben m√∂chtest.

### Beispiel

Lass uns direkt einsteigen und den `einkaufen` Datensatz nach
Verkehrsmittel aufteilen und als neuen Datensatz `einkaufen_grouped`
speichern.

```{r example_1groupby, exercise = TRUE}
einkaufen_grouped <- einkaufen |>  
  group_by(verkehrsmittel)

head(einkaufen_grouped)
```

Huch da scheint erstmal nichts passiert zu sein, die Reiehnfolge ist
weiterhin zuf√§llig. Das liegt daran, dass die Funktion normalerweise in
Kombination mit anderen Funktionen erst zur Geltung kommt.

Z√§hlen wir mit der Funktion `count()` z.B. noch die Verkehrsmittel, wird
es ersichtlich:

```{r example_2groupby, exercise = TRUE}
einkaufen |>  
  group_by(verkehrsmittel) |> 
  count()

einkaufen |>  
  select(verkehrsmittel) |> 
  count()
```

Anstelle der Anzahl an Eintr√§gen (166) f√ºr verkehrsmittel z√§hlt
`count()` mithilfe der `group_by()` Funktion die Anzahl f√ºr jede
Kategorie.

Das kannst du dir grafisch so vorstellen:

![](images/groupby2.png){width="80%"} [Source: Cheat
Sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

### Probiere es doch selbst mal aus.

::: aufgabe
Gruppiere (`group_by()`) den Datensatz `einkaufen` nach `ort` und lass
dir mit `count()` anzeigen wie viele Eintr√§ge es f√ºr jeden Ort gibt.
:::

```{r groupby1, exercise = TRUE, excercise.caption = "Gruppieren √ºben"}

```

```{r groupby1-hint}
# f√ºge der Funktion group_by() das entsprechende Argument hinzu
einkaufen |> 
  group_by() |> 
  count()
```

```{r groupby1-solution}
einkaufen |> 
  group_by(ort) |> 
  count()
```

Nice! Die Grundlage hast du nun verstanden. Gehen wir also einen kleinen
Schritt weiter und Gruppieren den Datensatz nach 2 Variabeln. Daf√ºr
kannst du wie gewohnt einfach durch ein Komma getrennt eine weitere
Variable in die Funktion `group_by()` einf√ºgen.

::: aufgabe
Gruppiere den Datensatz `einkaufen` nach `bioladen` UND
`verkehrsmittel`, lass dir mit `count()` anzeigen wie viele Eintr√§ge es
f√ºr die entehenden Gruppen gibt.
:::

```{r groupby2, exercise = TRUE, excercise.caption = "Gruppieren mit 2 Variablen"}
einkaufen |> 
  group_by() |> 
  count()
```

```{r groupby2-solution}
einkaufen |> 
  group_by(ort, verkehrsmittel) |> 
  count()
```

Es lassen sich zwar beliebig viele Variablen zur Gruppierung hinzuf√ºgen,
aber sinnvoll ist das nicht unbedingt, da die Kategorien schnell so
viele neue Gruppen erstellen, das jede Gruppe am Ende aus 1-2 Eintr√§gen
besteht. Einen Mittelwert oder √§hnliches hieraus zu berechnen w√§re nicht
sinnvoll.

```{r groupby3, exercise = TRUE, excercise.caption = "Gruppieren mit vielen Variablen"}
einkaufen_gbvwa <- einkaufen |> 
  group_by(verkehrsmittel, weg, alter) |> 
  count()
```

### group_by() und mutate()

Kommen wir zu unserem "Expertenlevel" der Funktion `group_by()`. Die Verkn√ºpfung mit der zuvor gelernten Funktion `mutate()`.

<!-- help -->
einkaufen |>
  group_by(ort) |>
  mutate(neue_variable = mean(weg))


```{r q1_groupmutate}

question_radio("Was denkst du passiert wenn wir group_by() und mutate() verkn√ºpfen?)",
  answer("Zeilenanzahl von `neue_variable` entspricht der Anzahl der Zeilen von `weg`",
         correct = TRUE),
  answer("Zeilenanzahl von `neue_variable` entspricht der Anzahl der Kategorien von `bioladen`",
         message = "Das war ein guter Gedanke, tats√§chlich enth√§lt die Variable jedoch genau so viele Zeilen wie weg. Lies weiter im Tutorial, um zu verstehen warum das so ist."),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de"))

```

#### neue Variablen mit group_by()

Was dir vielleicht zun√§chst komisch erscheint, hat dennoch ein hinterliegendes System und Verwendung.

Um zu verstehen was durch die Verkn√ºpfung mit `mutate()` entstanden ist auch hier f√ºr dich die grafische Darstellung:

![](images/groupby3.png){width="70%"}

[Source: Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

Willst du wie im angegebenen Beispiel f√ºr jede Gruppe den Mittelwert berechnen und als neue Variable abspeichern, erh√§ltst du logischerweise einen Vektor mit Dopplungen f√ºr jeden Eintrag einer Kategorie. Sehen wir uns die Ausgabe gemeinsam an:

```{r groupmutate, exercise = TRUE}

einkaufen_gbf <- einkaufen |>
  group_by(frequenz) |>
  mutate(weg_mean = mean(weg, na.rm = T))

einkaufen_gbf |>
  select(weg_mean, verkehrsmittel)

```

Auf diesem Wege k√∂nntest du z.B. h√§ndisch die Abweichung vom Mittelwert der Gruppe errechnen, in dem du die Spalte weg - weg_mean rechnest. 

```{r groupmutate1, exercise = TRUE}
einkaufen_gbf <-  einkaufen_gbf |>
  mutate(weg_abw = weg - weg_mean)

einkaufen_gbf |>
  select(weg, weg_mean, weg_abw)
```

###  ungroup()
Zu guter letzt noch die versprochene `ungroup()` Funktion, die du nutzen
kannst, wenn du keinen neuen Data Frame erstellt hast und stattdessen
deinen urspr√ºnglichen Data Frame wieder un-gruppieren m√∂chtest:

```{r ungroupby1, exercise = TRUE, excercise.caption = "Gruppieren mit vielen Variablen"}
einkaufen |> 
  group_by( bioladen) |> 
  count()

einkaufen |> 
  group_by( bioladen) |> 
  ungroup() |> 
  count()
```

Du siehst, die Funktion `ungroup()` revidiert die Aufhebung. R sagt dir auch vor jedem Output, dass die Daten Gruppiert wurden. Hier mit `bioladen` und [2] Kategorien.
Von: 
<!-- help -->
A tibble: 2 √ó 2
Groups:   bioladen [2]
 
zu:
<!-- help -->
A tibble: 1 √ó 1

Nat√ºrlich w√ºrdest du es in deinem Code nicht so schreiben wie oben dargestellt, sondern als
alleinstehende Zeile nach deinen Analysen der Gruppen den Code so anf√ºgen:

<!-- help -->
einkaufen <- einkaufen |> 
  ungroup()  


## summarise()

`summarise()` verwendet Zusammenfassungs-Funktionen, d.h. die Funktionen nehmen einen Vektor von Werten und geben einen einzelnen Wert zur√ºck:

![](images/summarize.png){width="80%"} [Source: Cheat
Sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

Es gibt viele Zusammenfassungs-Funktionen, die du innerhalb von `summarise()` verwenden kannst, unter anderem:

-   `min()` (Minimum)

-   `max()` (Maximum)

-   `sum()` (Summe)

-   `var()` (Varianz)

-   `sd()` (Standardabweichung)

-   `mean()` (Mittelwer)


Dabei wird `summarise()` wird oft mit `group_by()` verwendet.

Schauen wir uns die Verwendung der Funktion in Aktion an:

```{r summarise1, exercise = TRUE}
einkaufen |> 
  summarise(weg_m = sum(weg))
```

Wir bekommen ein NA? Komisch?
Nein, erinnere dich daran, dass R sobald ein NA in der Rechnung beteiligt ist, dir stehts NA als Antwort ausgibt. 

F√ºr uns kein Problem, wir sagen der Funktion `sum()` mit dem Zusatzargument `(na.rm = T)`, dass sie die NAs nicht mit in die Rechnung einbeziehen soll:

```{r summarise2, exercise = TRUE}
einkaufen |> 
  summarise(weg_m = sum(weg, na.rm = T))
```

Jetzt bist du dran! 

::: aufgabe
Finde den Maximalwert f√ºr die Variable `weg` f√ºr jeden `ort`. Verwende wieder `na.rm = T` in der Zusammenfassungs-Funktion
:::

```{r summarise3, exercise = TRUE}

```

```{r summarise3-hint}
einkaufen |>
  group_by() |> 
  summarise()
```

```{r summarise3-solution}
einkaufen |>
  group_by(ort) |> 
  summarise(weg_max = max(weg, na.rm = T))
```

Ich m√∂chte dir noch eine Zusammenfassungs-Funktion zeigen, die f√ºr den Beispieldatensatz hilfreich ist:
`n_distinct()`. Die Funktion z√§hlt alle unterschiedlichen (distinkten) Werte in einer Variable. Das k√∂nnen wir gut f√ºr die Variable essen nutzen.

Probiere es doch mal aus:

```{r summarise4, exercise = TRUE}
einkaufen |>
  summarise(anzahl_lieblingsgerichte = n_distinct())
```

```{r summarise4-solution}
einkaufen |>
  summarise(anzahl_lieblingsgerichte = n_distinct(essen))
```

Super auch das hast du jetzt verstanden! Vielleicht geht dir auch langsam die Logik von R ins Blut und die Finger √ºber. üßô

## arrange()

Manchmal m√∂chtest du einen Datensatz in einer bestimmten Reihenfolge anzeigen lassen. Datens√§tze
werden oft in der Reihenfolge angezeigt, in der die Daten eingegeben wurden, aber du m√∂chtest
ihn m√∂glicherweise nach einer anderen Variable sortiert sehen. Du kannst die *tidyverse* `arrange()`-Funktion verwenden, um einen Datensatz nach einer bestimmten
Spalte zu sortieren.

Die `arrange()`-Funktion nimmt einen Dataframe und die zu sortierenden Spalten als Eingabe entgegen und gibt den neu geordneten Dataframe aus. `arrange()` √§ndert dabei keine Werte in deinen Daten, sondern √§ndert nur die Darstellung.

```{r arrange1, exercise = TRUE}
einkaufen |>
  arrange(weg) |> 
  select(weg, alter, frequenz)
```

Du siehst, die Wegl√§nge ist nun aufsteigend arrangiert worden. Auch hier kannst du die Funktion f√ºr mehrere Variablen gleichzeitig nutzen:

```{r arrange2, exercise = TRUE}
einkaufen |>
  arrange(weg, alter) |> 
  select(weg, alter, essen)
```

::: blau
Auch hier gilt: Es gibt viele Wege das gleiche Ziel zu erreichen. Die *Base R* Variante `sort()` kennst du ja auch bereits, die ebenfalls einen Vektor sortieren kann: 
:::

```{r sort, exercise = TRUE}
einkaufen$weg |>
  sort(decreasing  = T) 
```

## rename

Highlights:

-   We can rename multiple columns in a dataframe at once using
    `rename()`.
-   It is helpful to rename columns into something simpler and clearer.
-   We can name columns that do not already have a name using
    `rename()`.
    
`rename(new = old)`


```{r rename-1, exercise = TRUE}
einkaufen <- einkaufen |>
  rename(freq = frequenz)
```

```{r rename-1, exercise = TRUE}
einkaufen |>
  rename(mode = names(.)[2])
```

## Ausrei√üer

## Abschlussquiz

**Wichtig:** Argument setzen: `allow_retry = TRUE`

```{r abschlussquiz_01, echo = FALSE}
learnr::question_radio("Was vermutest du: Was wird ausgegeben durch `wg$name`?",
                       answer("Ein Data Frame",
                              message = "Es ist kein Data Frame, weil die Werte dann untereinander in einer Spalte ausgegeben w√ºrden und nicht nebeneinander."),
                       answer("Ein Vektor",
                              correct = TRUE,
                              message = "Genau. Es ist ein Vektor, denn bei einem Data Frame w√ºrden die Werte untereinander in einer Spalte ausgegeben statt horizontal."),
                       allow_retry = TRUE)
```

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

Hier ein kleiner Text, was gelernt wurde und vlt. auch warum das wichtig
ist.

### Diese neuen Konzepte kennst du nun:

-   

    ```         
    Stichpunktartige Beschreibung
    ```

### Neue Funktionen

eine Tabelle mit den wichtigesten Codes des Tutorials \| Code \|
Beschreibung \|
\|----------------\|----------------------------------------\| \| `[ ]`
\| Indizierung \| \| `&` \| UND-Operator f√ºr logische Indizierung \|

## Credit

<!-- vielleicht in diese Richtung? -->

Dieses Tutorial wurde (gr√∂√ütenteils) von Marie Klosterkamp sowie in
Teilen von Lukas Bruelheide geschrieben.

Bei der Erstellung (u.a. der Beispiele, Aufgaben und Zusammenfassung)
wurde teilweise von ChatGPT und Bing Image Creator gebrauch gemacht.
