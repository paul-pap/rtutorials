---
title: "Data Wrangling"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Mit Daten ringen.
resource_files:
- css/boxes.css
tutorial:
      id: visbasic
      version: 1
---

```{r setup, include=FALSE}
library(learnr)
library(dplyr)
library(tidyr)
knitr::opts_chunk$set(echo = FALSE)
```

## Inhalt

kurze Beschreibung des Inhalts

Verortung auf der Roadmap

## Lernziele

kleine Checkliste mit abhakbaren Checkboxen:

-   <input type="checkbox" unchecked> Wie verschiedene √úberschriften
    gerendert werden </input>
-   <input type="checkbox" unchecked> farbige HTML-Boxen </input>
-   <input type="checkbox" unchecked> HTML-Tag f√ºr Abs√§tze </input>
-   <input type="checkbox" unchecked> ausklappbare Abschnitte </input>
-   <input type="checkbox" unchecked> LaTex </input>

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verf√ºgbaren R Tutorial namens [*DoSStoolkit*](https://dosstoolkit.com/) [[Copyright (c) 2021 Rohan Alexander](https://dosstoolkit.com/LICENSE.html)]. Wir haben die Reihenfolge ge√§ndert, Sachen √ºbersetzt und paraphrasiert und unsere eigenen Gedanken hinzugef√ºgt.

Es ist in vielen Teilen ausf√ºhrlicher als dieses Tutorial und Allen, die vor englischer Sprache nicht zur√ºckstrecken, w√§rmstens zu empfehlen dort einen Blick hinein zu werfen. 

<hr>

## Tidyverse

Wenn unsere Welt mal wieder im Chaos versinkt, gibt es  einen R√ºckzugsort, wo die Welt noch in *Ordnung* ist: das **Tidyverse**. 

![](images/messy_tidy.jpg){width="100%"}

Was ist das Tidyverse? Es ist ein Universum von Paketen, die sich einem bestimmten Ziel widmen, n√§mlich R f√ºr *Data Science* zu nutzen. Dazu geh√∂rt vor allem die Arbeit mit Tabellen und Daten.

Dabei hat sich eine Art Dialekt gebildet, der das Ziel hat, √ºbersichtlich zu sein und konsistent und nutzerfreundlich. In den meisten F√§llen werden Tidyverse-Funktionen diesem Anspruch gerecht und deswegen macht es auch Sinn, sie zu nutzen.

::: gelb
Trotzdem *ein Wort der Warnung*: Alles, was mit Tidyverse-Paketen m√∂glich ist, l√§sst sich auch mit `base R` erreichen. Es w√§re nicht so schlau, die "Basis" zu vergessen, und nur noch Tidyverse zu lernen. Tidyverse schreibt selbst auf seiner [Website](https://www.tidyverse.org/), es sei ein ‚Äûopinionated R Package". Das hei√üt, es vertritt eine klare Meinung dar√ºber, was eigentlich *tidy*, also aufger√§umt sein, f√ºr R bedeutet. Letztlich kann das Tidyverse nicht alles und nicht alle sind √ºberzeugt davon. Manche R-Kurse entscheiden sich, um nicht zu verwirrend zu sein, nur noch Tidyverse zu lehren, beispielsweise @ismay2022 oder @wickham2016.
:::

</br>

Folgende Pakete geh√∂ren zum Tidyverse:

![](images/ggplot.png){width="20%"} 

-   `ggplot2`: konsistente *Grammar of Graphs* f√ºr Visualisierungen (kannst du ja sogar schon üëè)

![](images/tidyr.png){width="20%"}

-   `tidyr`: Daten in ein *tidy*-Format bringen


![](images/dplyr.png){width="20%"}

-   `dplyr`: *Data Plyers* "Datenzange"



-   ... und noch einige mehr, unter anderem `tibble`, `readr` and `purrr`.

Alle diese Pakete k√∂nnen entweder einzeln installiert werden oder alle auf einmal, indem das Schirmpaket `tidyverse` installiert wird.

```{r tidyinstall, exercise = TRUE}
# Nur EIN Mal zur Installation ausf√ºhren
# install.packages("tidyverse") # ist jedoch mit dem Tutorial bereits installiert

# f√ºr jede Session ausf√ºhren, in der tidyverse 
# Pakete genutzt werden sollen
library(tidyverse)            
```

Ein Beispiel f√ºr die Design-Richtlinien, nach denen sich Tidyverse-Funktionen richten m√ºssen, ist keine Punkte zu verwenden in Funktionsnamen (wie z.B. `base R`: `as.data.frame()`), sondern Unterstriche wie in `as_tibble()`. Das ist ein klassisches Zeichen, dass wir uns im Tidyverse bewegen. Au√üerdem ist dort alles
*lowercase*, also kleingeschrieben, damit es nicht zu Verwirrungen wegen Gro√ü-
und Kleinschreibung kommt. 

## Von der Datenerhebung zur Analyse

Es klingt banal, aber wenn die Daten aufger√§umt sind, ist bereits die gr√∂√üte H√ºrde geschafft. Einen Gro√üteil der Zeit von Datenanalyse verbringen Forschende damit, Daten in die richtige Form zu bringen. Die Auswertung selbst geht dann oft vergleichsweise schnell.

Den ganzen Aufr√§umprozess k√∂nnen Sie erleichtern, wenn Sie die Daten von Anfang an so organisieren, dass R gut damit umgehen kann.

Aber was gibt es eigentlich f√ºr Formen in denen Daten sein k√∂nnen?


Gleiche Daten, aber anders organisiert:

```{r}
df <- trees |> tibble::rowid_to_column(var = "id")
#moved to setup:
# library(dplyr) 
# library(tidyr)
df |> pivot_longer(cols = !id, names_to = "variable")

df |> arrange(Height) |> pivot_wider(id_cols = "id", names_from = "Height",
                                     names_prefix = "Height=", values_from = "Volume")
```

## Datenerhebung

Wir beginnen damit, Daten zu erheben. Im Wintersemester 2022/23 haben 8 Studierende sich vor Biol√§den in und um Kassel gestellt und den Kund_innen Fragen gestellt - zum Beispiel zum Lieblingsessen, wie oft sie selbst kochen und wie weit der Weg bis zum Laden war.

Die Antworten wurden mitgeschrieben und sp√§ter in Excel oder OpenOffice eingetippt. Damit die Analyse in R sp√§ter gut funktioniert, m√ºssen die Daten in einer speziellen Form eingegeben werden:

```{r}
knitr::include_graphics(path = "images/clean.png")
```

::: grau-nb
Merke: Beobachtungen sind immer die Zeilen, und Variablen immer die Spalten.
:::

##### Variablen

Variablen sind die unterschiedlichen Fragen, die wir gestellt haben. Zum Beispiel:

-   Wie alt sind Sie? -\> Variable: Alter

-   Wie weit war Ihr Weg in km? -\> Variable: Weg

##### Beobachtungen

Beobachtungen sind hier die einzelnen Personen, denen die Fragen gestellt wurden. Eine Person ist dabei eine Beobachtung.

##### tidy data

Das oben vorgestellte Konzept wurde unter dem Namen "*tidy data"* formalisiert.

Hier sind drei wichtige Grundregeln f√ºr *tidy data* nach @wickham2016:

<div>

> 1.  Jede Variable braucht ihre eigene Spalte.
>
> 2.  Jede Beobachtung braucht ihre eigene Zeile.
>
> 3.  Jeder Wert braucht seine eigene Zelle.

</div>

grafisch dargestellt:
![](images/tidy_tableview.png){width="90%"}

Source: [R for Data Science, H. Wickham, M. Cetinkaya-Rundel, G. Grolemund](https://r4ds.hadley.nz/data-tidy)

Mit diesen drei Grundregeln werden Sie weniger Kopfschmerzen bei der Analyse von Daten mit R bekommen.

## dplyr

Das dplyr-Paket wird verwendet, um einen Datensatz zu manipulieren, den du mit readr und tidyr erstellt hast.

    select() erm√∂glicht es dir, Variablen anhand ihrer Namen auszuw√§hlen.
    filter() erm√∂glicht es dir, F√§lle basierend auf ihren Werten auszuw√§hlen.
    summarise() fasst mehrere Werte zu einer einzigen Zusammenfassung zusammen.
    arrange() erm√∂glicht es dir, die Reihenfolge der Zeilen zu √§ndern.
    group_by() erm√∂glicht es dir, die Mutation gruppenweise durchzuf√ºhren.

Das sind einige gute Beispiele f√ºr Funktionen, die du im Modul lernen wirst.

Die repr√§sentativste Funktion, die von tidyr und dplyr unterst√ºtzt wird, ist der Pipe-Operator %>%. Durch die Verwendung dieses Operators werden Redundanz und Ineffizienz von duplizierten Variablennamen im Code vermieden. Nicht nur der Pipe-Operator, sondern es gibt auch viele andere n√ºtzliche Funktionen, die diese beiden Pakete zu lernen unerl√§sslich machen.

Hier findest du weitere Informationen zum dplyr-Paket.

### select

In dieser Lektion werden wir lernen, wie man die Funktion `select()` verwendet.

Wenn du mit Daten arbeitest, stellst du m√∂glicherweise fest, dass es zu viele Variablen gibt, und vielleicht fragst du dich, wie du nur die Variablen ausw√§hlen kannst, die du f√ºr die Analyse verwenden m√∂chtest. Nun, es gibt eine super einfache M√∂glichkeit, die von dir ausgew√§hlten Variablen zu sehen, indem du dich auf Variablen anhand des Namens der Spalte beziehst, und das mit nur einer einfachen Funktion.

`select()` ist eine Funktion, die nur die von dir angegebenen Variablen beh√§lt.

Die Ausgabe der Funktion ist eine Teilmenge der Eingabedaten (Spalten), m√∂glicherweise in einer anderen Reihenfolge. Die Funktion select() ver√§ndert jedoch nicht den Originaldatensatz/die Originalspalten. Wenn du also die neuen ausgew√§hlten Spalten verwenden m√∂chtest, musst du den Wert einer neuen Variable zuweisen.

Vorausgesetzte F√§higkeiten sind:

- Du solltest ein gutes Verst√§ndnis von Daten (Spalte, Zeile, Variable) und davon haben, wie man Daten importiert.

- Du solltest auch wissen, wie man den Pipe-Operator (%>%) verwendet.

Hier ist ein einfacher Datensatz mit durchschnittlichen Temperaturen f√ºr jede Jahreszeit. Wie du im Ergebnis sehen kannst, gibt es 3 Beobachtungen (Zeilen) und 4 Variablen (Spalten) im Datensatz.

```{r echo = F}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 
temperature_data
```

Nehmen wir an, wir m√∂chten nur die Temperaturen im Fr√ºhling sehen. Um dies zu tun, w√§hle die Variablen aus, die du behalten m√∂chtest, indem du den Variablennamen mit der Funktion select in den Parameter einf√ºgst. Hier m√∂chte ich nur die Spalte "spring" sehen, indem ich den Code wie folgt schreibe:


```{r}
select(temperature_data, spring)
```

Es ist jedoch wichtig zu wissen, dass sich die Daten in `temperature_data` nicht ge√§ndert haben, wie du sehen kannst. Die Funktion ver√§ndert den Originaldatensatz nicht.

```{r}
temperature_data
```

Wenn du den neuen Datensatz mit der Variable "spring" verwenden m√∂chtest, musst du die ausgew√§hlte(n) Spalte(n) einer neuen Variable zuweisen:

```{r}
new_data = select(temperature_data, spring)
new_data
```

#### Operatoren:

Jetzt wissen wir, wie man die Funktion select im Minimum verwendet. Es gibt verschiedene M√∂glichkeiten, die Funktion mit einigen Operatoren zu verwenden.

- `|`  **ODER**-Operator
- `&` **UND**-Operator
- `!`  eine Aussage oder eine Spalte zu **negieren**
- `-` eine Spalte **ausschlie√üen**
- `:` eine Reihe **aufeinanderfolgender Variablen ausw√§hlen**

**1. Du kannst mehrere Variablen durch Kommas getrennt ausw√§hlen. Die Reihenfolge der Eingabe ist wichtig**

```{r}
select(temperature_data, winter, summer)
```


**2. Eine andere M√∂glichkeit, mehrere Variablen auszuw√§hlen, besteht darin, den Operator `c()`. zu verwenden.**\ Die Reihenfolge ist hierbei jedoch zu beachten. 

```{r}
temperature_data %>%
select(c(winter, fall))
```

**3.Der Operator `!`** verneint eine Auswahl, der Operator `&` bedeutet "UND" (Schnittmenge), w√§hrend `|` die Vereinigung der Auswahlen (ODER) vornimmt.**

```{r}
temperature_data %>%
select(!winter)
select(temperature_data, !winter & !summer)
```

`select(temperature_data, winter & summer)` w√ºrde einen Fehler verursachen, da es keine Variable geben kann, die sowohl Winter als auch Sommer ist.

**4.Der Operator `:`** w√§hlt einen Bereich aufeinanderfolgender Variablen aus, beginnend mit der Variable links des Doppelpunkts bis zur Variable rechts des Doppelpunkts.

```{r}
temperature_data %>% 
  select(summer:winter)
```

**5.Der Operator `-`** schlie√üt eine Spalte aus.

Wenn du die meisten Spalten im Datensatz ausw√§hlen m√∂chtest und nur einige Spalten ausschlie√üen m√∂chtest, gibt es eine einfachere M√∂glichkeit. Du kannst einfach - vor den Namen der Spalte setzen, die du ausschlie√üen m√∂chtest. Zum Beispiel m√∂chte ich die Spalten "summer" und "winter" ausschlie√üen, dann setze ich einfach ein - vor die Spalten:

```{r}
temperature_data %>% 
  select(-summer, -winter)
```

::: Aufgabe
√Ñndere diesen Code so, dass wir nur die Spalten "winter" und
"sommer" sehen k√∂nnen, indem du den Operator "|" verwendest.
:::

```{r q1_select, exercise=TRUE}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 

select(temperature_data, spring)
```

```{r q1_select-solution}
select(temperature_data, winter|summer)
```

```{r q2_select}
question_checkbox(
  "Es gibt Variablen 'id', 'gpa', 'age', 'height', 'weight' in einem Datensatz 'data'. Du m√∂chtest nur die Variablen 'id', 'height' und 'weight' ausw√§hlen. Was solltest du schreiben? (W√§hle alle zutreffenden Optionen aus)",
  answer("data %>% select(id, height, weight)", 
         correct = T),
  answer("data %>% select(id & height & weight)", 
         message = "Bei dem & Operator ist es etwas tricky. Erinnere dich, dass alle Bedingungen TRUE sein m√ºssen, damit die Bedingung erf√ºllt ist. Es gibt logischerweise keine Variable, die sowohl id, height und weight  beinhaltet."),
  answer("data %>% select(id | height | weight)", 
         correct = T),
  answer("data %>% select(id | height:weight)", 
         correct = T),
  allow_retry = T,
  random_answer_order = T,
  incorrect = "Versuche es erneut. Du schaffst das!"
)
```

## tidyr

Das tidyr Paket hilft uns dabei unsere Daten in ein *tidy*-Format zu bringen. Die Hauptfunktionen von *tidyr* sind:

- Pivoting: Dies erm√∂glicht die Umwandlung zwischen der langen und breiten Form eines Data Frames. In diesem Kapitel werden die Funktionen `pivot_wider()` und `pivot_longer()` vorgestellt. 

- Umgang mit fehlenden Werten: Du kannst NA-Werte mit der Funktion `drop_na()` entfernen oder du kannst  `replace_na()` verwenden, um die NA-Werte durch einen bestimmten Wert zu ersetzen.

## Abschlussquiz

**Wichtig:** Argument setzen: `allow_retry = TRUE`


```{r abschlussquiz_01, echo = FALSE}
learnr::question_radio("Was vermutest du: Was wird ausgegeben durch `wg$name`?",
                       answer("Ein Data Frame",
                              message = "Es ist kein Data Frame, weil die Werte dann untereinander in einer Spalte ausgegeben w√ºrden und nicht nebeneinander."),
                       answer("Ein Vektor",
                              correct = TRUE,
                              message = "Genau. Es ist ein Vektor, denn bei einem Data Frame w√ºrden die Werte untereinander in einer Spalte ausgegeben statt horizontal."),
                       allow_retry = TRUE)
```


## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```



### Zusammenfassung

Hier ein kleiner Text, was gelernt wurde und vlt. auch warum das wichtig ist.

### Diese neuen Konzepte kennst du nun:
-     Stichpunktartige Beschreibung

### Neue Funktionen
eine Tabelle mit den wichtigesten Codes des Tutorials
| Code           | Beschreibung                           |
|----------------|----------------------------------------|
| `[ ]`          | Indizierung                            |
| `&`            | UND-Operator f√ºr logische Indizierung  |

## Credit
<!-- vielleicht in diese Richtung? -->
Dieses Tutorial wurde (gr√∂√ütenteils) von Marie Klosterkamp sowie in Teilen von Lukas Bruelheide geschrieben. 

Bei der Erstellung (u.a. der Beispiele, Aufgaben und Zusammenfassung) wurde teilweise von ChatGPT und Bing Image Creator gebrauch gemacht.


