---
title: "Data Wrangling"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Mit Daten ringen.
resource_files:
- css/boxes.css
tutorial:
      id: visbasic
      version: 1
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(learnr)
library(dplyr)
library(tidyr)
knitr::opts_chunk$set(echo = FALSE)
```

## Inhalt

kurze Beschreibung des Inhalts

Verortung auf der Roadmap

## Lernziele

In diesem Tutorial lernst du:

-   <input type="checkbox" unchecked> Was das *tidyverse* ist</input>
-   <input type="checkbox" unchecked> Wie *saubere* Daten ausssehen
    </input>
-   <input type="checkbox" unchecked> Wie du Daten arrangierst </input>

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verf√ºgbaren R
Tutorial namens [*DoSStoolkit*](https://dosstoolkit.com/) [@rohan2023]. Wir haben die Reihenfolge ge√§ndert, Sachen √ºbersetzt und
paraphrasiert und unsere eigenen Gedanken hinzugef√ºgt.

Es ist in vielen Teilen ausf√ºhrlicher als dieses Tutorial und Allen, die
vor englischer Sprache nicht zur√ºckstrecken, w√§rmstens zu empfehlen dort
einen Blick hinein zu werfen.

<hr>

## Tidyverse

Wenn unsere Welt mal wieder im Chaos versinkt, gibt es einen
R√ºckzugsort, wo die Welt noch in *Ordnung* ist: das **tidyverse**.

![](images/messy_tidy.jpg){width="100%"}

Was ist das **tidyverse**? Es ist ein Universum von Paketen, die sich
einem bestimmten Ziel widmen, n√§mlich R f√ºr *Data Science* zu nutzen.
Dazu geh√∂rt vor allem die Arbeit mit Tabellen und Daten.

Dabei hat sich eine Art Dialekt gebildet, der das Ziel hat,
√ºbersichtlich zu sein, konsistent und nutzerfreundlich. In den meisten
F√§llen werden *tidyverse*-Funktionen diesem Anspruch gerecht und
deswegen macht es auch Sinn, sie zu nutzen.

::: gelb
Trotzdem *ein Wort der Warnung*: Alles, was mit *tidyverse*-Paketen
m√∂glich ist, l√§sst sich auch mit `base R` erreichen. Es w√§re nicht so
schlau, die "Basis" zu vergessen, und nur noch *tidyverse* zu lernen.
*Tidyverse* schreibt selbst auf seiner
[Website](https://www.tidyverse.org/), es sei ein ‚Äûopinionated R
Package". Das hei√üt, es vertritt eine klare Meinung dar√ºber, was
eigentlich *tidy*, also aufger√§umt sein, f√ºr R bedeutet. Letztlich kann
das *tidyverse* nicht alles und nicht alle sind √ºberzeugt davon. Manche
R-Kurse entscheiden sich, um nicht zu verwirrend zu sein, nur noch
*tidyverse* zu lehren, beispielsweise @ismay2022 oder @wickham2016.
:::

</br>

Folgende Pakete geh√∂ren zum *tidyverse*:

-   `ggplot2`: konsistente *Grammar of Graphs* f√ºr Visualisierungen
    (kannst du ja sogar schon üëè)
    
![](images/ggplot.png){width="20%"}


-   `tidyr`: Daten in ein *tidy*-Format bringen

![](images/tidyr.png){width="20%"}


-   `dplyr`: *Data Plyers* "Datenzange"

![](images/dplyr.png){width="20%"}


-   ... und noch einige mehr, unter anderem `tibble`, `readr` and
    `purrr`.

Alle diese Pakete k√∂nnen entweder einzeln installiert werden oder alle
auf einmal, indem das Schirmpaket `tidyverse` installiert wird.

Ein Beispiel f√ºr die Design-Richtlinien, nach denen sich
*tidyverse*-Funktionen richten m√ºssen, ist keine Punkte zu verwenden in
Funktionsnamen (wie z.B. `base R`: `as.data.frame()`), sondern
Unterstriche wie in `as_tibble()`. Das ist ein klassisches Zeichen, dass
wir uns im *tidyverse* bewegen. Au√üerdem ist dort alles *lowercase*,
also kleingeschrieben, damit es nicht zu Verwirrungen wegen Gro√ü- und
Kleinschreibung kommt.

## Von der Datenerhebung zur Analyse

Es klingt banal, aber wenn die Daten aufger√§umt sind, ist bereits die
gr√∂√üte H√ºrde geschafft. Einen Gro√üteil der Zeit von Datenanalyse
verbringen Forschende damit, Daten in die richtige Form zu bringen. Die
Auswertung selbst geht dann oft vergleichsweise schnell.

Den ganzen Aufr√§umprozess kannst du erleichtern, wenn du die Daten von
Anfang an so organisierst, dass R gut damit umgehen kann.

Aber was gibt es eigentlich f√ºr Formen in denen Daten vorliegen k√∂nnen?

Gleiche Daten, aber anders organisiert:

```{r}
df <- trees |> tibble::rowid_to_column(var = "id")

df |> pivot_longer(cols = !id, names_to = "variable")

df |> arrange(Height) |> pivot_wider(id_cols = "id", 
                                     names_from = "Height",
                                     names_prefix = "Height=", values_from = "Volume")
```

## Datenerhebung

Im Falle unseres Beispieldatensatzes `einkaufen` haben 8 Studierende sich
vor Biol√§den in und um Kassel gestellt und den Kund_innen Fragen
gestellt - zum Beispiel zum Lieblingsessen, wie oft sie selbst kochen
und wie weit der Weg bis zum Laden war.

Die Antworten wurden mitgeschrieben und sp√§ter in Excel oder OpenOffice
eingetippt. Damit die Analyse in R sp√§ter gut funktioniert, m√ºssen die
Daten in dieser speziellen Form eingegeben werden:

```{r}
knitr::include_graphics(path = "images/clean.png")
```

::: grau-nb
Merke: Beobachtungen sind immer die Zeilen, und Variablen immer die
Spalten.
:::

##### Variablen

Variablen sind die unterschiedlichen Fragen, die wir gestellt haben. Zum
Beispiel:

-   Wie alt sind Sie? -\> Variable: Alter

-   Wie weit war Ihr Weg in km? -\> Variable: Weg

##### Beobachtungen

Beobachtungen sind hier die einzelnen Personen, denen die Fragen
gestellt wurden. Eine Person ist dabei eine Beobachtung.

##### tidy data

Das oben vorgestellte Konzept wurde unter dem Namen "*tidy data"*
formalisiert.

Hier sind drei wichtige Grundregeln f√ºr *tidy data* nach @wickham2016:

<div>

> 1.  Jede Variable braucht ihre eigene Spalte.
>
> 2.  Jede Beobachtung braucht ihre eigene Zeile.
>
> 3.  Jeder Wert braucht seine eigene Zelle.

</div>

grafisch dargestellt: ![](images/tidy_tableview.png){width="90%"}

Source: [R for Data Science, H. Wickham, M. Cetinkaya-Rundel, G.
Grolemund](https://r4ds.hadley.nz/data-tidy)

Mit diesen drei Grundregeln wirst du weniger Kopfschmerzen bei der
Analyse von Daten mit R bekommen.

<!-- ## tidyr -->

<!-- ![](images/tidyr.png){width="20%"} -->

<!-- Das tidyr Paket hilft uns dabei unsere Daten in ein *tidy*-Format zu bringen. Die Hauptfunktionen von *tidyr* sind: -->

<!-- - *Pivoting*: Dies erm√∂glicht die Umwandlung zwischen der langen und breiten Form eines Data Frames. In diesem Kapitel werden die Funktionen `pivot_wider()` und `pivot_longer()` vorgestellt.  -->

<!-- - Umgang mit *fehlenden Werten*: Du kannst NA-Werte mit der Funktion `drop_na()` entfernen oder du kannst `replace_na()` verwenden, um die NA-Werte durch einen bestimmten Wert zu ersetzen. -->

Stelle bei der Erhebung sicher, dass deine Daten in diesem Format
vorliegen, dann kannst du sie mithilfe des *tidyverse* nach deinen
W√ºnschen arrangieren. Im folgenden stellen wir dir daf√ºr dir das Pakete
`dplyr` und dessen Funktionen vor.

## dplyr

Das `dplyr`-Paket wird verwendet, um einen Datensatz zu manipulieren.

```         
select() erm√∂glicht es dir, Variablen anhand ihrer Namen auszuw√§hlen.
filter() erm√∂glicht es dir, F√§lle basierend auf ihren Werten auszuw√§hlen.
summarise() fasst mehrere Werte zu einer einzigen Zusammenfassung zusammen.
arrange() erm√∂glicht es dir, die Reihenfolge der Zeilen zu √§ndern.
group_by() erm√∂glicht es dir, die Mutation gruppenweise durchzuf√ºhren.
```

Das sind einige gute Beispiele f√ºr Funktionen, die du im Modul lernen
wirst.

Jetzt ist auch die Zeit, in der dein Wissen und K√∂nnen zum Thema Pipe-Operator `|>` n√ºtzlich wird. Diesen werden wir heute umfassend nutzen. Falls du im Internet Code findest der diese Pipe `%>%`
verwendet, die stammt ebenfalls aus dem *tidyverse*. Erinnere dich daran, dass du die Pipe ganz easy mit der Tastenkombination `strg bzw. Cmd + shift + M` hinzuf√ºgen kannst.  

## select

In dieser Lektion werden wir lernen, wie man die Funktion `select()`
verwendet.

Wenn du mit Daten arbeitest, stellst du m√∂glicherweise fest, dass es zu
viele Variablen gibt, und vielleicht fragst du dich, wie du nur die
Variablen ausw√§hlen kannst, die du f√ºr die Analyse verwenden m√∂chtest.
Nun, es gibt eine super einfache M√∂glichkeit, die von dir ausgew√§hlten
Variablen zu sehen, indem du dich auf Variablen anhand des Namens der
Spalte beziehst, und das mit nur einer einfachen Funktion.

`select()` ist eine Funktion, die nur die von dir angegebenen Variablen
beh√§lt.

Die Ausgabe der Funktion ist eine Teilmenge der Eingabedaten (Spalten),
m√∂glicherweise in einer anderen Reihenfolge. Die Funktion select()
ver√§ndert jedoch nicht den Originaldatensatz/die Originalspalten. Wenn
du also die neuen ausgew√§hlten Spalten verwenden m√∂chtest, musst du den
Wert einer neuen Variable zuweisen.

### Vorausgesetzte F√§higkeiten sind:

-   Du solltest ein gutes Verst√§ndnis von Daten (Spalte, Zeile,
    Variable) und davon haben, wie man Daten importiert.

-   Du solltest auch wissen, wie man den Pipe-Operator (%\>%) verwendet.

Hier ist ein einfacher Datensatz mit durchschnittlichen Temperaturen f√ºr
jede Jahreszeit. Wie du im Ergebnis sehen kannst, gibt es 3
Beobachtungen (Zeilen) und 4 Variablen (Spalten) im Datensatz.

```{r temperature, exercise = TRUE}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 
temperature_data
```

Nehmen wir an, wir m√∂chten nur die Temperaturen im Fr√ºhling sehen. Um
dies zu tun, w√§hle die Variablen aus, die du behalten m√∂chtest, indem du
den Variablennamen mit der Funktion select in den Parameter einf√ºgst.
M√∂chten wir nur die Spalte "spring" sehen, sieht der Code daf√ºr so aus:

```{r select1, exercise = TRUE, exercise.setup = "temperature"}
select(temperature_data, spring)
```

Es ist jedoch wichtig zu wissen, dass sich die Daten in
`temperature_data` nicht ge√§ndert haben, wie du sehen kannst. Die
Funktion ver√§ndert den Originaldatensatz nicht.

```{r select2, exercise = TRUE, exercise.setup = "temperature"}
temperature_data
```

Wenn du den neuen Datensatz mit der Variable "spring" verwenden
m√∂chtest, musst du die ausgew√§hlte(n) Spalte(n) einer neuen Variable
zuweisen:

```{r select3, exercise = TRUE, exercise.setup = "temperature"}
new_data <- select(temperature_data, spring)
new_data
```

Du kannst auch **mehrere Variablen durch Kommas getrennt ausw√§hlen**, solange der Datensatz der erste Input der Funktion ist. Geanu hier ist dann auch die Pipe n√ºtzlich, da wir das damit sicherstellen.

```{r select4, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |>
  select(summer, winter)
```

### Operatoren:

Jetzt wissen wir, wie die Funktion `select()` funktioniert. Es
gibt dar√ºber hinaus noch verschiedene M√∂glichkeiten, die Funktion mit diesen hilfreichen Operatoren zu erweitern:

-   `!` eine Aussage oder eine Spalte **negieren**
-   `|` **ODER**-Operator
-   `&` **UND**-Operator
-   `-` eine Spalte **ausschlie√üen**
-   `:` eine Reihe **aufeinanderfolgender Variablen ausw√§hlen**

**.Der Operator `!`** verneint eine Auswahl:

```{r select5, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |>
select(!winter)
select(temperature_data, !winter & !summer)
```

**die Operatoren `|` und `&`** w√§hlen die Vereinigung (`|`) oder eine Schnittmenge (`&`) der Auswahlen aus.

```{r select6, exercise = TRUE, exercise.setup = "temperature"}
# ODER OPERATOR
temperature_data |>
select(winter | summer)
```

::: gelb
Beachte: `select(temperature_data, winter & summer)` w√ºrde hingegen einen Fehler verursachen, da es keine Werte geben kann, die eine Schnittmenge aus Winter und Sommer sind. `&` ist besser daf√ºr geeignet nach Bedingungen zu filtern, wie du es vielleicht noch vom Indizieren her kennst.
:::

**4.Der Operator `:`** w√§hlt einen Bereich aufeinanderfolgender Variablen aus, beginnend mit der Variable links des Doppelpunkts bis zur Variable rechts des Doppelpunkts.

```{r select7, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |> 
  select(summer:winter)
```

**5.Der Operator `-`** schlie√üt eine Spalte aus.

Wenn du die meisten Spalten im Datensatz ausw√§hlen m√∂chtest und nur
einige Spalten ausschlie√üen m√∂chtest, gibt es eine einfachere
M√∂glichkeit. Du kannst einfach - vor den Namen der Spalte setzen, die du
ausschlie√üen m√∂chtest. Zum Beispiel m√∂chte ich die Spalten "summer" und
"winter" ausschlie√üen, dann setze ich einfach ein - vor die Spalten:

```{r select8, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |> 
  select(-summer, -winter)
```

Jetzt bist du dran!

::: Aufgabe
*1.* Lasse dir vom Datensatz `einkaufen` nur die Variablen `verkehrsmittel` und `alter` ausgeben.
:::

```{r q1_select, exercise = TRUE}

```

```{r q1_select-hint}
# f√ºge der Funktion select die entsprechenden Variablen hinzu
einkaufen |>
   select() 
```

```{r q1_select-solution}
einkaufen |>
   select(verkehrsmittel, alter) 
```

::: Aufgabe
*2.* Lasse dir vom Datensatz `einkaufen` alle Variablen bis auf `id` und `datum` ausgeben.
:::

```{r q2_select, exercise = TRUE}

```

```{r q2_select-hint}
# f√ºge der Funktion select die entsprechenden Variablen hinzu
einkaufen |>
   select() 
```

```{r q2_select-solution}
einkaufen |>
   select(-id, -datum) 
```

```{r q3_select}
question_checkbox("Es gibt Variablen 'id', 'gpa', 'age', 'height', 'weight' in einem Datensatz 'data'. Du m√∂chtest nur die Variablen 'id', 'height' und 'weight' ausw√§hlen. Was solltest du schreiben? (W√§hle alle zutreffenden Optionen aus)",
  answer("data |> select(id, height, weight)", 
         correct = TRUE),
  answer("data select(id & height & weight)", 
         message = "Bei dem & Operator ist es etwas tricky. Erinnere dich, dass alle Bedingungen TRUE sein m√ºssen, damit die Bedingung erf√ºllt ist. Es gibt logischerweise keine Variable, die sowohl id, height und weight  beinhaltet."),
  answer("data |> select(id | height | weight)", 
         correct = TRUE),
  answer("data |> select(id | height:weight)", 
         correct = TRUE),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = "Versuche es erneut. Du schaffst das!"
)
```

Super, das sitzt! üëå
Dann kann es jetzt zur n√§chsten dplyr Funktion weitergehen.

## filter

Die `filter()`-Funktion wird verwendet, um Zeilen aus einem gegebenen Data Frame basierend auf bestimmten Kriterien zu extrahieren. Alle Zeilen, die diese Kriterien nicht erf√ºllen, werden verworfen.

Diese Kriterien werden in Form von logischen Bedingungen geschrieben, die ausgewertet werden k√∂nnen. Zum Beispiel k√∂nnen wir, wenn ein DataFrame `ToothGrowth` eine Variable namens `len` f√ºr *length* hat, alle Zeilen extrahieren, bei denen `len` gleich 22 ist, mit dem Ausdruck `len == 22.0`. Es k√∂nnen eine einzelne Bedingung oder mehrere Bedingungen vorhanden sein.

Einige n√ºtzliche Funktionen und Operatoren sind:

-   `==`, `>`, `<`, `>=`, `<=`
-   `&`, `|`, `!`, `xor()`
-   `is.na()

`filter()` funktioniert dabei √§hnlich wie das Indizieren anhand von eckigen Klammern `[]` in `Base R`. Allerdings, falls beim Auswerten unserer Bedingungen auf einer Zeile NAs auftreten, verwirft `filter()` diese Zeilen, w√§hrend `[]` diese weiterhin extrahiert. Das solltest du also unbedingt im Kopf behalten.

### Welche Argumente nimmt `filter()`?

- `.data`: den Data Frame, mit dem wir arbeiten
- ` ...`: die Bedingungen f√ºr die zu extrahierenden Zeilen
- `.preserve`: ob wir die Gruppierung des Data Frames erhalten m√∂chten

### Welchen Wert gibt `filter()` zur√ºck?

`filter()` gibt einen Data Frame zur√ºck, der eine Teilmenge der Zeilen des Data Frames basierend auf den definierten Bedingungen oder Kriterien enh√§lt. Dabei bleiben die Spalten unver√§ndert und die Reihenfolge der Zeilen bleibt ebenfalls gleich. Aber schauen wir es uns doch einfach mal an. 

Angenommen, wir interessieren uns nur f√ºr die Antworten von Menschen, deren Lieblingsessen "Pasta" ist. So k√∂nnten wir mit dem folgenden Code entsprechend nur jene Zeilen ausgeben lassen, bei denen die Befragten "Pasta" als Lieblingsessen angaben.

```{r filter1, exercise = TRUE}
einkaufen |> 
filter(essen == "Pasta")
```

::: Aufgabe
√Ñndere den Code so um, dass stattdessen nach dem Verkehrsmittel "Fahrrad" gefiltert wird. 
:::

```{r filter2, exercise = TRUE}
einkaufen |> 
filter(essen == "Pasta")
```

```{r filter2-solution, exercise = TRUE}
einkaufen |> 
filter(verkehrsmittel == "Fahrrad")
```

Das hat doch schon mal super geklappt! Gehen wir also einen Schritt weiter. 

::: Aufgabe
√Ñndere den Code so um, dass sowohl nach dem Verkehrsmittel "Fahrrad" als auch einer Wegl√§nge (`weg`) von √ºber `5`km gefiltert wird. 
:::

```{r filter3, exercise = TRUE}
einkaufen |> 
filter()
```

```{r filter3-hint, exercise = TRUE}
# f√ºge der ersten Filterbedingung mit dem &-Operator eine weitere Bedingung f√ºr weg √ºber 5 hinzu.
einkaufen |> 
filter(verkehrsmittel == "Fahrrad")
```

```{r filter3-solution, exercise = TRUE}
einkaufen |> 
filter(verkehrsmittel == "Fahrrad" & weg > 5)
```

Noch eine kurze √úbung zu den NAs. Wie du oben bereits gelesen hast, werden als default NAs in deiner zu filternden Variable herausgefiltert. M√∂chtest du dir hingegen nur die NAs einer Variable anzeigen lassen, so ist auch das mit der `filter()` Funktion m√∂glich. Daf√ºr nutzen wir die Funktion `is.na(*variable*)` innerhalb der `filter()` Funktion. Das sieht dann so aus:

```{r filter4, exercise = TRUE}
einkaufen |> 
filter(is.na(ort))
```

```{r q1_filter}
question_radio("Welche der folgenden Codes sind korrekt? (W√§hle alle zutreffenden Optionen aus)",
  answer("data |> filter(id & weight)", 
         message = "`filter()` braucht spezifische Bedingungen, die mittels Operatoren bewerkstelligt werden. M√∂chtest du nur die Variablen ausw√§hlen, kannst du daf√ºr `select()` nutzen.") ,
  answer("data |> filter(weight = 60)", 
         message = "`=` ist kein g√ºltiger Operator. Nutze daf√ºr `==`"),
  answer("data |> filter(height <= 1,80)", 
         correct = TRUE),
  answer("data |> filter(farbe == gr√ºn)", 
         message = "String-Variablen m√ºssen in Anf√ºhrungszeichen geschrieben werden, damit R sie nicht als eine Variable interpretiert."),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de")
)
```

Super, auch das hast du gemeistert! Weiter geht¬¥s!

## mutate()

Die `mutate()`-Funktion in R, die durch das Paket dplyr bereitgestellt wird, erm√∂glicht es, neue Spalten zu deinem Data Frame hinzuzuf√ºgen oder vorhandene Spalten zu ver√§ndern, basierend auf bestimmten Berechnungen oder Transformationen. Dies ist besonders n√ºtzlich, um neue Informationen aus vorhandenen Daten zu generieren oder um bestehende Daten zu modifizieren.

Um `mutate()` zu nutzen, m√ºssen wir angeben, welcher Data Frame bearbeitet werden soll, gefolgt von der Definition der neuen oder zu ver√§ndernden Spalte(n). Die Syntax lautet:

`mutate(.data, new_column = expression)`

-.data: Das DataFrame, das bearbeitet werden soll.
- new_column: Der Name der neuen Spalte oder einer vorhandenen Spalte, die modifiziert werden soll.
- expression: Die Berechnung oder Transformation, die auf die Daten angewendet werden soll.

Mutate ist somit eine *window function*, das bedeutet, die Funktion nimmt als Input einen Vektor und gibt auch wieder einen gleichlangen Vektor aus. 
![](images/windowfunc.png){width="70%"}
[Source - dplyr cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)


### Beispiel

Angenommen, wir wollen f√ºr unseren Data Frame `einkaufen` den Weg nicht nur in km sondern auch in Meter verf√ºgbar haben. Um eine neue Spalte `weg_m` zu berechnen, k√∂nnten wir folgenden Code verwenden:

```{r mutate1, exercise = TRUE}
# nur weg ausw√§hlen, um den data frame zur Veranschaulichung klein zu halten
einkaufen |> 
  select(weg) |> 
  mutate(weg_m = weg*1000)
```

Willst du die neue Variable jedoch deinem Data Frame hinzuf√ºgen, so musst du diese mit dem Assignment auch noch zuweisen:

```{r mutate2, exercise = TRUE}
einkaufen <-  einkaufen |> 
  mutate(weg_m = weg*1000)
```

::: gelb
Vorsicht, benutzt du bei dem Assignment in der Pipe auch die `select()`-Funktion, so verlierst du dabei die anderen Variablen deines Datensatzes. F√ºr solche F√§lle kannst du besser einen neuen Data Frame erstellen. 
:::

Das Ergebnis, kannst du dir grafisch so vorstellen:

![](images/dfmutate.png){width="80%"}
[Source - dplyr cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

Aber `mutate()` kann noch vieles mehr als eine neue Variable berechnen. Schau dir daf√ºr gerne auch das  [cheat sheet vom Paket dyplr](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) an.

### Expertenlevel

Eine sehr interessante M√∂glichkeiten von `mutate()` ist die bedingte Mutation. Hier k√∂nnen Spalten basierend auf bestimmten Bedingungen erstellt werden.

Nehmen wir an, wir wollen eine unserer metrischen Variablen in selbst gew√§hlte Kategorien aufteilen. Daf√ºr nutzen wir die Funktion `ifelse(B, y, z)` in `mutate()`. Damit sagen wir R, wenn Bedingung `B`, dann `x` ansonsten `y`.

In einem Beispiel ist dies bestimmt leichter zu verstehen:

```{r ifelse, exercise = TRUE}
einkaufen <- einkaufen |> 
  mutate(weglaenge = ifelse(weg > 5, "weit", "nah"))

einkaufen |>  
  select(weg, weglaenge)
```

Hier haben wir eine neue Spalte weglaenge erstellt, die basierend auf der Bedingung, ob der Weg "gr√∂√üer" als 5km ist, den Wert "weit" oder ansonsten "nah" enth√§lt. Ziemlich cool, wenn man verstanden hat wie es funktionert. 

Wenn du magst, probiere es doch gleich mal selbst aus: 

::: Aufgabe
Erstelle eine neue kategoriale Variable `alterskategorien` aus `alter`. W√§hle dabei nach deinem Ermessen was du f√ºr "jung" und "alt" h√§lst, denn das ist nicht objektiv, wie es bei einer metrischen Variable w√§re.

Zur Hilfe: `ifelse(Bedingung, "erf√ºllt", "nicht_erf√ºllt")`
:::

```{r jungundalt, exercise = TRUE}

```

```{r jungundalt-hint}
einkaufen_alter <-  einkaufen |> 
  select(alter) |> 
  mutate(alterskategorien = 
           ifelse(Bedingung, "erf√ºllt", "nicht_erf√ºllt")
         )
```

```{r jungundalt-solution}
# f√ºr mich sind Menschen unter 18 jung und dar√ºber alt
einkaufen_alter <-  einkaufen |> 
  select(alter) |> 
  mutate(alterskategorien = 
           ifelse(alter > 18, "alt", "jung")) 

# wir k√∂nnen uns dar√ºber hinaus auch die Kategorien z√§hlen lassen:
einkaufen_alter |>  count(alterskategorien)
```

Wow, das war wirklich nicht leicht! Dann sind die folgenden Frage f√ºr dich kein Problem:

```{r q1_mutate}
quiz(caption = "Teste dein Wissen zu `mutate()`!",
     
  question_radio("Welche Aussage √ºber `mutate()` ist korrekt?",
    answer("Die durch `mutate()` neu berechnete Variable hat gleich viele Zeilen wie die Variable aus der sie berechnet wurde",
         correct = TRUE),
    answer("Die durch `mutate()` neu berechnete Variable kann auch mehr Zeilen als die Variable aus der sie berechnet wurde", 
         message = "Das die neu berechnete Variable mehr Zeilen hat ist rechnerisch nicht m√∂glich, da sie sich ja aus den bestehenden Werten berechnet"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de")),
  
  question_radio("Welche Aussage √ºber `mutate()` ist korrekt?",
    answer("Um die neu berechnete Variable zu speichern, muss der Assignment Operator genutzt werden",
         correct = TRUE),
    answer("Die neu berechnete Variable wird in dem Data Frame gespeichert", 
         message = "Du siehst beim Ausf√ºhren von `mutate()` zwar das Ergebnis, aber zum tats√§chlichen Speichern wird wie immer der `<-` Assignment Pfeil ben√∂tigt"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de"))
  
)
```

## summarise() 




## arrange() 
## group_by()



## Abschlussquiz

**Wichtig:** Argument setzen: `allow_retry = TRUE`

```{r abschlussquiz_01, echo = FALSE}
learnr::question_radio("Was vermutest du: Was wird ausgegeben durch `wg$name`?",
                       answer("Ein Data Frame",
                              message = "Es ist kein Data Frame, weil die Werte dann untereinander in einer Spalte ausgegeben w√ºrden und nicht nebeneinander."),
                       answer("Ein Vektor",
                              correct = TRUE,
                              message = "Genau. Es ist ein Vektor, denn bei einem Data Frame w√ºrden die Werte untereinander in einer Spalte ausgegeben statt horizontal."),
                       allow_retry = TRUE)
```

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

Hier ein kleiner Text, was gelernt wurde und vlt. auch warum das wichtig
ist.

### Diese neuen Konzepte kennst du nun:

-   

    ```         
    Stichpunktartige Beschreibung
    ```

### Neue Funktionen

eine Tabelle mit den wichtigesten Codes des Tutorials \| Code \|
Beschreibung \|
\|----------------\|----------------------------------------\| \| `[ ]`
\| Indizierung \| \| `&` \| UND-Operator f√ºr logische Indizierung \|

## Credit

<!-- vielleicht in diese Richtung? -->

Dieses Tutorial wurde (gr√∂√ütenteils) von Marie Klosterkamp sowie in
Teilen von Lukas Bruelheide geschrieben.

Bei der Erstellung (u.a. der Beispiele, Aufgaben und Zusammenfassung)
wurde teilweise von ChatGPT und Bing Image Creator gebrauch gemacht.
