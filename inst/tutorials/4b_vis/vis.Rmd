---
title: "Visualisierung"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Schnelle Diagramme erstellen, schöne Diagramme erstellen. Die Grammar of Graphs wird kurz erklärt, das Prinzip wonach ggplot2 aufgebaut ist. Die Erstellung verschiedener Diagrammarten wird geübt. Aesthetic Mappings, Geoms, Facets. 
resource_files:
- css/boxes.css
tutorial:
      id: ggplot
      version: 1
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(kableExtra)
library(tibble)
library(rtutorials)
knitr::opts_chunk$set(echo = FALSE)

```

## Inhalt

Jetzt kommt wirklich einer der allercoolsten Teile des ganzen Kurses. R ist einfach
unfassbar mächtig, was das Visualisieren von Daten angeht, viel ausgefeilter und vielfältiger, als
Excel und SPSS es je erreichen können. Unser Ziel ist euch ein paar schnelle Kochrezepte für die wichtigsten
Visualisierungsaufgaben mitzugeben, und die Neugier auf mehr zu wecken, in dem wir eine kleine Einführung in das Visualisierungspaket `ggplot2` geben.

Mit R sind abgefahrene Sachen möglich. Eine vielfältige Übersicht darüber, was alles geht, erhältst du in der [R Graph Gallery](https://r-graph-gallery.com/). Hier sind ein paar Beispiele:

#### [Eine Karte im Stil von Jacques Bertin](https://r-graph-gallery.com/web-valued-dots-map-bertin.html)

![](images/compress/bertin.png){width=80%}

#### [Heatmap stündliche Temperatur über zwei Jahre](https://r-graph-gallery.com/283-the-hourly-heatmap.html)

![](images/compress/temp.png){width=80%}

Ziemlich beeindruckend, oder?
Das soll hier aber nur ein kleiner Einblick in das sein, was alles möglich ist.  In diesem Tutorial starten natürlich bei den Basics und focussieren uns darauf grundständige Diagramme zu zeichnen. Mit diesem Grundwissen kannst du dir dann auch selbst beibringen solche abgefahrenen Diagramme zu erstellen.
In den Links über den Grafiken findest du detaillierte Anleitungen, wenn du dann soweit bist.

Wie gesagt, wir fangen Schritt für Schritt an und daher sind das hier die Ziele für heute: 

### Lernziele

<input type="checkbox" unchecked> Punktdiagramm (*scatterplot*) erstellen </input>

<input type="checkbox" unchecked> Balkendiagramm (*barplot*) erstellen </input>

<input type="checkbox" unchecked> Histogramm (*histogram*) erstellen </input>

<input type="checkbox" unchecked> Liniendiagramm (*linegraph*) erstellen </input>

<input type="checkbox" unchecked> Boxplot erstellen </input>

<input type="checkbox" unchecked> Schnelle Grafikfunktionen, um einen Überblick zu gewinnen </input>

<input type="checkbox" unchecked> Grafiken mit `ggplot2` nach dem Baukasten der *Grammar of Graphs* erstellen </inpu>

<input type="checkbox" unchecked> colorblind-friendly sein </input>

### Die fünf essentiellen Diagrammtypen

```{r echo=FALSE}
de <- c("Punktdiagramm","Liniendiagramm","Histogramm","Boxplot","Balkendiagramm")
en <- c("scatterplot","linegraph", "histogram", "boxplot", "barplot")
vars <- c("2 stetige Variablen", "1 stetige und 1 zeitlich geordnete Variable",
          "1 stetige Variable", "1 stetige Variable mit Gruppen", "1 kategoriale Variable")
tibble(` `= c("1.", "2.", "3.", "4.", "5."), de, en, `geeignet für` = vars) |>
  kbl() |>
  kable_styling()
```

```{r fiveplots, fig.height=8, out.width="100%"}
par(mfrow = c(3, 2),
    bty = "n")
plot(heated[ ,c("maxtemp", "edvisits")],
     main = "1.",
     axes = F,
     ylab = NA,
     xlab = NA)
plot(heated$enddate[heated$enddate > as.Date("2022-03-24")], 
     heated$maxtemp[heated$enddate > as.Date("2022-03-24")],
     type = "l",
     main = "2.",
     axes = F,
     ylab = NA,
     xlab = NA)
hist(heated$maxtemp,
     main = "3.",
     axes = F,
     ylab = NA,
     xlab = NA)
boxplot(heated$maxtemp ~ factor(lubridate::month(heated$enddate)),
        main = "4.",
        axes = F,
        ylab = NA,
        xlab = NA)
barplot({einkaufen$Verkehrsmittel |> table()}[1:5],
        main = "5.",
        axes = F,
        ylab = NA,
        xlab = NA,
        names.arg = NA)
# reset par
par(mfrow = c(1, 1),
    bty = "o")
```

## Einführung

Es gibt (wie immer) tausend verschiedene Wege, Visualisierungen mit R zu erstellen. Aber einer hat sich über die Jahre als besonders Beliebt erwiesen, und das ist `ggplot2`. 

Der Grund, warum wir dir diesen Weg beibringen:

- Er folgt einem klaren Baukastenprinzip, mit dem auch später beliebig komplexe Anpassungen der Grafik an die eigenen Vorstellungen relativ schmerzfrei umgesetzt werden können. 

- Es ist der populärste Weg, es gibt auf Google viele gute Anleitungen und Antworten. Und es existieren zahlreiche Eweiterungen um das Paket `ggplot2`. 

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verfügbaren Online-Lehrbuch namens [*Modern Dive*](https://www.moderndive.com) [@ismay2022]. Wir haben die Reihenfolge geändert, 
Sachen übersetzt und paraphrasiert und unsere eigenen Gedanken hinzugefügt.

<hr>

### Grammar of Graphs

Das `gg` im Paketnamen `ggplot2` steht für *Grammar of Graphs*. 

Leland Wilkinson ist der Gründer des Grammar of Graphs-Ansatzes. Im Grunde ist das eine Theorie darüber, mit welchen Regeln und Bausteinen statistische Grafiken erstellt werden können [@wilkinson2005].

`ggplot2` ist die Umsetzung dieses theoretischen Baukastens. Es wurde von Hadley Wickham geschrieben und ist ein relativ altes Paket im R-Ökosystem [@wickham2009].

#### benötigtes Paket

::: aufgabe
Der erste Schritt für dieses Tutorial ist, das Paket `ggplot2` in die aktive Sitzung zu laden. Tu das mittels `library()`! 
:::

```{r lib, exercise = TRUE, exercise.cap = "ggplot2 laden"}
library()
```

```{r lib-solution}
library(ggplot2)
```

### Einordnung in den Prozess

Wir haben jetzt Daten erhoben, importiert - und nun? Grafiken sind ein guter Weg, Zusammenhänge in den Daten sichtbar zu machen. Zum einen, um sich selbst in den Daten zu orientieren, und zum anderen auch, um die Ergebnisse der Analyse zu präsentieren. Wir brauchen Visualisierungen also an zwei Stellen im Prozess: 

- einmal um einen **Überblick** zu gewinnen
- am Ende um **Ergebnisse** zu **kommunizieren**

![](images/compress/prozess.png){width=90%}


Welche Grafik du wann anwenden kannst, hängt vom Skalenniveau der Daten und der Anzahl von Variablen ab.

Grob kann unterschieden werden zwischen:

- Plots, die die Verteilung einer einzelnen Variablen darstellen
- Plots, die den Zusammenhang zwischen zwei oder mehr Variablen zeigen

Gehen wir sofort zur Sache!

## 1. Balkendiagramm

::: infobox
Balkendiagramme sind geeignet, um die Verteilung einer einzelnen, kategorialen Variable zu zeigen.

Funktion: `geom_bar()`
:::
<br>

So sieht Code aus, um mit `ggplot2` ein einfaches Balkendiagramm zu erstellen (das schön machen kommt später):

```{r barplot, exercise = TRUE, exercise.cap = "Einfacher Barplot"}
ggplot(data = einkaufen,
       mapping = aes(x = Verkehrsmittel)) +
  geom_bar()
```

Dabei wird deutlich, dass der Code durch eine klare Sprache organisiert ist:

- in `data` übergeben wir einen Datensatz an die Funktion
- in `mapping` sagen wir, welche Variablen aus dem Datensatz wo gezeigt werden. 
- das `+` fügt eine neue Ebene hinzu, genau wie in Photoshop / Gimp / Overhead-Folien
- `geom_bar()` fügt ein `geom`etrisches Objekt, nämlich die Balken (`bar`s), hinzu.

Mehr dazu, wie genau dieses Mapping funktioniert, folgt später.

### Baukasten-Prinzip

Leland Wilkonson, Begründer der *Grammar of Graphs*-Theorie sagt, dass sich jede statistische Grafik durch
diese drei Kernbestandteile beschreiben lässt: 

- `data`
- `aesthetic mapping`
- `geom`etric objects

Mit data kennst du dich ja jetzt schon aus, daher können wir direkt zum *mapping* übergehen.

### aesthetic mapping

Was ist eigentlich dieses `aesthetic mapping`? Das ist das, was wir oben im Code beim Argument `mapping` gemacht haben: `mapping = aes(x = Verkehrsmittel)`

`aes()` steht für *aesthetic attributes*, und weist den einzelnen Variablen, wie z.B. dem Verkehrsmittel, eine *grafische Eigenschaft* zu. Grafische Eigenschaften sind: 

- Achsen (`x`, `y`)
- Farbe (`colour`)
- Füllung (`fill`)
- Größe (`size`)
- Transparenz (`alpha`)

Im Diagramm oben wurde der x-Achse die Variable Verkehrsmittel zugewiesen. 

:::aufgabe
Ändere den Code so, dass die Variable Verkehrsmittel nun stattdessen auf die y-Achse gemappt wird. Wie wird sich das Diagramm wohl verändern?
:::

*Beachte, dass wir hier die Argumentnamen `data` und `mapping` weggelassen haben, so wie es in der Praxis üblicherweise auch getan wird. Das können wir machen, da wir die Reihenfolge der Argumente beachten, also `data`, `mapping` dann `geometric objects`.* 

```{r ybarplot, exercise = TRUE, exercise.cap = "Mapping ändern auf y-Achse"}
ggplot(einkaufen, aes(x = Verkehrsmittel)) +
  geom_bar()
```

```{r ybarplot-solution}
ggplot(einkaufen, aes(y = Verkehrsmittel)) +
  geom_bar()
```

Es gibt, wie oben erwähnt, noch mehr *aesthetic attributes* außer `x`-Achse und `y`-Achse, aber auf die fokussieren wir uns später. 

### `geom_bar`

Und was ist dieses `geom_bar()`? Das wird am ehesten deutlich, wenn wir es weglassen!

::: aufgabe
Schau dir an, wie der Plot aussieht ohne die Ebene mit`geom_bar()`!
:::

```{r plotwithoutgeom, exercise = TRUE, exercise.cap = "Ohne geom"}
ggplot(einkaufen, aes(x = Verkehrsmittel))
```

Jetzt versteht du vielleicht, wofür die `geom_bar()`-Funktion da ist: Geometrische Objekte, in diesem Fall Balken, in den Plot zu zeichnen! Der Plot ist leer, aber die Achsen sind bereits beschriftet und perfekt vorbereitet, aber es fehlt noch das geometrische Objekt. 

Innerhalb der Funktion für das geometrische Objekt finden auch Berechnungen statt, die einzelnen Ausprägungen der Verkehrsmittel werden gezählt, um die Höhe der Balken zu bestimmen. Aber damit müssen wir uns zum Glück nicht beschäftigen. 
Und jetzt kommt das Ding: Es gibt auch noch andere `geom_...()` Funktionen. Zum Beispiel `geom_point()`, welche dem Plot Punkte hinzufügt! Oder `geom_histogram()`, welche ein Histogramm zeichnet, siehe nächster Abschnitt.

Probieren wir das doch einfach mal aus und tauschen `geom_bar()` durch `geom_point()`. 

```{r error, exercise = TRUE, exercise.cap = "Fehlermeldung"}
ggplot(einkaufen, aes(x = Verkehrsmittel)) +
  geom_point()
```

Dass hier eine Fehlermeldung herauskommt, ist völlig normal! Fehlermeldungen sind freundlich, denn Programmierer*innen geben sich (oft) viel Mühe, diese möglichst informativ und genau zu machen. Also hab keine Angst, und lies dir tatsächlich mal durch was da steht!

Schon die erste Zeile gibt dir eine wichtige Information: Der Fehler trat in der Funktion `geom_point()` auf und nicht an irgendeiner anderen Stelle des Plots.

```
Error in `geom_point()`:
```

Manche Sachen verstehst du vielleicht nicht, wie z.B. was `compute_geom_1()` ist, und die beste Strategie für diese Sachen in R ist, sie einfach zu ignorieren und stattdessen Sinn aus den Dingen zu ziehen, die du verstehst!

Die allerletzte Zeile der Meldung ist am informativsten:

```
! `geom_point()` requires the following missing aesthetics: y
```
`geom_point()` braucht die folgenden fehlenden aesthetics: 'y'

Ah, das macht auch Sinn, denn ein Punkt hat immer zwei Koordinaten, eine `x`- und eine `y`-Koordinate! Logischerweise kann kein Punkt gezeichnet werden, wenn du nur eine `x`-Koordinate angibst. 

::: aufgabe
Löse das Problem, indem du in `aes()` noch das Argument `y = Weg` angibst. Denk daran, Argumente werden durch Kommata getrennt. 

"Weg" ist eine stetige Variable, die den zurückgelegten Anreiseweg der Person zum Bioladen, wo die Erhebung stattfand, in km enthält. 
:::

```{r weg, exercise = TRUE, exercise.cap = "aesthetic mapping hinzufügen für y-Achse"}
ggplot(einkaufen, aes(x = Verkehrsmittel)) +
  geom_point()
```

```{r weg-solution}
ggplot(einkaufen, aes(x = Verkehrsmittel, y = Weg)) +
  geom_point()
```

Ok, das Diagramm ist vielleicht nicht ultra informativ, weil ganz viele Punkte übereinandergelagert wurden an manchen Stellen. Es gibt definitiv ein anderes, geeigneteres Diagramm! Hier ging es nur darum, das Prinzip zu beweisen: `ggplot` funktioniert wie ein Baukasten, und das `geom` können wir austauschen, so lange dafür gesorgt wird, dass in den `aes`thetic mappings Variablen und Skalenniveau zu dem jeweiligen `geom` passen!

```{r weg-quest}
question_text("Wie erklärst du dir die weiten Anreisewege (bis 600km!) beim Verkehrsmittel „ÖPNV”? (Tipp: Der Bioladen ist in der Nähe eines ICE-Bahnhofs)",
              answer_fn(\(x) correct(messages = "Vermutlich waren einige Menschen zuvor mit dem ICE gefahren, und hatten vielleicht auch nur einen Umstieg mit Wartezeit und Hunger auf ein Bio-Brötchen oder so. Während der Rest der Menschen ihren regulären Wocheneinnkauf machen und aus der Umgebung kommen, maximal ein paar Kilometer entfernt.")),
              placeholder = "Musterlösung erscheint bei Abgabe deiner Antwort...")
```


## 2. Histogramm

::: infobox
Histogramme sind geeignet, um die Verteilung einer **einzelnen**, stetigen Variable zu zeigen.

Funktion: `geom_histogram()`
:::
<br>

Unser Go-To-Beispiel für eine stetige Variable ist `einkaufen$Alter`, die dir schon in den letzten Tutorials begegnet sein sollte. Beachte, dass du innerhalb von `ggplot`-Code den `$`-Operator nicht benutzen musst. Das liegt daran, dass `ggplot` weiß, in welchem Datensatz die Variable gesucht werden muss, da wir den Datensatz ja im allerersten Argument angeben. 

Hier ist `ggplot2`-Code für ein einfaches, absolut nicht schönes Histogramm. In diesem Abschnitt wird es deswegen auch mal Zeit, über Farben und Verschönerungen zu sprechen. 

```{r hist, exercise = TRUE, exercise.cap = "einfaches Histogramm erstellen"}
ggplot(einkaufen, aes(Alter)) +
  geom_histogram()
```


### Was ist ein Histogramm?

Bei einem Histogramm werden auf der x-Achse die möglichen Ausprägungen der Variable aufgelistet, und auf der y-Achse die Häufigkeit. Es ist also genau das gleiche Prinzip wie bei einem Balkendiagramm, nur dass wir uns hier zusätzlich noch mit der Kategorienbreite (*binwidth*) auseinandersetzen müssen.

Denn: Balkendiagramme sind für diskrete Daten, und diskrete Daten haben natürliche Kategorien. Zum Beispiel ist das Verkehrsmittel ÖPNV etwas anderes als Motorrad - die Kategorien liegen also schon in der Natur der Sache. 

Das ist bei stetigen (kontinuierlichen) Daten anders: Von Natur her gibt es bei stetigen Daten immer unendlich viele mögliche Ausprägungen, und also auch immer unendlich viele mögliche Kategorien. 

Zum Beispiel kann ein Meter in unendlich feine Messeinheiten aufgeteilt werden:

- Meter
- Dezimeter
- Zentimeter
- Millimeter
- Mikrometer
- Nanometer
- Picometer
- Femtometer
- Attometer
...

Da es unendlich Möglichkeiten gibt einen Meter einzuteilen, gehen keine natürlichen Kategorien daraus hervor. Deswegen können die Kategorien beliebig gebildet werden.

Beim Histogramm des Alters oben sind die Balken zum Beispiel immer 2.5 Jahre breit, komplett random also. Darüber informiert `ggplot` auch beim Erstellen des Diagramms mit einer Warnmeldung:

```
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`
```
`ggplot` sagt damit: „Hey, ich habe deine Daten einfach mal in 30 gleich große Kategorien eingeteilt, aber das ist ein default-Wert, den du bitte anpassen solltest.“

### Kategorienbreite anpassen

In der Warnmeldung wurde bereits das Argument `binwidth` erwähnt. Hier ist Code, mit dem die Kategorienbreite auf 5 (Jahre) festgelegt wird. 

```{r binwidth, exercise = TRUE, exercise.cap = "Kategorienbreite einstellen"}
ggplot(einkaufen, aes(x = Alter)) +
  geom_histogram(binwidth = 5)
```

Da die Balken gerade visuell in einer großen grauen Masse verschwinden, wird noch nicht so ganz deutlich worum es eigentlich geht. Deswegen wäre es hilfreich, wenn alle Balken eine schwarze Umrandung hätten und etwas hellgrauer wären. Beachte, dass jetzt nach dem `binwidth`-Argument dafür noch die Argumente `color` und `fill` stehen. 

```{r color, exercise = TRUE, exercise.cap = "Color und Fill"}
ggplot(einkaufen, aes(x = Alter)) +
  geom_histogram(binwidth = 5,
                 color = "black",
                 fill = "grey")
```

Das sieht schon mal ein Stück weit besser aus. Jetzt ist noch etwas störend, dass die Kategorien
nicht bei den markanten Zahlen anfangen, sondern z.B. die 50 in der Mitte einer Kategorie liegt. Dafür kannst du das Argument `boundary` nutzen, um einen Grenzwert zu bestimmen, der die Kategorien an diesem Punkt teilt (sog. "bin break"):

```{r boundary, exercise = TRUE, exercise.cap = "Boundary-Argument"}
ggplot(einkaufen, aes(x = Alter)) +
  geom_histogram(binwidth = 5,
                 boundary = 50,
                 color = "black",
                 fill = "grey")
```

## 3. Boxplot

::: infobox
Ein Boxplot ist eine effektive Methode, um die Verteilung von einer oder mehrerer stetiger Variablen zu visualisieren und Ausreißer zu identifizieren.

Funktion: geom_boxplot()
:::
<br>

Du erinnerst dich vielleicht daran im letzten Tutorial selbst bereits einen Boxplot gezeichnet zu haben. Hier noch einmal die Übersicht, welche Daten in einem Boxplot enthalten sind:

![](images/boxplot.png){width=90%}

Zum Glück wird es jetzt mit einem kleinen Codeschnipsel für uns erstellt, ohne dass wir es alles händisch vorher ermitteln müssten. 

```{r boxplot-Beispiel, exercise = TRUE, exercise.cap = "Boxplot Beispiel"}
ggplot(einkaufen, aes(y = Alter)) +
  geom_boxplot()
```


::: aufgabe
Probiere es doch mal aus, und schaue welche Daten aus dem Beispieldatensatz `einkaufen` du dir gut als Boxplot anzeigen lassen kannst. 
:::

Hier eine Auflistung der Variabelnamen:

```{r}
names(einkaufen)
```


```{r boxplot, exercise = TRUE, exercise.cap = "Boxplot Exploration"}
ggplot(einkaufen, aes(y = )) +
  geom_boxplot()
```

<!-- Quizz: Welche der folgenden Variablen eignen sich für einen Boxplot -->
<!-- Answer: Alter und Weg. Message: kontinuierliche Variablen! -->

### Farbanpassung und Verbesserungen

Wie bei anderen Diagrammen kannst du Farben und Stile anpassen, um die Lesbarkeit zu verbessern. Hier werden die Boxen in unterschiedlichen Graustufen dargestellt und die Whiskers sind schwarz:

```{r boxplotColor, exercise = TRUE, exercise.cap = "Boxplot mit Farbe"}
ggplot(einkaufen, aes(y = Alter)) +
  geom_boxplot(color = "blue", fill = "gray", alpha = 0.5) 
```


## 4. Punktdiagramm

::: infobox
Punktdiagramme sind geeignet, um die Zusammenhänge zweier numerischen Variablen zu zeigen.

Funktion: `geom_point()`
:::
<br>

## 5. Liniendiagramm

::: infobox
Liniendiagramme sind geeignet, um zwei numerische Variablen zu Visualisieren. Die x-Variable 
hat dabei häufig eine sequentielle Reihenfolge (wie z.B. die Zeit).

Funktion: `geom_line()`
:::
<br>

## 6. Special: Facets

::: infobox
Facets sind geeignet, um 

Funktion: `facet()`
:::
<br>

## 7. Special: Jitter

## Überblick bekommen

Wie zu Beginn erwähnt benutzen wir diese Visualisierungen für zweierlei Zwecke:

- einmal um einen **Überblick** zu gewinnen
- am Ende um **Ergebnisse** zu **kommunizieren**

Es lassen sich eigentlich alle Grafiken nuzten, um Ergebnisse zu kommunizieren, aber welche eignen sich dafür einen Überblick zu bekommen, um deine (zunächst unverständlich großen) Daten besser zu verstehen? Hier nur eine kurze Auflistung: 

1. *Histogramme*:
Zweck: Zeigt die Verteilung der Daten.
Verwendung: Geeignet, um die Form der Verteilung, Zentralität und Streuung zu untersuchen.

2. *Boxplots*:
Zweck: Veranschaulicht die Verteilung und Zentralität der Daten sowie Ausreißer.
Verwendung: Besonders hilfreich bei der Identifizierung von Ausreißern.

3. *Streudiagramme* (Scatter Plots):
Zweck: Zeigt die Beziehung zwischen zwei kontinuierlichen Variablen.
Verwendung: Ermöglicht die Identifizierung von Mustern, Korrelationen oder Ausreißern.

Dieser Art der Nutzung von Visualisierungen wirst du in späteren Tutorials erneut begegnen, wenn wir diese zur Überprüfung der Voraussetzungen für eine statistische Testgröße verwenden. Jetzt hast du es bereits schon einmal gehört - oder eher *gelesen* - und weißt dann, wenn die Zeit gekommen ist, schon Bescheid was da passiert. 


## Barrierefreiheit

Noch ein letztes Kapitel, dass nicht vernachlässigt werden sollte, wenn es um visuelle Darstellung geht: die Barrierefreiheit.

Ein nicht zu vernachlässigender Anteil der Bevölkerung kann bestimmte Farben nicht unterscheiden. Deswegen wurden von schlauen Menschen Farbpaletten entworfen, die keine ambivalenten Farben wie rot und grün enthalten, und auch ganz ohne Farbwahrnehmung nur über Helligkeit und Dunkelheit der Farben in schwarz weiß funktionieren würden. 

Eine der verbreitetesten ist `viridis`.

### Viridis

```{r viridis-demo, message=FALSE, warning=FALSE}
library(ggplot2)
library(hexbin)
library(viridis)

dat <- data.frame(x = rnorm(10000), y = rnorm(10000))

p <- ggplot(dat, aes(x = x, y = y)) +
  geom_hex() + coord_fixed() +
  scale_fill_gradientn(colours = viridis(256, option = "D")) +
  theme_bw()

p
```

Die obenstehende Grafik ist ein gutes Beispiel dafür, wie hell-dunkel Kontraste verwendet werden können. So ist das Ganze in schwarz-weiß immer noch lesbar, was insbesondere für Menschen mit eingeschränkter Farbwahrnehmung klasse ist, denn alles was schwarz weiß gut lesbar ist, ist immer auch colorblind-friendly. 

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```



## Credit

### Literaturverzeichnis

fehlt:  Modern Dive (Ismay and Kim 2022)

