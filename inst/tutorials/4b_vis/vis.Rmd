---
title: "Visualisierung"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Schnelle Diagramme erstellen, schöne Diagramme erstellen. Die Grammar of Graphs wird kurz erklärt, das Prinzip wonach ggplot2 aufgebaut ist. Die Erstellung verschiedener Diagrammarten wird geübt. Aesthetic Mappings, Geoms, Facets. 
resource_files:
- css/boxes.css
tutorial:
      id: ggplot
      version: 1
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(kableExtra)
library(tibble)
library(rtutorials)
knitr::opts_chunk$set(echo = FALSE)

```

## Inhalt

Jetzt kommt wirklich einer der allercoolsten Teile des ganzen Kurses. R ist einfach
unfassbar mächtig, was das Visualisieren von Daten angeht, viel ausgefeilter und vielfältiger, als
Excel und SPSS es je erreichen können. Unser Ziel ist euch ein paar schnelle Kochrezepte für die wichtigsten
Visualisierungsaufgaben mitzugeben, und die Neugier auf mehr zu wecken, in dem wir eine kleine Einführung in das Visualisierungspaket `ggplot2` geben.

Mit R sind abgefahrene Sachen möglich. Eine vielfältige Übersicht darüber, was alles geht, erhältst du in der [R Graph Gallery](https://r-graph-gallery.com/). Hier sind ein paar Beispiele:

#### [Eine Karte im Stil von Jacques Bertin](https://r-graph-gallery.com/web-valued-dots-map-bertin.html)

![](images/compress/bertin.png){width=80%}

#### [Heatmap stündliche Temperatur über zwei Jahre](https://r-graph-gallery.com/283-the-hourly-heatmap.html)

![](images/compress/temp.png){width=80%}

Ziemlich beeindruckend, oder?
Das soll hier aber nur ein kleiner Einblick in das sein, was alles möglich ist.  In diesem Tutorial starten natürlich bei den Basics und focussieren uns darauf grundständige Diagramme zu zeichnen. Mit diesem Grundwissen kannst du dir dann auch selbst beibringen solche abgefahrenen Diagramme zu erstellen.
In den Links über den Grafiken findest du detaillierte Anleitungen, wenn du dann soweit bist.

Wie gesagt, wir fangen Schritt für Schritt an und daher sind das hier die Ziele für heute: 

### Lernziele

<input type="checkbox" unchecked> Punktdiagramm (*scatterplot*) erstellen </input>

<input type="checkbox" unchecked> Balkendiagramm (*barplot*) erstellen </input>

<input type="checkbox" unchecked> Histogramm (*histogram*) erstellen </input>

<input type="checkbox" unchecked> Liniendiagramm (*linegraph*) erstellen </input>

<input type="checkbox" unchecked> Boxplot erstellen </input>

<input type="checkbox" unchecked> Schnelle Grafikfunktionen, um einen Überblick zu gewinnen </input>

<input type="checkbox" unchecked> Grafiken mit `ggplot2` nach dem Baukasten der *Grammar of Graphs* erstellen </inpu>

<input type="checkbox" unchecked> colorblind-friendly sein </input>

### Die fünf essentiellen Diagrammtypen

```{r echo=FALSE}
de <- c("Punktdiagramm","Liniendiagramm","Histogramm","Boxplot","Balkendiagramm")
en <- c("scatterplot","linegraph", "histogram", "boxplot", "barplot")
vars <- c("2 stetige Variablen", "1 stetige und 1 zeitlich geordnete Variable",
          "1 stetige Variable", "1 stetige Variable mit Gruppen", "1 kategoriale Variable")
tibble(` `= c("1.", "2.", "3.", "4.", "5."), de, en, `geeignet für` = vars) |>
  kbl() |>
  kable_styling()
```

```{r fiveplots, fig.height=8, out.width="100%"}
par(mfrow = c(3, 2),
    bty = "n")
plot(heated[ ,c("maxtemp", "edvisits")],
     main = "1.",
     axes = F,
     ylab = NA,
     xlab = NA)
plot(heated$enddate[heated$enddate > as.Date("2022-03-24")], 
     heated$maxtemp[heated$enddate > as.Date("2022-03-24")],
     type = "l",
     main = "2.",
     axes = F,
     ylab = NA,
     xlab = NA)
hist(heated$maxtemp,
     main = "3.",
     axes = F,
     ylab = NA,
     xlab = NA)
boxplot(heated$maxtemp ~ factor(lubridate::month(heated$enddate)),
        main = "4.",
        axes = F,
        ylab = NA,
        xlab = NA)
barplot({einkaufen$Verkehrsmittel |> table()}[1:5],
        main = "5.",
        axes = F,
        ylab = NA,
        xlab = NA,
        names.arg = NA)
# reset par
par(mfrow = c(1, 1),
    bty = "o")
```

## Einführung

Es gibt (wie immer) tausend verschiedene Wege, Visualisierungen mit R zu erstellen. Aber einer hat sich über die Jahre als besonders Beliebt erwiesen, und das ist `ggplot2`. 

Der Grund, warum wir dir diesen Weg beibringen:

- Er folgt einem klaren Baukastenprinzip, mit dem auch später beliebig komplexe Anpassungen der Grafik an die eigenen Vorstellungen relativ schmerzfrei umgesetzt werden können. 

- Es ist der populärste Weg, es gibt auf Google viele gute Anleitungen und Antworten. Und es existieren zahlreiche Eweiterungen um das Paket `ggplot2`. 

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verfügbaren Online-Lehrbuch namens [*Modern Dive*](https://www.moderndive.com) [@ismay2022]. Wir haben die Reihenfolge geändert, 
Sachen übersetzt und paraphrasiert und unsere eigenen Gedanken hinzugefügt.

<hr>

### Grammar of Graphs

Das `gg` im Paketnamen `ggplot2` steht für *Grammar of Graphs*. 

Leland Wilkinson ist der Gründer des Grammar of Graphs-Ansatzes. Im Grunde ist das eine Theorie darüber, mit welchen Regeln und Bausteinen statistische Grafiken erstellt werden können [@wilkinson2005].

`ggplot2` ist die Umsetzung dieses theoretischen Baukastens. Es wurde von Hadley Wickham geschrieben und ist ein relativ altes Paket im R-Ökosystem [@wickham2009].

#### benötigtes Paket

::: aufgabe
Der erste Schritt für dieses Tutorial ist, das Paket `ggplot2` in die aktive Sitzung zu laden. Tu das mittels `library()`! 
:::

```{r lib, exercise = TRUE, exercise.cap = "ggplot2 laden"}
library()
```

```{r lib-solution}
library(ggplot2)
```

### Einordnung in den Prozess

Wir haben jetzt Daten erhoben, importiert - und nun? Grafiken sind ein guter Weg, Zusammenhänge in den Daten sichtbar zu machen. Zum einen, um sich selbst in den Daten zu orientieren, und zum anderen auch, um die Ergebnisse der Analyse zu präsentieren. Wir brauchen Visualisierungen also an zwei Stellen im Prozess: 

- einmal um einen **Überblick** zu gewinnen
- am Ende um **Ergebnisse** zu **kommunizieren**

![](images/compress/prozess.png){width=90%}


Welche Grafik du wann anwenden kannst, hängt vom Skalenniveau der Daten und der Anzahl von Variablen ab.

Grob kann unterschieden werden zwischen:

- Plots, die die Verteilung einer einzelnen Variablen darstellen
- Plots, die den Zusammenhang zwischen zwei oder mehr Variablen zeigen

Gehen wir sofort zur Sache!

## 1. Balkendiagramm

::: infobox
Balkendiagramme sind geeignet, um die Verteilung einer einzelnen, kategorialen Variable zu zeigen.

Funktion: `geom_bar()`
:::
<br>

So sieht Code aus, um mit `ggplot2` ein einfaches Balkendiagramm zu erstellen (das schön machen kommt später):

```{r barplot, exercise = TRUE, exercise.cap = "Einfacher Barplot"}
ggplot(data = einkaufen,
       mapping = aes(x = Verkehrsmittel)) +
  geom_bar()
```

Dabei wird deutlich, dass der Code durch eine klare Sprache organisiert ist:

- in `data` übergeben wir einen Datensatz an die Funktion
- in `mapping` sagen wir, welche Variablen aus dem Datensatz wo gezeigt werden. 
- das `+` fügt eine neue Ebene hinzu, genau wie in Photoshop / Gimp / Overhead-Folien
- `geom_bar()` fügt ein `geom`etrisches Objekt, nämlich die Balken (`bar`s), hinzu.

Mehr dazu, wie genau dieses Mapping funktioniert, folgt später.

### Baukasten-Prinzip

Leland Wilkonson, Begründer der *Grammar of Graphs*-Theorie sagt, dass sich jede statistische Grafik durch
diese drei Kernbestandteile beschreiben lässt: 

- `data`
- `aesthetic mapping`
- `geom`etric objects

Mit data kennst du dich ja jetzt schon aus, daher können wir direkt zum *mapping* übergehen.

### aesthetic mapping

Was ist eigentlich dieses `aesthetic mapping`? Das ist das, was wir oben im Code beim Argument `mapping` gemacht haben: `mapping = aes(x = Verkehrsmittel)`

`aes()` steht für *aesthetic attributes*, und weist den einzelnen Variablen, wie z.B. dem Verkehrsmittel, eine *grafische Eigenschaft* zu. Grafische Eigenschaften sind: 

- Achsen (`x`, `y`)
- Farbe (`colour`)
- Füllung (`fill`)
- Größe (`size`)
- Transparenz (`alpha`)

Im Diagramm oben wurde der x-Achse die Variable Verkehrsmittel zugewiesen. 

:::aufgabe
Ändere den Code so, dass die Variable Verkehrsmittel nun stattdessen auf die y-Achse gemappt wird. Wie wird sich das Diagramm wohl verändern?
:::

*Beachte, dass wir hier die Argumentnamen `data` und `mapping` weggelassen haben, so wie es in der Praxis üblicherweise auch getan wird. Das können wir machen, da wir die Reihenfolge der Argumente beachten, also `data`, `mapping` dann `geometric objects`.* 

```{r ybarplot, exercise = TRUE, exercise.cap = "Mapping ändern auf y-Achse"}
ggplot(einkaufen, aes(x = Verkehrsmittel)) +
  geom_bar()
```

```{r ybarplot-solution}
ggplot(einkaufen, aes(y = Verkehrsmittel)) +
  geom_bar()
```

Es gibt, wie oben erwähnt, noch mehr *aesthetic attributes* außer `x`-Achse und `y`-Achse, aber auf die fokussieren wir uns später. 

### `geom_bar`

Und was ist dieses `geom_bar()`? Das wird am ehesten deutlich, wenn wir es weglassen!

::: aufgabe
Schau dir an, wie der Plot aussieht ohne die Ebene mit`geom_bar()`!
:::

```{r plotwithoutgeom, exercise = TRUE, exercise.cap = "Ohne geom"}
ggplot(einkaufen, aes(x = Verkehrsmittel))
```

Jetzt versteht du vielleicht, wofür die `geom_bar()`-Funktion da ist: Geometrische Objekte, in diesem Fall Balken, in den Plot zu zeichnen! Der Plot ist leer, aber die Achsen sind bereits beschriftet und perfekt vorbereitet, aber es fehlt noch das geometrische Objekt. 

Innerhalb der Funktion für das geometrische Objekt finden auch Berechnungen statt, die einzelnen Ausprägungen der Verkehrsmittel werden gezählt, um die Höhe der Balken zu bestimmen. Aber damit müssen wir uns zum Glück nicht beschäftigen. 
Und jetzt kommt das Ding: Es gibt auch noch andere `geom_...()` Funktionen. Zum Beispiel `geom_point()`, welche dem Plot Punkte hinzufügt! Oder `geom_histogram()`, welche ein Histogramm zeichnet, siehe nächster Abschnitt.

Probieren wir das doch einfach mal aus und tauschen `geom_bar()` durch `geom_point()`. 

```{r error, exercise = TRUE, exercise.cap = "Fehlermeldung"}
ggplot(einkaufen, aes(x = Verkehrsmittel)) +
  geom_point()
```

Dass hier eine Fehlermeldung herauskommt, ist völlig normal! Fehlermeldungen sind freundlich, denn Programmierer*innen geben sich (oft) viel Mühe, diese möglichst informativ und genau zu machen. Also hab keine Angst, und lies dir tatsächlich mal durch was da steht!

Schon die erste Zeile gibt dir eine wichtige Information: Der Fehler trat in der Funktion `geom_point()` auf und nicht an irgendeiner anderen Stelle des Plots.

```
Error in `geom_point()`:
```

Manche Sachen verstehst du vielleicht nicht, wie z.B. was `compute_geom_1()` ist, und die beste Strategie für diese Sachen in R ist, sie einfach zu ignorieren und stattdessen Sinn aus den Dingen zu ziehen, die du verstehst!

Die allerletzte Zeile der Meldung ist am informativsten:

```
! `geom_point()` requires the following missing aesthetics: y
```
`geom_point()` braucht die folgenden fehlenden aesthetics: 'y'

Ah, das macht auch Sinn, denn ein Punkt hat immer zwei Koordinaten, eine `x`- und eine `y`-Koordinate! Logischerweise kann kein Punkt gezeichnet werden, wenn du nur eine `x`-Koordinate angibst. 

::: aufgabe
Löse das Problem, indem du in `aes()` noch das Argument `y = Weg` angibst. Denk daran, Argumente werden durch Kommata getrennt. 

"Weg" ist eine stetige Variable, die den zurückgelegten Anreiseweg der Person zum Bioladen, wo die Erhebung stattfand, in km enthält. 
:::

```{r weg, exercise = TRUE, exercise.cap = "aesthetic mapping hinzufügen für y-Achse"}
ggplot(einkaufen, aes(x = Verkehrsmittel)) +
  geom_point()
```

```{r weg-solution}
ggplot(einkaufen, aes(x = Verkehrsmittel, y = Weg)) +
  geom_point()
```

Ok, das Diagramm ist vielleicht nicht ultra informativ, weil ganz viele Punkte übereinandergelagert wurden an manchen Stellen. Es gibt definitiv ein anderes, geeigneteres Diagramm! Hier ging es nur darum, das Prinzip zu beweisen: `ggplot` funktioniert wie ein Baukasten, und das `geom` können wir austauschen, so lange dafür gesorgt wird, dass in den `aes`thetic mappings Variablen und Skalenniveau zu dem jeweiligen `geom` passen!

```{r weg-quest}
question_text("Wie erklärst du dir die weiten Anreisewege (bis 600km!) beim Verkehrsmittel „ÖPNV”? (Tipp: Der Bioladen ist in der Nähe eines ICE-Bahnhofs)",
              answer_fn(\(x) correct(messages = "Vermutlich waren einige Menschen zuvor mit dem ICE gefahren, und hatten vielleicht auch nur einen Umstieg mit Wartezeit und Hunger auf ein Bio-Brötchen oder so. Während der Rest der Menschen ihren regulären Wocheneinnkauf machen und aus der Umgebung kommen, maximal ein paar Kilometer entfernt.")),
              placeholder = "Musterlösung erscheint bei Abgabe deiner Antwort...")
```


## 2. Histogramm

::: infobox
Histogramme sind geeignet, um die Verteilung einer **einzelnen**, stetigen Variable zu zeigen.

Funktion: `geom_histogram()`
:::
<br>

Unser Go-To-Beispiel für eine stetige Variable ist `einkaufen$Alter`, die dir schon in den letzten Tutorials begegnet sein sollte. Beachte, dass du innerhalb von `ggplot`-Code den `$`-Operator nicht benutzen musst. Das liegt daran, dass `ggplot` weiß, in welchem Datensatz die Variable gesucht werden muss, da wir den Datensatz ja im allerersten Argument angeben. 

Hier ist `ggplot2`-Code für ein einfaches, absolut nicht schönes Histogramm. In diesem Abschnitt wird es deswegen auch mal Zeit, über Farben und Verschönerungen zu sprechen. 

```{r hist, exercise = TRUE, exercise.cap = "einfaches Histogramm erstellen"}
ggplot(einkaufen, aes(Alter)) +
  geom_histogram()
```


### Was ist ein Histogramm?

Bei einem Histogramm werden auf der x-Achse die möglichen Ausprägungen der Variable aufgelistet, und auf der y-Achse die Häufigkeit. Es ist also genau das gleiche Prinzip wie bei einem Balkendiagramm, nur dass wir uns hier zusätzlich noch mit der Kategorienbreite (*binwidth*) auseinandersetzen müssen.

Denn: Balkendiagramme sind für diskrete Daten, und diskrete Daten haben natürliche Kategorien. Zum Beispiel ist das Verkehrsmittel ÖPNV etwas anderes als Motorrad - die Kategorien liegen also schon in der Natur der Sache. 

Das ist bei stetigen (kontinuierlichen) Daten anders: Von Natur her gibt es bei stetigen Daten immer unendlich viele mögliche Ausprägungen, und also auch immer unendlich viele mögliche Kategorien. 

Zum Beispiel kann ein Meter in unendlich feine Messeinheiten aufgeteilt werden:

- Meter
- Dezimeter
- Zentimeter
- Millimeter
- Mikrometer
- Nanometer
- Picometer
- Femtometer
- Attometer
...

Da es unendlich Möglichkeiten gibt einen Meter einzuteilen, gehen keine natürlichen Kategorien daraus hervor. Deswegen können die Kategorien beliebig gebildet werden.

Beim Histogramm des Alters oben sind die Balken zum Beispiel immer 2.5 Jahre breit, komplett random also. Darüber informiert `ggplot` auch beim Erstellen des Diagramms mit einer Warnmeldung:

```
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`
```
`ggplot` sagt damit: „Hey, ich habe deine Daten einfach mal in 30 gleich große Kategorien eingeteilt, aber das ist ein default-Wert, den du bitte anpassen solltest.“

### Kategorienbreite anpassen

In der Warnmeldung wurde bereits das Argument `binwidth` erwähnt. Hier ist Code, mit dem die Kategorienbreite auf 5 (Jahre) festgelegt wird. 

```{r binwidth, exercise = TRUE, exercise.cap = "Kategorienbreite einstellen"}
ggplot(einkaufen, aes(x = Alter)) +
  geom_histogram(binwidth = 5)
```

Da die Balken gerade visuell in einer großen grauen Masse verschwinden, wird noch nicht so ganz deutlich worum es eigentlich geht. Deswegen wäre es hilfreich, wenn alle Balken eine schwarze Umrandung hätten und etwas hellgrauer wären. Beachte, dass jetzt nach dem `binwidth`-Argument dafür noch die Argumente `color` und `fill` stehen. 

```{r color, exercise = TRUE, exercise.cap = "Color und Fill"}
ggplot(einkaufen, aes(x = Alter)) +
  geom_histogram(binwidth = 5,
                 color = "black",
                 fill = "grey")
```

Das sieht schon mal ein Stück weit besser aus. Jetzt ist noch etwas störend, dass die Kategorien
nicht bei den markanten Zahlen anfangen, sondern z.B. die 50 in der Mitte einer Kategorie liegt. Dafür kannst du das Argument `boundary` nutzen, um einen Grenzwert zu bestimmen, der die Kategorien an diesem Punkt teilt (sog. "bin break"):

```{r boundary, exercise = TRUE, exercise.cap = "Boundary-Argument"}
ggplot(einkaufen, aes(x = Alter)) +
  geom_histogram(binwidth = 5,
                 boundary = 50,
                 color = "black",
                 fill = "grey")
```

## 3. Boxplot

::: infobox
Ein Boxplot ist eine effektive Methode, um die Verteilung **einer stetigen** Variable zu visualisieren und Ausreißer zu identifizieren.

Funktion: `geom_boxplot()`
:::
<br>

Du erinnerst dich vielleicht daran im letzten Tutorial selbst bereits einen Boxplot gezeichnet zu haben. Hier noch einmal die Übersicht, welche Daten in einem Boxplot enthalten sind:

![](images/boxplot.png){width=90%}
[image source](https://leansigmacorporation.com/box-plot-with-minitab/)

Zum Glück wird es jetzt mit einem kleinen Codeschnipsel für uns erstellt, ohne dass wir es alles händisch vorher ermitteln müssten. 

```{r boxplot-Beispiel, exercise = TRUE, exercise.cap = "Boxplot Beispiel"}
ggplot(einkaufen, aes(y = Alter)) +
  geom_boxplot()
```

Ok, dieser Boxplot ist sehr breit und dafür auch nicht so besonders informativ. 
Da würde ein Histogramm vom Gefühl her besser geeignet sein, um Informationen über die Verteilung **einer** einzelnen Variablen zeigen. 

Spannend wird es, wenn noch eine weitere **kategoriale** Variable hinzukommt, erst dann
wird wirklich sichtbar, wozu Boxplots gut sind.
Hier nehmen wir „Verkehrsmittel“ als kategoriale Variable, und für jedes Verkehrsmittel
ergibt sich nun eine eigene Altersverteilung. Da zeigen sich dann die ersten Zusammenhänge!

```{r}
ggplot(einkaufen, aes(x = Verkehrsmittel, y = Alter)) +
  geom_boxplot()
```

```{r question_boxplot}
quiz(caption = "Interpretation üben",
question_radio("Wie ist das obere und untere Ende der Box bei den Autofahrenden zu interpretieren? Der untere Rand der Box liegt ungefähr bei 37, der obere bei ca. 60 Jahren.",
               answer("Diese Altersspanne umfasst die mittleren 50% der Autofahrenden",
                      correct = TRUE,
                      message = "Das entspricht der IQR (*interquartile range*), also dem Abstand zwischen drittem und erstem Quartil, oder anders gesagt zwischen dem 75%-Quantil und dem 25%-Quantil."),
               answer("Diese Altersspanne umfasst die mittleren 75% der Autofahrenden",
                      message = "Das obere Ende der Box kennzeichnet das 75%-Quantil oder auch drittes Quartil, das untere das 25%-Quantil oder auch 1. Quartil. Der Abstand zwischen 75 und 25 % beträgt 50%."),
               answer("Diese Altersspanne umfasst die mittleren 25% der Autofahrenden",
                      message = "Das obere Ende der Box kennzeichnet das 75%-Quantil oder auch drittes Quartil, das untere das 25%-Quantil oder auch 1. Quartil. Der Abstand zwischen 75 und 25 % beträgt 50%."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question_numeric("Wie lautet der Median des Alters aller Autofahrenden? (grob)",
                 answer(50, correct = TRUE),
                 tolerance = 2,
                 allow_retry = T,
                 incorrect = "Der Median ist der dicke Strich in der Mitte der Box."),

question_radio("Wie ist der Median zu interpretieren?",
               answer("Der Median ist das Alter, was die Autofahrenden in zwei gleich große Hälften teilt", correct = TRUE, message = 
                        "Dabei wird die Box ja gar nicht in zwei gleich große Teile geteilt! Aber trotzdem hast du es richtig erkannt."),
               answer("Der Median ist der Punkt, wo die Alterskurve ein Plateau erreicht", message = "Diese Antwort hat nichts mit der Realität zu tun"),
               answer("Der Median darf hier nicht interpretiert werden, da das Alter stetig ist.", message = "Der Median darf zwar bereits für ordinale, diskrete Daten berechnet werden, aber das heißt nicht dass er für höhere Skalenniveaus verboten ist."),
               allow_retry = T,
               random_answer_order = T,
               incorrect = "Leider nicht richtig, probier es noch mal!"),
question_radio("Zeigt der Boxplot die Gruppengröße jedes Verkehrsmittels?",
               answer("Nein, es wird nur die Verteilung gezeigt, aber nicht auf wie vielen Datenpunkten diese Verteilung beruht!",
                      correct = TRUE,
                      message = "Das schauen wir uns im nächsten Abschnitt genauer an."),
               answer("Ja, die Größe der Box kennzeichnet auch die Anzahl an Personen.",
                      message = "Das ist leider falsch. Ganz im Gegenteil. Wenn die Box sehr klein ist, können das tausende von Personen sein, die einfach alle innerhalb einer sehr geringen Altersspanne liegen."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               incorrect = random_encouragement(language = "de"))
)
```

### \# Show your data!

Der obige Boxplot hat einen großen Nachteil: Es ist nicht zu sehen, wie viele Personen in jeder Gruppe sind. Dabei wissen wir eigentlich, dass die Gruppengröße der unterschiedlichen Verkehrsmittel
unterschiedlich ist. Manchmal wird halt ein ganzer Boxplot gezeichnet, während lediglich
4 Personen dahinter stehen, und er ist nicht zu unterscheiden von einem für ein Verkehrsmittel, was 100 Menschen nutzen. Genau hier können wir die die Magie von R nutzen, um unsere Visualisierung nach unseren Wünschen zu ändern. 

Mit einem kleinen Befehl (`geom_jitter()`), lassen sich über unsere Boxplots noch die Informationen der Datenpunkte legen. Mehr dazu in einem späteren Kapitel. 

```{r showyourdata, echo=TRUE}
ggplot(einkaufen, aes(x = Verkehrsmittel, y = Alter)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.2, 
              width = 0.1, 
              size = 3)
```

Achte mal auf das Verkehrsmittel "Andere". Dort gibt es wirklich nur eine handvoll Punkte,
aber die Box ist kaum von den anderen Verkehrsmitteln zu unterscheiden. Aber mithilfe der Punkte können wir nun sehen, dass dort weit weniger Datenpunkte vorliegen und wir daher bei der Interpretation dieser Gruppe Vorsicht walten lassen sollten.

::: aufgabe
Probiere es doch mal aus, und schaue welche anderen zwei Variablen aus dem Beispieldatensatz `einkaufen` du gut für ein Boxplot nutzen kannst. 
:::

</br>

Hier eine Auflistung der Variablennamen:

```{r}
names(einkaufen)
```


```{r boxplot, exercise = TRUE, exercise.cap = "Boxplot Exploration"}
ggplot(einkaufen, aes(x = , y =  )) +
  geom_boxplot()
```


```{r boxplot-quest}
question_text("Welche Variablen hast du gefunden, die sich für einen Boxplot mit 2 Variablen eignen",
              answer_fn(\(x) correct(messages = "Wie oben erwähnt, ist es am aussagekräftigsten eine kontinuierliche Variable und eine kategoriale Variable zu verwenden. Zum Beispiel Ort (kategorial) und Weg (kontinuierlich).")),
              placeholder = "Musterlösung erscheint bei Abgabe deiner Antwort...")
```


## 4. Punktdiagramm

::: infobox
Punktdiagramme sind geeignet, um die Zusammenhänge zweier numerischen Variablen zu zeigen.

Funktion: `geom_point()`
:::
<br>

## 5. Liniendiagramm

::: infobox
Liniendiagramme sind geeignet, um zwei numerische Variablen zu Visualisieren. Die x-Variable 
hat dabei häufig eine sequentielle Reihenfolge (wie z.B. die Zeit).

Funktion: `geom_line()`
:::
<br>

## 6. Special: Facets

::: infobox
Facets sind geeignet, um 

Funktion: `facet()`
:::
<br>

## 7. Special: Jitter

## Becoming a Pro

In Zukunft möchtest du wahrscheinlich deine eigenen Visualisierungen ganz nach deinen Wünschen gestalten,  - darum geht es ja hier auch! Denn diese Basics sind zwar schon hilfreich, aber beeindruckend und besonders ästhetisch sind sie noch nicht. 

Also wie kommst du zum nächsten Level? - Recherche! Informiere dich im Internet was für deine Zwecke möglich ist und passe den Beispielcode auf deine Daten an. (Das gilt übrigens für alle Tutorials und Alles, was du hier in diesem Kurs lernst). 

In den ersten Tutorials haben wir dir bereits *Cheat Sheets* verlinkt und auch zu Beginn dieses Tutorials die super hilfreiche Seite [R Graph Gallery](https://r-graph-gallery.com/) empfohlen. 

**Cheat Sheets** 
Sind eine fantastische erste Anlaufstelle, wenn du dir Zeit nimmst sie zu verstehen. Sie geben dir für ein bestimmtes Paket einen guten Überblick zu den vielzähligen Funktionen und deren Code. Somit fungieren Sie wie die `Hilfe` Seite einer Funktion oder eines Paketes, das für dich visuell aufbereitet wurde.

Hier kannst du die [von R Studio erstellten Cheat Sheets](https://rstudio.github.io/cheatsheets/) finden. Es gibt aber auch noch weitere *Cheat Sheets* von anderen Instanzen. 

::: aufgaberstudio
Hier mal eine besondere Aufgabe: Schau dir das [ggplot Cheat Sheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf) genau an und beantworte dann folgende Fragen.
:::

</br>

```{r question_cheatsheet}
quiz(caption = "Das Cheat Sheet verstehen",
question_checkbox("In der Box zu Basics hast du gelernt, dass diese Funktionen notwendig zur Erstellung einer Grafik sind:",
               answer("ggplot(data= <DATA>)",
                      correct = TRUE,
                      message = "Wir brauchen Daten, die wir visualiesieren können."),
               answer("stat = <STAT>",
                      message = "Die Nutzung von in der ggplot-Funktion neu berechneten Statistiken ist kein muss."),
               answer("mapping = aes( <MAPPINGS> )",
                      correct = TRUE,
                      message = "Wir brauchen natürlich auch `aes` für ein Koordinatensystem."),
                answer("<GEOM_FUNCTION>",
                       correct = TRUE,
                      message = "Die `geom` Funktion brauchen wir für das Einzeichnen unserer Datenpunkte."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),


question_radio("Welche Art von Variablen wird für die Funktion `g + geom_count()` benötigt?",
               answer("Zwei diskrete Variablen", 
                      correct = TRUE, 
                      message = "Das Cheat Sheet ist so aufgebaut, dass die Buchstaben vor den Funktionen (z.B. das `g +` vor geom_count) im Abschnitt `Geoms` für die entsprechenden Skalenniveaus und Anzahl der Variablen stehen."),
               answer("Eine kontinuierliche Variable"),
               answer("Zwei kontinuierliche Variablen"),
               allow_retry = T,
               random_answer_order = T,
               incorrect = "Leider nicht richtig, probier es noch mal!"),

question_radio("Wie kannst du deiner Grafik eine Legende hinzufügen?",
               answer("labs(x = , y = )",
                      correct = TRUE,
                      message = "Richtig, du kannst für die jeweiligen Variablen auf Achse x und y eine Legende einfügen lassen."),
               answer("labels(x = , y =)"),
               answer("leg(x = , y =)"),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               incorrect = random_encouragement(language = "de"))
)
```


### Farbanpassung und Verbesserungen

Da du jetzt vertraut mit dem Sheet Cheat bist, versuche herauszufinden, wie du die Farben deiner Grafik 

Wie bei anderen Diagrammen kannst du Farben und Stile anpassen, um die Lesbarkeit zu verbessern. Dafür kannst du in der Funktion `geom_boxplot()` u.a. die Argumente `color`, `fill` und `alpha` nutzen.

```{r boxplotColor, exercise = TRUE, exercise.cap = "Boxplot mit Farbe"}
library(viridis)

ggplot(einkaufen, aes(x = Ort, y = Alter, fill = Ort)) +
  geom_boxplot() +
  scale_fill_viridis_d(alpha = 0.7)
```

## Überblick bekommen

Wie ganz zu Beginn erwähnt, benutzen wir Visualisierungen für zweierlei Zwecke:

- einmal um einen **Überblick** zu gewinnen
- am Ende um **Ergebnisse** zu **kommunizieren**

Es lassen sich eigentlich alle Grafiken nuzten, um Ergebnisse zu kommunizieren, aber welche eignen sich dafür einen Überblick zu bekommen, um deine (zunächst unverständlich großen) Daten besser zu verstehen? Hier nur eine kurze Auflistung: 

1. *Histogramme*:
Zweck: Zeigt die Verteilung der Daten.
Verwendung: Geeignet, um die Form der Verteilung, Zentralität und Streuung zu untersuchen.

2. *Boxplots*:
Zweck: Veranschaulicht die Verteilung und Zentralität der Daten sowie Ausreißer.
Verwendung: Besonders hilfreich bei der Identifizierung von Ausreißern.

3. *Streudiagramme* (Scatter Plots):
Zweck: Zeigt die Beziehung zwischen zwei kontinuierlichen Variablen.
Verwendung: Ermöglicht die Identifizierung von Mustern, Korrelationen oder Ausreißern.

Dieser Art der Nutzung von Visualisierungen wirst du in späteren Tutorials erneut begegnen, wenn wir diese zur Überprüfung der Voraussetzungen für eine statistische Testgröße verwenden. Jetzt hast du es bereits schon einmal gehört - oder eher *gelesen* - und weißt dann, wenn die Zeit gekommen ist, schon Bescheid was wir zur Verfügung haben. 


## Barrierefreiheit

Noch ein letztes Kapitel, dass nicht vernachlässigt werden sollte, wenn es um visuelle Darstellung geht: die Barrierefreiheit.

Ein nicht zu vernachlässigender Anteil der Bevölkerung kann bestimmte Farben nicht unterscheiden. Deswegen wurden von schlauen Menschen Farbpaletten entworfen, die keine ambivalenten Farben wie rot und grün enthalten, und auch ganz ohne Farbwahrnehmung nur über Helligkeit und Dunkelheit der Farben in schwarz weiß funktionieren würden. 

Eine der verbreitetesten ist das Paket `viridis`. Es hat auch seine eigene [Hilfe Seite](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) auf der die Verwendung und möglichen Farbschemen dargestellt werden. 

### Viridis

```{r viridis-demo, message=FALSE, warning=FALSE}
library(ggplot2)
library(hexbin)
library(viridis)

dat <- data.frame(x = rnorm(10000), y = rnorm(10000))

p <- ggplot(dat, aes(x = x, y = y)) +
  geom_hex() + coord_fixed() +
  scale_fill_gradientn(colours = viridis(256, option = "D")) +
  theme_bw()

p
```

Die obenstehende Grafik ist ein gutes Beispiel dafür, wie hell-dunkel Kontraste verwendet werden können. So ist das Ganze in schwarz-weiß immer noch lesbar, was insbesondere für Menschen mit eingeschränkter Farbwahrnehmung klasse ist, denn alles was schwarz weiß gut lesbar ist, ist immer auch colorblind-friendly. 

Schau dir doch einmal die Hilfeseite von viridis für ggplot an und finde heraus, wie du es nutzen kannst

```{r exvi, exercise = TRUE}
??viridis
```


## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```



## Credit

### Literaturverzeichnis

fehlt:  Modern Dive (Ismay and Kim 2022)

