---
title: "Visualisierung"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: false
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Schnelle Diagramme erstellen, schöne Diagramme erstellen. Die Grammar of Graphs wird kurz erklärt, das Prinzip wonach ggplot2 aufgebaut ist. Die Erstellung verschiedener Diagrammarten wird geübt. Aesthetic Mappings, Geoms, Facets. 
resource_files:
- css/boxes.css
tutorial:
      id: ggplot
      version: 1
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(kableExtra)
library(tibble)
library(rtutorials)
knitr::opts_chunk$set(echo = FALSE)

## hexbin und kableExtra?
```

## Einführung

Jetzt kommt wirklich einer der allercoolsten Teile des ganzen Kurses. R ist einfach
unfassbar mächtig, was das Visualisieren von Daten angeht, viel ausgefeilter und vielfältiger, als
Excel und SPSS es je erreichen können. Unser Ziel ist euch ein paar schnelle Kochrezepte für die wichtigsten
Visualisierungsaufgaben mitzugeben, und die Neugier auf mehr zu wecken, in dem wir eine kleine Einführung in das Visualisierungspaket `ggplot2` geben.

Mit R sind abgefahrene Sachen möglich. Eine vielfältige Übersicht darüber, was alles geht, erhältst du in der [R Graph Gallery](https://r-graph-gallery.com/). Hier sind ein paar Beispiele:

#### [Eine Karte im Stil von Jacques Bertin](https://r-graph-gallery.com/web-valued-dots-map-bertin.html)

![](images/compress/bertin.png){width=80%}

#### [Heatmap stündliche Temperatur über zwei Jahre](https://r-graph-gallery.com/283-the-hourly-heatmap.html)

![](images/compress/temp.png){width=80%}

Das war nur, um dir einen Einblick zu geben in das, was alles möglich ist. Dieses Tutorial muss jedoch bei den Basics starten, wir werden nur grundständige Diagramme zeichnen. Das abgefahrene
kann alles später kommen. In den Links über den Grafiken findest du detaillierte Anleitungen, sie selbst herzustellen, für deren Verständnis du aber das Grundwissen brauchst, was in diesem Tutorial
vermittelt wird. Das hier sind die Ziele für heute: 

### Lernziele

<input type="checkbox" unchecked> Punktdiagramm (*scatterplot*) erstellen </input>

<input type="checkbox" unchecked> Balkendiagramm (*barplot*) erstellen </input>

<input type="checkbox" unchecked> Histogramm (*histogram*) erstellen </input>

<input type="checkbox" unchecked> Liniendiagramm (*linegraph*) erstellen </input>

<input type="checkbox" unchecked> Boxplot erstellen </input>

<input type="checkbox" unchecked> Schnelle Grafikfunktionen um einen Überblick zu gewinnen </input>

<input type="checkbox" unchecked> Grafiken mit `ggplot2` nach dem Baukasten der *Grammar of Graphs* erstellen </inpu>

<input type="checkbox" unchecked> colorblind-friendly sein </input>

### Die fünf essentiellen Diagrammtypen

```{r echo=FALSE}
de <- c("Punktdiagramm","Liniendiagramm","Histogramm","Boxplot","Balkendiagramm")
en <- c("scatterplot","linegraph", "histogram", "boxplot", "barplot")
vars <- c("2 stetige Variablen", "1 stetige und 1 zeitlich geordnete Variable",
          "1 stetige Variable", "1 stetige Variable mit Gruppen", "1 kategoriale Variable")
tibble(` `= c("1.", "2.", "3.", "4.", "5."), de, en, `geeignet für` = vars) |>
  kbl() |>
  kable_styling()
```

```{r fiveplots, fig.height=8, out.width="100%"}
par(mfrow = c(3, 2),
    bty = "n")
plot(heated[ ,c("maxtemp", "edvisits")],
     main = "1.",
     axes = F,
     ylab = NA,
     xlab = NA)
plot(heated$enddate[heated$enddate > as.Date("2022-03-24")], 
     heated$maxtemp[heated$enddate > as.Date("2022-03-24")],
     type = "l",
     main = "2.",
     axes = F,
     ylab = NA,
     xlab = NA)
hist(heated$maxtemp,
     main = "3.",
     axes = F,
     ylab = NA,
     xlab = NA)
boxplot(heated$maxtemp ~ factor(lubridate::month(heated$enddate)),
        main = "4.",
        axes = F,
        ylab = NA,
        xlab = NA)
barplot({einkaufen$Verkehrsmittel |> table()}[1:5],
        main = "5.",
        axes = F,
        ylab = NA,
        xlab = NA,
        names.arg = NA)
# reset par
par(mfrow = c(1, 1),
    bty = "o")
```

## Einführung

Es gibt (wie immer) tausend verschiedene Wege, Visualisierungen mit R zu erstellen. Aber einer hat sich über die Jahre herauskristallisiert, und das ist `ggplot2`. 

Der Grund, warum wir dir diesen Weg beibringen:

- Er folgt einem klaren Baukastenprinzip, mit dem auch später beliebig komplexe Anpassungen der Grafik an die eigenen Vorstellungen relativ schmerzfrei umgesetzt werden können. 

- Es ist der populärste Weg, es gibt auf Google viele gute Anleitungen und Antworten. Und es existieren zahlreiche Eweiterungen um das Paket `ggplot2`. 

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verfügbaren Online-Lehrbuch namens [*Modern Dive*](https://www.moderndive.com) [@ismay2022]. Wir haben die Reihenfolge geändert, 
Sachen übersetzt und paraphrasiert und unsere eigenen Gedanken hinzugefügt.

<hr>

### Grammar of Graphs

Das `gg` im Paketnamen `ggplot2` steht für *Grammar of Graphs*. 

Leland Wilkinson ist der Gründer des Grammar of Graphs-Ansatzes. Im Grunde ist das eine Theorie darüber, mit welchen Regeln und Bausteinen statistische Grafiken erstellt werden können [@wilkinson2005].

`ggplot2` ist die Umsetzung dieses theoretischen Baukastens, und das `gg` steht für *Grammar of Graphs*. Es wurde von Hadley Wickham geschrieben und ist ein relativ altes Paket im R-Ökosystem [@wickham2009].

#### benötigtes Paket

Der erste Schritt für dieses Tutorial ist, das Paket `ggplot2` in die aktive Sitzung zu laden. Tu das mittels `library()`!

```{r lib, exercise = TRUE, exercise.cap = "ggplot2 laden"}
library()
```

```{r lib-solution}
library(ggplot2)
```

### Einordnung in den Prozess

Wir haben jetzt Daten erhoben, importiert - und nun? Grafiken sind ein guter Weg, Zusammenhänge in den Daten sichtbar zu machen. Zum einen, um sich selbst in den Daten zu orientieren, und zum anderen auch um die Ergebnisse der Analyse zu präsentieren. Wir brauchen Visualisierungen also an zwei Stellen im Prozess: 

- einmal um einen Überblick zu gewinnen
- am Ende um Ergebnisse zu kommunizieren

![](images/compress/prozess.png){width=90%}


Welche Grafik du wann anwenden kannst, hängt vom Skalenniveau der Daten und der Anzahl von Variablen ab.

Grob kann unterschieden werden zwischen:

- Plots, die die Verteilung einer einzelnen Variablen darstellen
- Plots, die den Zusammenhang zwischen zwei oder mehr Variablen zeigen

Gehen wir sofort zur Sache!

## 1. Balkendiagramm

::: infobox
Balkendiagramme sind geeignet, um die Verteilung einer einzelnen, kategorialen Variable zu zeigen. 
:::

So sieht Code aus, um mit `ggplot2` ein einfaches Balkendiagramm zu erstellen (das schön machen kommt später). 

```{r barplot, exercise = TRUE, exercise.cap = "Einfacher Barplot"}
ggplot(data = einkaufen,
       mapping = aes(x = Verkehrsmittel)) +
  geom_bar()
```

Dabei wird deutlich, dass der Code durch eine klare Sprache organisiert ist:

- in `data` übergeben wir einen Datensatz an die Funktion
- in `mapping` sagen wir, welche Variablen aus dem Datensatz gezeigt werden. 
- das `+` fügt eine neue Ebene hinzu, genau wie in Photoshop / Gimp / Overhead-Folien
- `geom_bar()` fügt ein `geom`etrisches Objekt, nämlich die Balken (`bar`s), hinzu.

Mehr dazu, wie genau dieses Mapping funktioniert, folgt später.

### Baukasten-Prinzip

Leland Wilkonson, Begründer der *Grammar of Graphs*-Theorie sagt, dass sich jede statistische Grafik durch
diese drei Kernbestandteile beschreiben lässt: 

- `data`
- `aesthetic mapping`
- `geom`etric objects

### aesthetic mapping

Was ist eigentlich dieses aesthetic mapping? Das ist das, was wir oben im Code beim Argument `mapping` gemacht haben: `mapping = aes(x = Verkehrsmittel)`

`aes()` steht für *aesthetic attributes*, und weist den einzelnen Variablen, wie z.B. dem Verkehrsmittel,
eine *grafische Eigenschaft* zu. Grafische Eigenschaften sind: 

- Achsen (`x`, `y`)
- Farbe (`colour`)
- Füllung (`fill`)
- Größe (`size`)
- Transparenz (`alpha`)

Im Diagramm oben wurde der x-Achse die Variable Verkehrsmittel zugewiesen. 



## 2. Histogramm

## 3. Boxplot

## 4. Punktdiagramm

## 5. Liniendiagramm

## 6. Special: Facets

## 7. Special: Jitter

## 8. Special: 


## Barrierefreiheit

Ein nicht zu vernachlässigender Anteil der Bevölkerung kann bestimmte Farben nicht unterscheiden. Deswegen wurden von schlauen Menschen Farbpaletten entworfen, die keine ambivalenten Farben wie rot und grün enthalten, und auch ganz ohne Farbwahrnehmung nur über Helligkeit und Dunkelheit der Farben in schwarz weiß funktionieren würden. 

Eine der verbreitetesten ist `viridis`.

### Viridis

```{r viridis-demo, message=FALSE, warning=FALSE}
library(ggplot2)
library(hexbin)
library(viridis)

dat <- data.frame(x = rnorm(10000), y = rnorm(10000))

p <- ggplot(dat, aes(x = x, y = y)) +
  geom_hex() + coord_fixed() +
  scale_fill_gradientn(colours = viridis(256, option = "D")) +
  theme_bw()

p
```

Die obenstehende Grafik ist ein gutes Beispiel dafür, wie hell-dunkel Kontraste verwendet werden können. So ist das Ganze in schwarz-weiß immer noch lesbar, was insbesondere für Menschen mit eingeschränkter Farbwahrnehmung klasse ist, denn alles was schwarz weiß gut lesbar ist, ist immer auch colorblind-friendly. 

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```



## Credit

### Literaturverzeichnis
