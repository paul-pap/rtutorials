---
title: "Visualisierung"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Schnelle Diagramme erstellen, schöne Diagramme erstellen. Die Grammar of Graphs wird kurz erklärt, das Prinzip wonach ggplot2 aufgebaut ist. Die Erstellung verschiedener Diagrammarten wird geübt. Aesthetic Mappings, Geoms, Facets. 
resource_files:
- css/boxes.css
tutorial:
      id: ggplot
      version: 1
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(kableExtra)
library(tibble)
library(rtutorials)
knitr::opts_chunk$set(echo = FALSE)
colnames(einkaufen) <- tolower(colnames(einkaufen))
```

## Inhalt

Jetzt kommt wirklich einer der allercoolsten Teile des ganzen Kurses. R ist einfach
unfassbar mächtig, was das Visualisieren von Daten angeht, viel ausgefeilter und vielfältiger, als
Excel und SPSS es je erreichen können. Unser Ziel ist euch ein paar schnelle Kochrezepte für die wichtigsten
Visualisierungsaufgaben mitzugeben, und die Neugier auf mehr zu wecken, in dem wir eine kleine Einführung in das Visualisierungspaket `ggplot2` geben.

Mit R sind abgefahrene Sachen möglich. Eine vielfältige Übersicht darüber, was alles geht, erhältst du in der [R Graph Gallery](https://r-graph-gallery.com/). Hier sind ein paar Beispiele:

#### [Eine Karte im Stil von Jacques Bertin](https://r-graph-gallery.com/web-valued-dots-map-bertin.html)

![](images/compress/bertin.png){width=80%}

#### [Heatmap stündliche Temperatur über zwei Jahre](https://r-graph-gallery.com/283-the-hourly-heatmap.html)

![](images/compress/temp.png){width=80%}

Ziemlich beeindruckend, oder?
Das soll hier aber nur ein kleiner Einblick in das sein, was alles möglich ist.  In diesem Tutorial starten natürlich bei den Basics und focussieren uns darauf grundständige Diagramme zu zeichnen. Mit diesem Grundwissen kannst du dir dann auch selbst beibringen solche abgefahrenen Diagramme zu erstellen.
In den Links über den Grafiken findest du detaillierte Anleitungen, wenn du dann soweit bist.

Wie gesagt, wir fangen Schritt für Schritt an und daher sind das hier die Ziele für heute: 

### Lernziele

<input type="checkbox" unchecked> Punktdiagramm (*scatterplot*) erstellen </input>

<input type="checkbox" unchecked> Balkendiagramm (*barplot*) erstellen </input>

<input type="checkbox" unchecked> Histogramm (*histogram*) erstellen </input>

<input type="checkbox" unchecked> Liniendiagramm (*linegraph*) erstellen </input>

<input type="checkbox" unchecked> Boxplot erstellen </input>

<input type="checkbox" unchecked> Schnelle Grafikfunktionen, um einen Überblick zu gewinnen </input>

<input type="checkbox" unchecked> Grafiken mit `ggplot2` nach dem Baukasten der *Grammar of Graphs* erstellen </inpu>

<input type="checkbox" unchecked> colorblind-friendly sein </input>

### Die fünf essentiellen Diagrammtypen

```{r echo=FALSE}
de <- c("Punktdiagramm","Liniendiagramm","Histogramm","Boxplot","Balkendiagramm")
en <- c("scatterplot","linegraph", "histogram", "boxplot", "barplot")
vars <- c("2 stetige Variablen", "1 stetige und 1 zeitlich geordnete Variable",
          "1 stetige Variable", "1 stetige Variable mit Gruppen", "1 kategoriale Variable")
tibble(` `= c("1.", "2.", "3.", "4.", "5."), de, en, `geeignet für` = vars) |>
  kbl() |>
  kable_styling()
```

```{r fiveplots, fig.height=8, out.width="100%"}
par(mfrow = c(3, 2),
    bty = "n")
plot(heated[ ,c("maxtemp", "edvisits")],
     main = "1.",
     axes = F,
     ylab = NA,
     xlab = NA)
plot(heated$enddate[heated$enddate > as.Date("2022-03-24")], 
     heated$maxtemp[heated$enddate > as.Date("2022-03-24")],
     type = "l",
     main = "2.",
     axes = F,
     ylab = NA,
     xlab = NA)
hist(heated$maxtemp,
     main = "3.",
     axes = F,
     ylab = NA,
     xlab = NA)
boxplot(heated$maxtemp ~ factor(lubridate::month(heated$enddate)),
        main = "4.",
        axes = F,
        ylab = NA,
        xlab = NA)
barplot({einkaufen$verkehrsmittel |> table()}[1:5],
        main = "5.",
        axes = F,
        ylab = NA,
        xlab = NA,
        names.arg = NA)
# reset par
par(mfrow = c(1, 1),
    bty = "o")
```

## Einführung

Es gibt (wie immer) tausend verschiedene Wege, Visualisierungen mit R zu erstellen. Aber einer hat sich über die Jahre als besonders Beliebt erwiesen, und das ist `ggplot2`. 

Der Grund, warum wir dir diesen Weg beibringen:

- Er folgt einem klaren Baukastenprinzip, mit dem auch später beliebig komplexe Anpassungen der Grafik an die eigenen Vorstellungen relativ schmerzfrei umgesetzt werden können. 

- Es ist der populärste Weg, es gibt auf Google viele gute Anleitungen und Antworten. Und es existieren zahlreiche Eweiterungen um das Paket `ggplot2`. 

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verfügbaren Online-Lehrbuch namens [*Modern Dive*](https://www.moderndive.com) [@ismay2022]. Wir haben die Reihenfolge geändert, 
Sachen übersetzt und paraphrasiert und unsere eigenen Gedanken hinzugefügt.

<hr>

### Grammar of Graphs

Das `gg` im Paketnamen `ggplot2` steht für *Grammar of Graphs*. 

Leland Wilkinson ist der Gründer des Grammar of Graphs-Ansatzes. Im Grunde ist das eine Theorie darüber, mit welchen Regeln und Bausteinen statistische Grafiken erstellt werden können [@wilkinson2005].

`ggplot2` ist die Umsetzung dieses theoretischen Baukastens. Es wurde von Hadley Wickham geschrieben und ist ein relativ altes Paket im R-Ökosystem [@wickham2009].

#### benötigtes Paket

::: aufgabe
Der erste Schritt für dieses Tutorial ist, das Paket `ggplot2` in die aktive Sitzung zu laden. Tu das mittels `library()`! 
:::

```{r lib, exercise = TRUE, exercise.cap = "ggplot2 laden"}
library()
```

```{r lib-solution}
library(ggplot2)
```

### Einordnung in den Prozess

Wir haben jetzt Daten erhoben, importiert - und nun? Grafiken sind ein guter Weg, Zusammenhänge in den Daten sichtbar zu machen. Zum einen, um sich selbst in den Daten zu orientieren, und zum anderen auch, um die Ergebnisse der Analyse zu präsentieren. Wir brauchen Visualisierungen also an zwei Stellen im Prozess: 

- einmal um einen **Überblick** zu gewinnen
- am Ende um **Ergebnisse** zu **kommunizieren**

![](images/compress/prozess.png){width=90%}


Welche Grafik du wann anwenden kannst, hängt vom Skalenniveau der Daten und der Anzahl von Variablen ab.

Grob kann unterschieden werden zwischen:

- Plots, die die Verteilung einer einzelnen Variablen darstellen
- Plots, die den Zusammenhang zwischen zwei oder mehr Variablen zeigen

Die am häufigsten verwendeten und in diesem Tutorial vorgestellten Plots sind:

|                    | kategorial               | kontinuierlich                   |
|--------------------|--------------------------|----------------------------------|
| **keine**          | Barplot <br>`geom_bar()` | Histogram <br>`geom_histogram()` |
| **kategorial**     | (`geom_count()`)         | Boxplot<br>`geom_boxplot()`      |
| **kontinuierlich** | -                        | Punktdiagramm<br>`geom_point()`  |
| **sequentiell**    | -                        | Liniendiagramm<br>`geom_line()`  |




Steigen wir direkt ein!

## 1. Balkendiagramm

::: infobox
Balkendiagramme sind geeignet, um die Verteilung einer **einzelnen**, **kategorialen** Variable zu zeigen.

Funktion: `geom_bar()`
:::
<br>

So sieht Code aus, um mit `ggplot2` ein einfaches Balkendiagramm zu erstellen (das schön machen kommt später):

```{r barplot, exercise = TRUE, exercise.cap = "Einfacher Barplot"}
ggplot(data = einkaufen,
       mapping = aes(x = verkehrsmittel)) +
  geom_bar()
```

Dabei wird deutlich, dass der Code durch eine klare Sprache organisiert ist:

- in `data` übergeben wir einen Datensatz an die Funktion
- in `mapping` sagen wir, welche Variablen aus dem Datensatz wo gezeigt werden. 
- das `+` fügt eine neue Ebene hinzu, genau wie in Photoshop / Gimp / Overhead-Folien
- `geom_bar()` fügt ein `geom`etrisches Objekt, nämlich die Balken (`bar`s), hinzu.

Mehr dazu, wie genau dieses Mapping funktioniert, folgt später.

### Baukasten-Prinzip

Leland Wilkonson, Begründer der *Grammar of Graphs*-Theorie sagt, dass sich jede statistische Grafik durch
diese drei Kernbestandteile beschreiben lässt: 

- `data`
- `aesthetic mapping`
- `geom`etric objects

Mit data kennst du dich ja jetzt schon aus, daher können wir direkt zum *mapping* übergehen.

### aesthetic mapping

Was ist eigentlich dieses `aesthetic mapping`? Das ist das, was wir oben im Code beim Argument `mapping` gemacht haben: `mapping = aes(x = verkehrsmittel)`

`aes()` steht für *aesthetic attributes*, und weist den einzelnen Variablen, wie z.B. dem Verkehrsmittel, eine *grafische Eigenschaft* zu. Grafische Eigenschaften sind: 

- Achsen (`x`, `y`)
- Farbe (`colour`)
- Füllung (`fill`)
- Größe (`size`)
- Transparenz (`alpha`)

Im Diagramm oben wurde der x-Achse die Variable Verkehrsmittel zugewiesen. 

:::aufgabe
Ändere den Code so, dass die Variable Verkehrsmittel nun stattdessen auf die y-Achse gemappt wird. Wie wird sich das Diagramm wohl verändern?
:::

*Beachte, dass wir hier die Argumentnamen `data` und `mapping` weggelassen haben, so wie es in der Praxis üblicherweise auch getan wird. Das können wir machen, da wir die Reihenfolge der Argumente beachten, also `data`, `mapping` dann `geometric objects`.* 

```{r ybarplot, exercise = TRUE, exercise.cap = "Mapping ändern auf y-Achse"}
ggplot(einkaufen, aes(x = verkehrsmittel)) +
  geom_bar()
```

```{r ybarplot-solution}
ggplot(einkaufen, aes(y = verkehrsmittel)) +
  geom_bar()
```

Es gibt, wie oben erwähnt, noch mehr *aesthetic attributes* außer der `x`-Achse und der `y`-Achse, aber auf die fokussieren wir uns später. 

### `geom_bar`

Und was ist dieses `geom_bar()`? Das wird am ehesten deutlich, wenn wir es weglassen!

::: aufgabe
Schau dir an, wie der Plot aussieht ohne die Ebene mit`geom_bar()`!
:::

```{r plotwithoutgeom, exercise = TRUE, exercise.cap = "Ohne geom"}
ggplot(einkaufen, aes(x = verkehrsmittel))
```

Jetzt versteht du vielleicht, wofür die `geom_bar()`-Funktion da ist: Geometrische Objekte, in diesem Fall Balken, in den Plot zu zeichnen! Der Plot ist leer, aber die Achsen sind bereits beschriftet und perfekt vorbereitet, aber es fehlt noch das geometrische Objekt. 

Innerhalb der Funktion für das geometrische Objekt finden auch Berechnungen statt, die einzelnen Ausprägungen der Verkehrsmittel werden gezählt, um die Höhe der Balken zu bestimmen. Aber damit müssen wir uns zum Glück nicht beschäftigen. 
Und jetzt kommt das Ding: Es gibt auch noch andere `geom_...()` Funktionen. Zum Beispiel `geom_point()`, welche dem Plot Punkte hinzufügt! Oder `geom_histogram()`, welche ein Histogramm zeichnet, siehe nächster Abschnitt.

::: aufgabe
Probiere das doch einfach mal aus und tausche `geom_bar()` durch `geom_point()`. 
:::

```{r error-solution, exercise = TRUE}
ggplot(einkaufen, aes(x = verkehrsmittel)) +
  geom_point()
```

```{r error, exercise = TRUE, exercise.cap = "Fehlermeldung"}

```

Dass hier eine Fehlermeldung herauskommt, ist völlig normal! Fehlermeldungen sind freundlich, denn Programmierer*innen geben sich (oft) viel Mühe, diese möglichst informativ und genau zu machen. Also hab keine Angst, und lies dir tatsächlich mal durch was da steht!

Es gibt hier einen Unterschied, in den R Skripten, mit denen du arbeitest und den R Tutorials, in dem du dich gerade befindest, deswegen die folgende Aufgabe:

::: aufgaberstudio
Füge den Code aus der obigen Aufgabe in deine R Studio Konsole ein und schau dir die daraus resultierende Fehlermeldung genau an.
:::

Wahrscheinlich sieht sie so aus:

```
Error in `geom_point()`:
! Problem while setting up geom.
ℹ Error occurred in the 1st layer.
Caused by error in `compute_geom_1()`:
! `geom_point()` requires the following missing aesthetics: y
Run `rlang::last_trace()` to see where the error occurred.
```

- Schon die erste Zeile gibt dir eine wichtige Information: Der Fehler trat in der Funktion `geom_point()` auf und nicht an irgendeiner anderen Stelle des Plots. (Das wird wichtiger, umso mehr Ebenen ein Plot hat.)
- Die zweite Zeile spezifiziert das Problem: Es gibt Probleme mit dem geometrischen Objekt (also den Punkten) und nicht mit irgendwas anderem in dieser Funktion
- Die dritte Zeile sagt, dass der Fehler bereits in der allerersten Zeile / Ebene passiert
- Die vierte Zeile musst du nicht genau verstehen
- die fünfte Zeile schließlich sagt dir ganz genau, wo das Problem ist: Du brauchst eine zweite Variable. Und zwar auf der y-Achse. Das ergibt auch Sinn, denn ein Punkt hat immer zwei Koordinaten, eine `x`- und eine `y`-Koordinate! Logischerweise kann kein Punkt gezeichnet werden, wenn du nur eine `x`-Koordinate angibst. 
- In der sechsten Zeile ist ein Vorschlag, um genau zu verstehen, was in deinem Code schiefläuft, das kannst du eigentlich auch ignorieren, da du die wichtigeste Info ja bereits in Zeile fünf erhalten hast


::: aufgabe
Löse das Problem, indem du in `aes()` noch das Argument `y = weg` angibst. Denk daran, Argumente werden durch Kommata getrennt. 

"weg" ist eine stetige Variable, die den zurückgelegten Anreiseweg der Person zum Bioladen, wo die Erhebung stattfand, in km enthält. 
:::

```{r weg, exercise = TRUE, exercise.cap = "aesthetic mapping hinzufügen für y-Achse"}
ggplot(einkaufen, aes(x = verkehrsmittel)) +
  geom_point()
```

```{r weg-solution}
ggplot(einkaufen, aes(x = verkehrsmittel, y = weg)) +
  geom_point()
```

Ok, das Diagramm ist vielleicht nicht ultra informativ, weil ganz viele Punkte übereinandergelagert wurden an manchen Stellen. Es gibt definitiv ein anderes, geeigneteres Diagramm! Hier ging es nur darum, das Prinzip zu beweisen: `ggplot` funktioniert wie ein Baukasten, und das `geom` können wir austauschen, so lange dafür gesorgt wird, dass in den `aes`thetic mappings Variablen und Skalenniveau zu dem jeweiligen `geom` passen!

```{r weg-quest}
question_text("Wie erklärst du dir die weiten Anreisewege (bis 600km!) beim Verkehrsmittel „ÖPNV”? (Tipp: Der Bioladen ist in der Nähe eines ICE-Bahnhofs)",
              answer_fn(\(x) correct(messages = "Vermutlich waren einige Menschen zuvor mit dem ICE gefahren, und hatten vielleicht auch nur einen Umstieg mit Wartezeit und Hunger auf ein Bio-Brötchen oder so. Während der Rest der Menschen ihren regulären Wocheneinnkauf machen und aus der Umgebung kommen, maximal ein paar Kilometer entfernt.")),
              placeholder = "Musterlösung erscheint bei Abgabe deiner Antwort...")
```


## 2. Histogramm

::: infobox
Histogramme sind geeignet, um die Verteilung einer **einzelnen**, **stetigen** Variable zu zeigen.

Funktion: `geom_histogram()`
:::
<br>

Unser Go-To-Beispiel für eine stetige Variable ist `einkaufen$alter`, die dir schon in den letzten Tutorials begegnet sein sollte. Beachte, dass du innerhalb von `ggplot`-Code den `$`-Operator nicht benutzen musst. Das liegt daran, dass `ggplot` weiß, in welchem Datensatz die Variable gesucht werden muss, da wir den Datensatz ja im allerersten Argument angeben. 

Hier ist `ggplot2`-Code für ein einfaches, absolut nicht schönes Histogramm. In diesem Abschnitt wird es deswegen auch mal Zeit, über Farben und Verschönerungen zu sprechen. 

```{r hist, exercise = TRUE, exercise.cap = "einfaches Histogramm erstellen"}
ggplot(einkaufen, aes(alter)) +
  geom_histogram()
```


### Was ist ein Histogramm?

Bei einem Histogramm werden auf der x-Achse die möglichen Ausprägungen der Variable aufgelistet, und auf der y-Achse die Häufigkeit. Es ist also genau das gleiche Prinzip wie bei einem Balkendiagramm, nur dass wir uns hier zusätzlich noch mit der Kategorienbreite (*binwidth*) auseinandersetzen müssen.

Denn: Balkendiagramme sind für diskrete Daten, und diskrete Daten haben natürliche Kategorien. Zum Beispiel ist das Verkehrsmittel ÖPNV etwas anderes als Motorrad - die Kategorien liegen also schon in der Natur der Sache. 

Das ist bei stetigen (kontinuierlichen) Daten anders: Von Natur her gibt es bei stetigen Daten immer unendlich viele mögliche Ausprägungen, und also auch immer unendlich viele mögliche Kategorien. 

Zum Beispiel kann ein Meter in unendlich feine Messeinheiten aufgeteilt werden:

- Meter
- Dezimeter
- Zentimeter
- Millimeter
- Mikrometer
- Nanometer
- Picometer
- Femtometer
- Attometer
...

Da es unendlich Möglichkeiten gibt einen Meter einzuteilen, gehen keine natürlichen Kategorien daraus hervor. Deswegen können die Kategorien beliebig gebildet werden.

Beim Histogramm des Alters oben sind die Balken zum Beispiel immer 2.5 Jahre breit, komplett random also. Darüber informiert `ggplot` auch beim Erstellen des Diagramms mit einer Warnmeldung:

```
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`
```
`ggplot` sagt damit: „Hey, ich habe deine Daten einfach mal in 30 gleich große Kategorien eingeteilt, aber das ist ein default-Wert, den du bitte anpassen solltest.“

### Kategorienbreite anpassen

In der Warnmeldung wurde bereits das Argument `binwidth` erwähnt. Hier ist Code, mit dem die Kategorienbreite auf 5 (Jahre) festgelegt wird. 

```{r binwidth, exercise = TRUE, exercise.cap = "Kategorienbreite einstellen"}
ggplot(einkaufen, aes(x = alter)) +
  geom_histogram(binwidth = 5)
```

### `colour` und `fill`

Da die Balken gerade visuell in einer großen grauen Masse verschwinden, wird noch nicht so ganz deutlich worum es eigentlich geht. Deswegen wäre es hilfreich, wenn alle Balken eine schwarze Umrandung hätten und etwas hellgrauer wären. Beachte, dass jetzt nach dem `binwidth`-Argument dafür noch die Argumente `color` und `fill` stehen. 

Fun fact: in `ggplot` ist es für R egal, ob du die UK Variante von `colour` schreibst oder die amerikanische `color`. Wie das geschrieben wird ist in diesem Fall reine Geschmackssache.

```{r color, exercise = TRUE, exercise.cap = "Color und Fill"}
ggplot(einkaufen, aes(x = alter)) +
  geom_histogram(binwidth = 5,
                 color = "black",
                 fill = "grey")
```

Später in diesem Tutorial wird es noch ein eigenes Kapitel zu Farben geben.

### `boundary`

Das sieht schon mal ein Stück weit besser aus. Jetzt ist noch etwas störend, dass die Kategorien
nicht bei den markanten Zahlen anfangen, sondern z.B. die 50 in der Mitte einer Kategorie liegt. Dafür kannst du das Argument `boundary` nutzen, um einen Grenzwert zu bestimmen, der die Kategorien an diesem Punkt teilt (sog. "bin break"):

```{r boundary, exercise = TRUE, exercise.cap = "Boundary-Argument"}
ggplot(einkaufen, aes(x = alter)) +
  geom_histogram(binwidth = 5,
                 boundary = 50,
                 color = "black",
                 fill = "grey")
```

## 3. Boxplot

::: infobox
Ein Boxplot ist eine effektive Methode, um die Verteilung **einer stetigen** und **einer kategorialen** Variable zu visualisieren und Ausreißer zu identifizieren.

Funktion: `geom_boxplot()`
:::
<br>

Du erinnerst dich vielleicht daran im letzten Tutorial selbst bereits einen Boxplot gezeichnet zu haben. Hier noch einmal die Übersicht, welche Daten in einem Boxplot enthalten sind:

![](images/boxplot.png){width=90%}

[image source](https://leansigmacorporation.com/box-plot-with-minitab/)

Boxplots werden eigentlich niemals einzeln gezeigt, sondern immer im Vergleich neben
anderen Boxplots. Das heißt dann *side-by-side boxplot*. Das macht auch Sinn,
denn für die Verteilung einer einzelnen stetigen Variablen haben wir ja bereits
das Histogramm. Boxplots hingegen sind gut darin, mehrere Verteilungen übersichtlich zu vergleichen. Histogramme sind gut darin, eine einzelne Verteilung detailliert 
darzustellen.

*Side-by-side boxplots* entstehen, wenn zu der **stetigen** noch eine **kategoriale** Variable hinzukommt. 
Im Plot unten wird die stetige Variable `alter` nach der kategorialen Variable 
`verkehrsmittel` aufgeschlüsselt. Für jedes Verkehrsmittel
ergibt sich nun eine eigene Altersverteilung. Da zeigen sich dann die ersten spannenden  Zusammenhänge!

```{r sidebysideboxplot, echo=TRUE, message=FALSE, warning=FALSE}
ggplot(einkaufen, aes(x = verkehrsmittel, y = alter)) +
  geom_boxplot()
```

Es wird auch deutlich, dass die Kategorien "E-Roller" und "Motorrad" so klein sind, dass sie sich nicht als eigene Analyse-Kategorie eignen, deswegen werden sie mit "Andere" zusammengefasst. Hierfür wird ein neuer Datensatz mit dem Namen `data_einkaufen` erstellt. Die NAs dürfen allerdings nicht einfach umgecodet werden, weil wir es in diesem Fall einfach wirklich nicht wissen.

```{r}
# Erstelle ein neues Objekt und speichere den bisherigen Datensatz darin
data_einkaufen <- einkaufen

# Verändere Variablen nach deinen Wünschen im NEUEN Objekt
# in diesem Fall mit der recode Funktion aus dem Paket dplyr
# die bisherige Variable wird einfach mit der neuen überschrieben
data_einkaufen$verkehrsmittel <- recode(einkaufen$verkehrsmittel,
      "E-Roller" = "Andere",
      "Motorrad" = "Andere"
)

# und nochmal der gleiche Plot
ggplot(data_einkaufen, aes(x = verkehrsmittel, y = alter)) +
  geom_boxplot()
```


```{r question_boxplot}
quiz(caption = "Interpretation üben",
question_radio("Wie ist das obere und untere Ende der Box bei den Autofahrenden zu interpretieren? Der untere Rand der Box liegt ungefähr bei 37, der obere bei ca. 60 Jahren.",
               answer("Diese Altersspanne umfasst die mittleren 50% der Autofahrenden",
                      correct = TRUE,
                      message = "Das entspricht der IQR (*interquartile range*), also dem Abstand zwischen drittem und erstem Quartil, oder anders gesagt zwischen dem 75%-Quantil und dem 25%-Quantil."),
               answer("Diese Altersspanne umfasst die mittleren 75% der Autofahrenden",
                      message = "Das obere Ende der Box kennzeichnet das 75%-Quantil oder auch drittes Quartil, das untere das 25%-Quantil oder auch 1. Quartil. Der Abstand zwischen 75 und 25 % beträgt 50%."),
               answer("Diese Altersspanne umfasst die mittleren 25% der Autofahrenden",
                      message = "Das obere Ende der Box kennzeichnet das 75%-Quantil oder auch drittes Quartil, das untere das 25%-Quantil oder auch 1. Quartil. Der Abstand zwischen 75 und 25 % beträgt 50%."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question_numeric("Wie lautet der Median des Alters aller Autofahrenden? (grob)",
                 answer(50, correct = TRUE),
                 tolerance = 2,
                 allow_retry = T,
                 incorrect = "Der Median ist der dicke Strich in der Mitte der Box."),

question_radio("Wie ist der Median zu interpretieren?",
               answer("Der Median ist das Alter, was die Autofahrenden in zwei gleich große Hälften teilt", correct = TRUE, message = 
                        "Dabei wird die Box ja gar nicht in zwei gleich große Teile geteilt! Aber trotzdem hast du es richtig erkannt."),
               answer("Der Median ist das Alter, was am häufigsten vorkommt.", message = "Die häufigste Ausprägung nennt sich „Modus“ und wird üblicherweise für kategoriale Daten angegeben. Der Median ist etwas anderes: Wenn die Werte der Reihenfolge nach sortiert werden, ist der Median derjenige, der in der Mitte der Reihenfolge steht."),
               answer("Der Median darf hier nicht interpretiert werden, da das Alter stetig ist.", message = "Der Median darf zwar bereits für ordinale, diskrete Daten berechnet werden, aber das heißt nicht dass er für höhere Skalenniveaus verboten ist."),
               allow_retry = T,
               random_answer_order = T,
               incorrect = "Leider nicht richtig, probier es noch mal!"),
question_radio("Zeigt der Boxplot die Gruppengröße jedes Verkehrsmittels?",
               answer("Nein, es wird nur die Verteilung gezeigt, aber nicht auf wie vielen Datenpunkten diese Verteilung beruht!",
                      correct = TRUE,
                      message = "Das schauen wir uns im nächsten Abschnitt genauer an."),
               answer("Ja, die Größe der Box kennzeichnet auch die Anzahl an Personen.",
                      message = "Das ist leider falsch. Ganz im Gegenteil. Wenn die Box sehr klein ist, können das tausende von Personen sein, die einfach alle innerhalb einer sehr geringen Altersspanne liegen."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               incorrect = random_encouragement(language = "de"))
)
```

### \# Show your data!

Der obige Boxplot hat einen großen Nachteil: Es ist nicht zu sehen, wie viele Personen in jeder Gruppe sind. Dabei wissen wir eigentlich, dass die Gruppengröße der unterschiedlichen Verkehrsmittel
unterschiedlich ist. Manchmal wird halt ein ganzer Boxplot gezeichnet, während lediglich
6 Personen dahinter stehen, und er ist nicht zu unterscheiden von einem für ein Verkehrsmittel, was 100 Menschen nutzen. Genau hier können wir die die Magie von R nutzen, um unsere Visualisierung nach unseren Wünschen zu ändern. 

Mit einem kleinen Befehl (`geom_jitter()`), lassen sich über unsere Boxplots noch die Informationen der Datenpunkte legen. Mehr dazu in einem späteren Kapitel. 

```{r showyourdata, echo=TRUE}
ggplot(einkaufen, aes(x = verkehrsmittel, y = alter)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.2, 
              width = 0.1, 
              size = 3)
```

::: infobox
Hier siehst du, was ein Boxplot eigentlich wirklich aussagt: Er zeigt wirklich nur die Quartile, Minimum und Maximum und den Median (das ist ja ein Quartil).
:::
<br>

Achte mal auf das Verkehrsmittel "Andere". Dort gibt es wirklich nur eine handvoll Punkte,
aber die Box ist kaum von den anderen Verkehrsmitteln zu unterscheiden. Aber mithilfe der Punkte können wir nun sehen, dass dort weit weniger Datenpunkte vorliegen und wir daher bei der Interpretation dieser Gruppe Vorsicht walten lassen sollten, da sie von der Gruppengröße her nicht mit den anderen zu vergleichen ist, von Motorrad, E-Roller und NA ganz zu schweigen. 

::: aufgabe
**Aufgabe**

Probiere es doch mal aus, und schaue welche anderen zwei Variablen aus dem Beispieldatensatz `einkaufen` du gut für einen Boxplot nutzen kannst. 

Achte darauf, immer eine **metrische** mit einer **kategorialen** Variable zu kombinieren! Sonst gibt es komische Fehlermeldungen / komisch aussehende Plots.

Hier eine Auflistung der Variablennamen:

**Kategorial:**

- `essen`: Das Lieblingsessen der Person. Nominal, 97 verschiedene Ausprägungen
- `verkehrsmittel`: Das Verkehrsmittel, mit dem die Person zum Bioladen gefahren ist. Nominal, 7 Auprägungen
- `frequenz`: Wie oft die Person in einen Bioladen geht. Ordinal, 5 Stufen
- `ort`: Befragungsort. Nominal, 5 Ausprägungen
- `bioladen`: Ob der Laden ein Bioladen war. Nominal, binär
- `befragung`: Kürzel der Studierenden, die die Daten erhoben haben. Nominal, 8 Ausprägungen

**Metrisch:**

- `weg`: Die Länge der Anreise zum Bioladen in km, Verhältnisskala
- `alter`: Alter der Person, Verhältnisskala
- `kochen`:  Anzahl der Tage pro Woche, an denen selber gekocht wird, Absolutskala 

**Andere:**

- `id`, `datum`, `uhrzeit` sind Metadaten die wir gerade nicht brauchen. 
:::

```{r boxplot, exercise = TRUE, exercise.cap = "Boxplot Exploration"}
ggplot(einkaufen, aes(x = , y =  )) +
  geom_boxplot()
```


```{r boxplot-quest}
question_text("Welche Variablen hast du gefunden, die sich für einen Boxplot mit 2 Variablen eignen",
              answer_fn(\(x) correct(messages = "Wie oben erwähnt, ist es am aussagekräftigsten eine metrische Variable und eine kategoriale Variable zu verwenden. Zum Beispiel Ort (kategorial) und Weg (kontinuierlich).")),
              placeholder = "Musterlösung erscheint bei Abgabe deiner Antwort...")
```


## 4. Punktdiagramm

::: infobox
Punktdiagramme sind geeignet, um die Zusammenhänge **zweier numerischer** Variablen zu zeigen.

Funktion: `geom_point()`
:::
<br>
 
Punktediagramme können dir auch unter den Namen: *Streudiagramm*, *Punktewolke* oder englisch *Scatterplot* begegnen.

```{r scatterplot, exercise = TRUE, exercise.cap = "Streudiagramm"}
ggplot(einkaufen, aes(x = alter, y = weg)) +
  geom_point()
```

### Exkurs: Ausreißer-Werte

In diesem Unterkapitel hast du die Mögichkeit, einen Blick in die Praxis zu werfen: Der Umgang mit Ausreißerwerten. Es ist komplett freiwillig. Wenn du lieber mit dem rein grafischen weitermachen willst, springe zu Kapitel 5: Liniendiagramme.

Das ist ein klassischer Fall von Datenaufbereitung. Es wird **vor** den Analysen gemacht.

Und genau deswegen ist es so cool, dass wir diesen echten Datensatz zur Verfügung haben: Du wirst mit Problemen konfrontiert, die dir auch in Praxis begegnen werden, aber eben nicht in simulierten Datensätzen.

Wie du in der Grafik siehst gibt es einzelne Werte, die doll von allen anderen abweichen. Das verzerrt nicht nur die Grafik sondern auch die Analyse. Das sind sog. Ausreißer. Es gibt, wie eigentlich immer in der Statistik, nicht den einen Weg, damit umzugehen. Was allerdings immer gilt, wenn Ausreiper auftreten: **Check your data!**. Ausreißer können unterschiedlichste Gründe haben. Und je nachdem woher sie kommen, können sie behandelt werden.


Das Anschauen der Daten geht sowohl numerisch als auch optisch.

::: aufgabe
Nutze eine der dir bekannten Möglichkeiten, dir die Variable `weg` numerisch und optisch anzuschauen.
:::

```{r ausreisser-solution}
summary(einkaufen$weg)

table(einkaufen$weg)

ggplot(einkaufen, aes(x = weg)) +
  geom_histogram()
```

```{r ausreisser, exercise=TRUE, exercise.cap="Daten checken"}

```

Der Median liegt bei 3km bedeutet: 50% der Personen haben max. einen Anfahrtsweg von 3km. Das 3. Quantil ist bei 7km: 75% der Personen haben max. einen Anfahrtsweg von 7km. Und der Mean liegt bei 12.76km. Das deutet sehr starkt auf Ausreißerwerte hin. Das Maximum liegt bei 600, was die Vermutung noch bestärkt. Auch optisch wird deutlich, dass der Großteil der Ausprägungen unter 100km liegt.

#### Ursachenanalyse

Das die Ausreißer da sind kann, auch in diesem Fall, verschiedene Gründe haben:

1. Weiter oben im Tutorial wurde bereits erwähnt: Ein Laden liegt an einem ICE Bahnhof. Wenn das stimmt, dann müssten die Ausreißerwerte alle in einem Laden erhoben worden sein (`ort`)

Das lässt sich prüfen. (In diesem Unterkapitel wird nur nach Optik geprüft. In der freien Wildbahn wären statistische Analysen notwendig!)

```{r ausreisser2}
ggplot(einkaufen, aes(x = ort, y = weg)) +
  geom_boxplot()
```

Die Vermutung stimmt teilweise. Ganz schwierig ist, dass der Ladentyp `NA` ist. Das heißt, es ist nicht klar, um welchen und wie viele Läden es sich handelt. Es wurde miterhoben, wer welche Beobachtung aufgeschrieben hat (`befragung`), vielleicht gibt das Aufschluss. Sowohl numerisch, als auch optisch. `geom_count()` ist eine Möglichkeit, Kreuztabellen optisch darzustellen.

```{r ausreisser3}
table(einkaufen$ort, einkaufen$befragung, useNA = "always")

ggplot(einkaufen, aes(x = ort, y = befragung)) +
  geom_count()
```

Sowohl in der Kreuztabelle als auch in der Grafik kannst du sehen, dass jede Person lediglich in 1 Laden erhoben hat. LE hat scheinbar bei einer Person vergessen, den Laden einzutragen. LM und DS haben beide keinen Laden eingetragen. Es könnte also ein Laden sein oder auch 2, das können wir aus den Daten nicht wissen.

Sidefact: Die erhebenden Personen sind btw. klassische Metadaten - also Daten über Daten. Sie scheinen erstmal relativ wenige aussagekräftig. Das ist natürlich quatsch, Metadaten sind richtig mächtig. Hier ist ein sehr unterhaltsames [Beispiel](https://www.youtube.com/watch?v=-YpwsdRKt8Q).

#### Ausschluss

Jetzt ist ein wenig mehr Orientierung bzgl der Ausreißer da. Die Entscheidung, wie damit umgegangen wird ist nach wie vor offen. Spätestens jetzt ist es sehr wichtig, sich nochmal die Eingangsfrage der eigenen Forschung zu stellen: Was wollte ich eigentlich untersuchen? In diesem Fall ging es um die Frage, ob es einen Zusammenhang zwischen Einkaufsweg und Alter gibt. Wenn da Fernreisende mit drin sind, bieten diese logischerweise keine interessante Info für die Frage. Eine Möglichkeit wäre, den Laden am Bahnhof kategorisch auszuschließen. Allerdings ist unklar, ob in den NA Werten nur dieser Laden hinter steckt, deswegen müssten wir alle NAs rausschmeißen, was zum Verlust von 42 Beobachtungen führen würde. Das ist absurd viel. Außerdem kann davon ausgegangen werden, das Menschen auch ihre Alltagseinkäufe dort machen, die wären dadurch kategorisch auch ausgeschlossen. Die nächste Möglichkeit wäre, eine feste Grenze zu setzen. Klassischerweise könnte diese aus der bestehenden Literatur bezogen werden. Also wenn es zB ein Paper geben würde, dass sagen würde: klassische Einkäufe finden in einem Umkreis von 10km statt, könnten alle Werte über 10km ausgeschlossen werden. Das wären schon deutlich weniger. Eine andere Möglichkeit ist die statistische: entweder die Werte außerhalb des Intervalls $[Q_1 - 1.5 \cdot IQR; Q_3 + 1.5 \cdot IQR]$ oder die Werte außerhalb des Intervalls $[\mu \pm 3 \cdot \sigma]$. Wenn die Daten normalverteilt sind (wie angenommen wird für die allermeisten statistischen Analysen, wenn nicht, haben wir noch ganz andere Probleme!), liegen in diesem Bereich 99.8% aller Werte. Es gibt keine Funktion in R, die automatisiert entsprechende Werte rausschmeißt. Das liegt daran, dass die Entscheidung so Situationsabhängig ist und es einfach wichtig ist, sich jedes Mal wieder Gedanken zu machen, wie du damit umgehen möchtest. Hier sind beide Möglichkeiten:

```{r ausreisser4}
quantile(einkaufen$weg, .75, na.rm = T) + (1.5 * IQR(einkaufen$weg, na.rm = T))

mean(einkaufen$weg, na.rm = T) + (3 * sd(einkaufen$weg, na.rm = T))
```

Es wird sehr deutlich, dass die Quantilversion die robustere ist. 15 km Anfahrtsweg für Alltagseinkäufe scheinen deutlich logischer als 172. In diesem Fall wäre also eine Möglichkeit, alle Werte überhalb von 15km auszuschließen. Das geht dann so:

```{r ausreisser5}
# Maximalwert festlegen
maximalwert <- quantile(einkaufen$weg, .75, na.rm = T) + (1.5 * IQR(einkaufen$weg, na.rm = T))

# Ein Subset aus dem aktuellen Datensatz treffen und in dem schon oben neu angelegten Objekt speichern
data_einkaufen <- data_einkaufen[data_einkaufen$weg < maximalwert, ]

# und NAs entfernen
data_einkaufen <- data_einkaufen[!is.na(data_einkaufen$weg), ]
```

#### Dokumentation

**Ganz wichtig!**: Wenn du Daten ausschließt **musst** du das, inklusive der Argumentation warum, gut dokumentieren. Sonst ist das wissenschaftlicher Betrug!


Und jetzt nochmal der Plot ganz vom Anfang:

```{r scatterplot2}
ggplot(data_einkaufen, aes(x = alter, y = weg)) +
  geom_point()
```

Das sieht doch deutlich stimmiger aus.

## 5. Liniendiagramm

::: infobox
Liniendiagramme sind geeignet, um **zwei numerische** Variablen zu Visualisieren. Die x-Variable 
hat dabei häufig eine sequentielle Reihenfolge (wie z.B. die Zeit).

Funktion: `geom_line()`
:::
<br>

Hierfür wird ein anderer Datensatz benötigt, da eine Zeitvariable gebraucht wird. In `heated` ist die maximale Tagestemperatur (`maxtemp`) in Farenheit sowie das Tagesdatum (`enddate`) gespeichert.

```{r linegraph}
ggplot(heated, aes(x = enddate, y = maxtemp)) +
  geom_line()
```

Zwischen den Jahren sind eher horizontale Linien, das liegt daran, dass nur die Monate Mai bis September abgebildet sind. Das Problem ist, dass es durch den Verbindungsstrich den Anschein macht, als gäbe es Daten, die es gar nicht gibt. Um das zu umgehen braucht es in den `aes`thetics die `group` Variable. Mit der Funktion `year()` aus dem Paket `lubridate()` ziehst du *nur* das Jahr aus dem Datum und erschaffst somit eine Gruppe pro Jahr.

```{r linegraph2}
ggplot(heated, aes(x = enddate, y = maxtemp, group = lubridate::year(enddate))) +
  geom_line()
```

Sehr gut, jetzt werden keine Zusammenhänge mehr angedeutet, wo gar keine sind. Und weils noch schöner ist, wenn die lesende Person intuitiv die Zahlen deuten kann wird im letzten Schritt die Grad Farenheit Skala in eine Grad Celsius Skala umgerechnet. Dies geht mit der Funktion `convert_temperature()` aus dem Paket `weathermetrics`. Und weil sich Celsius an 0 Grad orientiert wird die y Achse noch nach unten bis auf 0 Grad erweitert und zu guter letzt die Achsenbeschriftung geändert:

```{r linegraph3}
# Für die Achsenbeschriftung
breaks <- heated$enddate[grepl("07-01", as.character(heated$enddate))]

# hier werden die Temperaturen konvertiert
ggplot(heated, aes(x = enddate, y = weathermetrics::convert_temperature(maxtemp, "f", "c"), group = lubridate::year(enddate))) +
  geom_line() +
  # Verlängerung der y Achse
  expand_limits(y = 0) +
  # Die Breaks/ Achsenbeschriftung ändern
  scale_x_date(breaks = breaks, date_labels = "%b %Y")
```

## 6. Aesthetic Mapping

Jetzt kennst du die 5 häufigsten Diagrammformen. Jetzt kommt farbe ins Spiel. Wie im ersten Kapitel bereits besprochen ist: Die ästhetischen Attribute eines Plots werden festgelegt. Bisher haben wir lediglich die Zuweisung zur x und ggf. y Achse genutzt, da geht allerdings noch viel mehr. Als Erinnerung:

::: infobox
`aes()` steht für *aesthetic attributes*, und weist den einzelnen Variablen, wie z.B. dem Verkehrsmittel, eine *grafische Eigenschaft* zu. Grafische Eigenschaften sind: 

- Achsen (`x`, `y`)
- Farbe (`colour`)
- Füllung (`fill`)
- Form (`shape`)
- Größe (`size`)
- Transparenz (`alpha`)
:::

Also: jeder Variable wird ein ästethisches Attribut zugeordnet. Bedeutet umgekehrt: Es lassen sich bis zu 6 verschiedenen Variablen in einem Plot unterbringen. Wie sinnvoll es ist, das auszureizen, sei dahingestellt.

### Füllung und Farbe

#### Fill

Was allerdings in vielen Fällen sinnvoll ist, ist eine weitere Variable über das Attribut Füllung (`fill`) zu plotten. Das gilt sowohl für *kategoriale* als auch *metrische* Daten.

```{r colour}
ggplot(einkaufen, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar()
```

Dazu kommt nun, dass unterschieden werden kann zwischen Bio- und Nicht-Bioläden. Aber **Achtung**: Es ist kein ausgewogenes Design, es wurde in deutlich mehr Bio- als Nicht-Bioläden erhoben. Das kann in der statistischen Analyse später noch besondere Beachtung benötigen.
Doch zu dem Plot: Scheint erstmal recht einleuchtend. Was jedoch noch besser wäre, um es vergleichbarer zu machen, wäre wenn die farbigen Balken *nebeneinander* und nicht aufeinander stünden. Das lässt sich mit dem Argument `position = "dodge"` erreichen:

```{r colour}
ggplot(einkaufen, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar(position = "dodge")
```

Jetzt ist nur noch bisschen hässlich, dass die Balken unterschiedlich breit sind, je nachdem, ob eine oder beide Faktorstufen vorkommen. Das lässt sich mit dem Argument `position = position_dodge(preserve = "single")` umgestalten:

```{r colour}
ggplot(einkaufen, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar(position = position_dodge(preserve = "single"))
```

#### Colour

Farbe (`colour`) ist ein bisschen tricky: Bei Balkendiagrammen, Histogrammen und Boxplots wird damit die Umrandung der Balken beeinflusst. Hier braucht es noch das Attribut `Füllung`.

```{r colour}
ggplot(einkaufen, aes(x = verkehrsmittel, colour = bioladen)) +
  geom_bar()
```

Bei Punktdiagrammen und Liniendiagrammen wird die Punkt- bzw. Linienfarbe durch `colour` bestimmt. Wird das Attribut Füllung vergeben passiert einfach nichts.

```{r scatterplot2, exercise.setup = "ausreisser5"}
ggplot(data_einkaufen, aes(x = alter, y = weg, colour = bioladen)) +
  geom_point()
```

Eine Ausnahme gibt es: Die Formen 21, 22, 23, 24, 25 in einem Punktediagramm haben sowohl ein Farben als auch ein Füllungsattribut. Doch dazu später mehr.

#### kontinuierlich

Das fill bzw colour Attribut kann genauso gut auf kontinuierliche Variablen angewendet werden:

```{r scatterplot2, exercise.setup = "ausreisser5"}
ggplot(data_einkaufen, aes(x = alter, y = weg, colour = kochen)) +
  geom_point()
```

### Shape

Die Form eignet sich, um in Punktediagrammen eine weitere kategoriale Variable einzubauen.

```{r exercise.setup = "ausreisser5"}
ggplot(data_einkaufen, aes(x = alter, y = weg, shape = verkehrsmittel)) +
  geom_point()
```

Insbesondere wenn es kombiniert wird mit `colour` wird es besonders eindeutig

```{r exercise.setup = "ausreisser5"}
ggplot(data_einkaufen, aes(x = alter, y = weg, shape = verkehrsmittel, colour = verkehrsmittel)) +
  geom_point()
```


### Size

Auch Mittels Größe kann eine weitere Dimension rein gebracht werden. Das ist allerdings mit vorsicht zu genießen, da es in vielen Fällen die Wahrnehmung zu bestimmten Zusammenhängen verzerrt:

```{r scatterplot2, exercise.setup = "ausreisser5"}
ggplot(data_einkaufen, aes(x = alter, y = weg, size = bioladen)) +
  geom_point()
```

Bei diesem Beispiel wird deutlich: Dieses Attribunt ist ungünstig verteilt. es macht den Plot viel unübersichtlicher im Vergleich zu der Info, die die lesende Person daraus ziehen kann. colour aus dem vorherigen Abschnitt war die deutlich bessere Wahl.

Im Grunde gibt es nur 3 Gründe, `size` als ästhetisches Attribut zu nutzen:

1. Bei diskreten Daten, wo die Punkte sonst so sehr übereinander liegen würden, dass die Grafik total Gegenstandslos wäre. (Hierfür wurde allerdings das `geom_count()` entwickelnt)
2. In Momenten, in denen mit der Größe wirklich eine Relation ausgedrückt werden kann (bspw. Gewicht, Quadratmeter oder Bruttoinlandsprodukt)
3. In Korrelationstabellen.

### Alpha

Zu guter letzt folgt die Dichte. Die ist grundsätzlich auch eher ungeeignet. Der Vollständigkeit halber, lernst du sie hier trotzdem kennen:

```{r}
ggplot(data_einkaufen, aes(x = alter, y = weg, alpha = kochen)) +
  geom_point()
```

Hier gilt das gleiche wie bei size: die unterschiedlichen alpha Werte nehmen eine Gewichtung vor, die die Wahrnehmung von Daten verzerren kann.

### Viel zu doll

Weil es auch ein bisschen Spaß bringt hier ein Plot, in dem fast alle Ästhetischen Attribute enthalten sind. Auch wenns Quatsch ist.

```{r}
ggplot(data_einkaufen, aes(x = alter, y = weg, colour = verkehrsmittel, shape = ort, size = bioladen, alpha = kochen)) +
  geom_point() +
  # legende lesbar anordnen
  theme(legend.direction = "horizontal", legend.box = "vertical")
```


### Ästhetische Attribute ohne Mapping

Jetzt kennst du die Möglichkeiten, ästhetische Attribute Variablen zuzuweisen, um noch mehr Information abzubilden. Was du bisher noch nicht gelernt hast ist, diese ästhetischen Attribute auch ohne Mapping (also ohne sie einer Variable, also noch mehr Informationen, zuzuweisen) zu nutzen. Einfach, weil es gut aussieht und Grafiken übersichtlicher und lesbarer macht. Einige Beispiele wurden dir im bisherigen Tutorial schon untergemogelt. Hier sollen sie nochmal den gebührenden Platz finden.

::: aufgabe
Schaue dir den folgenden Codeabschnitt an, führe den Code aus und finde den Unterschied zwischen den verschiedenen Plots
:::

```{r}
ggplot(einkaufen, aes(x = alter, colour = bioladen)) +
  geom_histogram(binwidth = 5, boundary = 50, fill = "grey", position = "identity", alpha = .5)

ggplot(einkaufen, aes(x = alter, fill = bioladen)) +
  geom_histogram(binwidth = 5, boundary = 50, colour = "black", position = "identity", alpha = .5)
```

Richtig erkannt: sobald ein ästhetisches Attribut in der Funktion `aes()` steht, wird ihr eine Variable zugeordnet, sie bringt neue Information mit in den Plot. Das erkennst du auch daran, dass per default eine Legende erstellt wird. Steht eine Attribut einfach in einer geom-Funktion wird der Inhalt auf *alle* Informationen im Plot angewendet, ihr wird ein einzelner Wert zugeordnet und es wird keine Legende erstellt.

Dieses Prinzip gilt für alle oben vorgestellten ästhetischen Attribute. Deiner Phantasie sind keine Grenzen gesetzt. Bevor du jetzt anfängst, wild mit Farben um die zu schmeißen wäre es allerdings wichtig, dass du das Unterkapitel Barrierefreiheit liest - da ist eine wunderschöne Palette vorgestellt, die so richtig Spaß macht :)

## 7. Special: Facets

::: infobox
Facets sind geeignet, um die Daten anhand von ein oder zwei Variablen aufzuteilen und mehr Information bei relativ guter Übersichtlichkeit in die Darstellung zu bekommen.

Funktion: `facet_grid()` und `facet_wrap()`.
:::
<br>

### `facet_grid()`

Für eine oder zwei Variablen. Wie auch bei anderen Indizierungen in R gilt: bei der 1. Stelle werden die Zeilen benannt, in der 2. die Spalten. In diesem Fall werden sie durch eine Tilde (`~`) verbunden. Wenn du nur eines von beiden willst kannst du einfach die Stelle vor bzw. nach der Tilde leer lassen.

In diesem Fall wird der veränderte Datensatz verwendet. Alle Veränderungen wurden im Laufe des bisherigen Tutorials argumentiert und dokumentiert.

::: aufgabe
Führe den Code aus und mache dich mit dem Ergebnis vertraut. Lösche jeweils einmal die Variable vor sowie nach der Tilde heraus und schaue, wie sich das Ergebnis verändert.
:::

```{r}
ggplot(data_einkaufen, aes(x = alter, y = weg)) +
  geom_point() +
  facet_grid(bioladen ~ verkehrsmittel)
```

Beachte: Hier wird (erneut) deutlich, welche Auswirkungen ein unbalanciertes Design hat. Da es sehr viel weniger Beobachtungen aus nicht Bioläden gibt, können die Zusammenhänge im Zweifel nicht wirklich dargestellt werden.

### `facet_wrap()`

Für den Fall, dass die Facetten nur anhand einer Variable aufmachen möchtest, du aber flexibler in der Form bleiben möchtest. Du kannst die Zeilen- **oder** die Spaltenanzahl bestimmen durch die Argumente `ncol` bzw. `nrow`.

::: aufgabe
Führe den Code aus, mach dich mit den Auswirkungen von `nrow` vertraut und setze anstatt dessen `ncol` ein.
:::

```{r}
ggplot(data_einkaufen, aes(x = alter, y = weg)) +
  geom_point() +
  facet_wrap(~verkehrsmittel, nrow = 3)
```
## 8. Das Drumherum: Labs, Themes usw.

Was noch fehlt um die Grafiken ganz grundlegend ein bisschen schöner zu machen ist die grundsätzliche Gestaltung der Plots sowie die grundsätzlichen Beschriftungen.

### Themes

Es gibt verschiedene Themes, welche Hintergrundfarbe, Umrandungen etc. bestimmen. Eine Übersicht findest du [hier](https://ggplot2.tidyverse.org/reference/ggtheme.html). Themes werden als eine weitere Lage dem Plot hinzugefügt.

::: aufgabe
Suche dir ein Theme deiner Wahl aus und füge es dem untenstehenden Plot hinzu
:::

```{r}
# Ein Beispiel:
ggplot(data_einkaufen, aes(x = alter, y = weg)) +
  geom_point() +
  theme_bw()
```

```{r}
ggplot(data_einkaufen, aes(x = alter, y = weg)) +
  geom_point()
```

### Labs

Die Beschriftungen sind ebenfalls eine weitere Lage und werden mittels `labs()` Funktion hinzu gefügt.

::: aufgabe
Ändere die Beschriftungen so, dass sie Sinn ergeben
:::


```{r}
ggplot(data_einkaufen, aes(x = alter, y = weg)) +
  geom_point() +
  labs(
    title = "Titel",
    subtitle = "Untertitel",
    x = "x-Achse",
    y = "y-Achse",
    caption = "Fußnote"
  )
```

## Barrierefreiheit

Es mag erstmal überraschen aber: auch in visuellen Darstellungen ist Barrierefreiheit ein relevantes Thema. Ein nicht zu vernachlässigender Anteil der Bevölkerung kann bestimmte Farben nicht unterscheiden. Deswegen wurden von schlauen Menschen Farbpaletten entworfen, die keine ambivalenten Farben wie rot und grün enthalten, und auch ganz ohne Farbwahrnehmung nur über Helligkeit und Dunkelheit der Farben in schwarz weiß funktionieren. Der letzte Punkt ist ebenfalls relevant für alle Plots, die in schwarz weiß (wie bspw. in manchen Journals) aus- oder abgedruckt werden. 

Eine der verbreitetesten ist das Paket `viridis`. Es hat auch seine eigene [Hilfe Seite](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) auf der die Verwendung und möglichen Farbschemen dargestellt werden. 

Hier ein Beispiel:

```{r viridis-demo, message=FALSE, warning=FALSE}
library(ggplot2)
library(hexbin)
library(viridis)

dat <- data.frame(x = rnorm(10000), y = rnorm(10000))

p <- ggplot(dat, aes(x = x, y = y)) +
  geom_hex() + coord_fixed() +
  scale_fill_gradientn(colours = viridis(256, option = "D")) +
  theme_bw()

p
```

Zuerst fällt auf: Die Farben sind einfach auch deutlich schöner als die Standard-Farbpalette von R. 

Und die obenstehende Grafik ist ein gutes Beispiel dafür, wie hell-dunkel Kontraste verwendet werden können. So ist das Ganze in schwarz-weiß immer noch lesbar, was insbesondere für Menschen mit eingeschränkter Farbwahrnehmung klasse ist, denn alles was schwarz weiß gut lesbar ist, ist immer auch colorblind-friendly. 

Im Grunde folgt die Anwendung von Viridis immer dem gleichen Prinzip: Du sagst R in den aesthetics, welche Variable R über colour oder fill abbilden soll. Dann fügst du eine weitere Ebene hinzu, in der du die Farbwahl spezifizierst. Diese Ebene hängt von 2 Punkten ab: hast du fill oder colour zugewiesen? Und: ist es eine kontinuierliche oder eine diskrete Variable:

|                    |   `colour`                             |   `fill`                           |
|--------------------|----------------------------------------|------------------------------------|
| **diskret**        | `scale_colour_viridis(discrete = T)`   | `scale_fill_viridis(discrete = T)` |
| **kontinuierlich** | `scale_colour_viridis()`               | `scale_fill_viridis()`             |

Zusätzlich gibt es noch die Möglichkeit, sich eine Palette (s. [Hilfeseite](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)) auszusuchen. Das geht mit dem Argument `option = ` und dann eine der Paletten in Anführungszeichen ! (`"magma"`, `"inferno"`, `"plasma"`, `"viridis"`, `"cividis"`, `"rocket"`, `"mako"` oder `"turbo"`).




::: aufgabe
:::

```{r exvi, exercise = TRUE}
```




## Becoming a Pro

In Zukunft möchtest du wahrscheinlich deine eigenen Visualisierungen ganz nach deinen Wünschen gestalten,  - darum geht es ja hier auch! Denn diese Basics sind zwar schon hilfreich, aber beeindruckend und besonders ästhetisch sind sie noch nicht. 

Also wie kommst du zum nächsten Level? - Recherche! Informiere dich im Internet was für deine Zwecke möglich ist und passe den Beispielcode auf deine Daten an. (Das gilt übrigens für alle Tutorials und Alles, was du hier in diesem Kurs lernst). 

In den ersten Tutorials haben wir dir bereits *Cheat Sheets* verlinkt und auch zu Beginn dieses Tutorials die super hilfreiche Seite [R Graph Gallery](https://r-graph-gallery.com/) empfohlen. 

**Cheat Sheets** 
Sind eine fantastische erste Anlaufstelle, wenn du dir Zeit nimmst sie zu verstehen. Sie geben dir für ein bestimmtes Paket einen guten Überblick zu den vielzähligen Funktionen und deren Code. Somit fungieren Sie wie die `Hilfe` Seite einer Funktion oder eines Paketes, das für dich visuell aufbereitet wurde.

Hier kannst du die [von R Studio erstellten Cheat Sheets](https://rstudio.github.io/cheatsheets/) finden. Es gibt aber auch noch weitere *Cheat Sheets* von anderen Instanzen. 

::: aufgaberstudio
Hier mal eine besondere Aufgabe: Schau dir das [ggplot Cheat Sheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf) genau an und beantworte dann folgende Fragen.
:::

</br>

```{r question_cheatsheet}
quiz(caption = "Das Cheat Sheet verstehen",
question_checkbox("In der Box zu Basics hast du gelernt, dass diese Funktionen notwendig zur Erstellung einer Grafik sind:",
               answer("`ggplot(data = ...)`",
                      correct = TRUE,
                      message = "Wir brauchen Daten, die wir visualiesieren können."),
               answer("`stat = ...`",
                      message = "Die Nutzung von in der ggplot-Funktion neu berechneten Statistiken ist kein muss."),
               answer("`mapping = aes(...)`",
                      correct = TRUE,
                      message = "Wir brauchen natürlich auch `aes` für ein Koordinatensystem."),
                answer("`geom_...()`",
                       correct = TRUE,
                      message = "Die `geom` Funktion brauchen wir für das Einzeichnen unserer Datenpunkte."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),


question_radio("Welche Art von Variablen wird für die Funktion `g + geom_count()` benötigt?",
               answer("Zwei diskrete Variablen", 
                      correct = TRUE, 
                      message = "Das Cheat Sheet ist so aufgebaut, dass die Buchstaben vor den Funktionen (z.B. das `g +` vor `geom_count()`) im Abschnitt `Geoms` für die entsprechenden Skalenniveaus und Anzahl der Variablen stehen."),
               answer("Eine kontinuierliche Variable"),
               answer("Zwei kontinuierliche Variablen"),
               allow_retry = T,
               random_answer_order = T,
               incorrect = "Leider nicht richtig, probier es noch mal!"),

question_radio("Wie kannst du deiner Grafik Achsebeschriftungen hinzufügen?",
               answer("`labs(x = , y = )`",
                      correct = TRUE,
                      message = "Richtig, du kannst für die jeweiligen Variablen auf Achse x und y eine Legende einfügen lassen."),
               answer("`labels(x = , y = )`"),
               answer("`leg(x = , y = )`"),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               incorrect = random_encouragement(language = "de"))
)
```


### Farbanpassung und Verbesserungen

Da du jetzt vertraut mit dem Sheet Cheat bist, versuche herauszufinden, wie du die Farben deiner Grafik 

Wie bei anderen Diagrammen kannst du Farben und Stile anpassen, um die Lesbarkeit zu verbessern. Dafür kannst du in der Funktion `geom_boxplot()` u.a. die Argumente `color`, `fill` und `alpha` nutzen.

```{r boxplotColor, exercise = TRUE, exercise.cap = "Boxplot mit Farbe"}
library(viridis)

ggplot(einkaufen, aes(x = ort, y = alter, fill = ort)) +
  geom_boxplot() +
  scale_fill_viridis_d(alpha = 0.7)
```

## Überblick bekommen

Wie ganz zu Beginn erwähnt, benutzen wir Visualisierungen für zweierlei Zwecke:

- einmal um einen **Überblick** zu gewinnen
- am Ende um **Ergebnisse** zu **kommunizieren**

Es lassen sich eigentlich alle Grafiken nuzten, um Ergebnisse zu kommunizieren, aber welche eignen sich dafür einen Überblick zu bekommen, um deine (zunächst unverständlich großen) Daten besser zu verstehen? Hier nur eine kurze Auflistung: 

1. *Histogramme*:
Zweck: Zeigt die Verteilung der Daten.
Verwendung: Geeignet, um die Form der Verteilung, Zentralität und Streuung zu untersuchen.

2. *Boxplots*:
Zweck: Veranschaulicht die Verteilung und Zentralität der Daten sowie Ausreißer.
Verwendung: Besonders hilfreich bei der Identifizierung von Ausreißern.

3. *Streudiagramme* (Scatter Plots):
Zweck: Zeigt die Beziehung zwischen zwei kontinuierlichen Variablen.
Verwendung: Ermöglicht die Identifizierung von Mustern, Korrelationen oder Ausreißern.

Dieser Art der Nutzung von Visualisierungen wirst du in späteren Tutorials erneut begegnen, wenn wir diese zur Überprüfung der Voraussetzungen für eine statistische Testgröße verwenden. Jetzt hast du es bereits schon einmal gehört - oder eher *gelesen* - und weißt dann, wenn die Zeit gekommen ist, schon Bescheid was wir zur Verfügung haben. 


## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

## Credit

Dieses Tutorial wurde gemeinsam von Gesa Graf, Lukas Bruelheide und Marie
Klosterkamp verfasst. 

### Literaturverzeichnis

<!--  Wird automatisch generiert aus den @autorYYYY-Zitationen und der Bibliothek in ref.json. Das Literaturverzeichnis wird immer ans Ende generiert, deswegen muss das hier die letzte Überschrift bleiben. -->
