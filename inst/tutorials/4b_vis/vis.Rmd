---
title: "Visualisierung"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Schnelle Diagramme erstellen, schöne Diagramme erstellen. Die Grammar of Graphs wird kurz erklärt, das Prinzip wonach ggplot2 aufgebaut ist. Die Erstellung verschiedener Diagrammarten wird geübt. Aesthetic Mappings, Geoms, Facets. 
resource_files:
- css/boxes.css
tutorial:
      id: ggplot
      version: 5
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(kableExtra)
library(tibble)
library(rtutorials)
library(dplyr)
library(viridis)
knitr::opts_chunk$set(echo = FALSE)
colnames(einkaufen) <- tolower(colnames(einkaufen))
```

## Inhalt

Jetzt kommt wirklich einer der allercoolsten Teile des ganzen Kurses. R ist einfach unfassbar mächtig, was das Visualisieren von Daten angeht, viel ausgefeilter und vielfältiger, als Excel und SPSS es je erreichen können. Unser Ziel ist euch ein paar schnelle Kochrezepte für die wichtigsten Visualisierungsaufgaben mitzugeben, und die Neugier auf mehr zu wecken, in dem wir eine kleine Einführung in das Visualisierungspaket `ggplot2` geben.

Mit R sind abgefahrene Sachen möglich. Eine vielfältige Übersicht darüber, was alles geht, erhältst du in der [R Graph Gallery](https://r-graph-gallery.com/). Hier sind ein paar Beispiele:

#### [Eine Karte im Stil von Jacques Bertin](https://r-graph-gallery.com/web-valued-dots-map-bertin.html)

![](images/compress/bertin.png){width="80%"}

#### [Heatmap stündliche Temperatur über zwei Jahre](https://r-graph-gallery.com/283-the-hourly-heatmap.html)

![](images/compress/temp.png){width="80%"}

#### [Aber auch solche geometrischen Schönheiten](https://fronkonstin.com/tag/ggplot2/page/3/)

```{r fronkonstin, fig.asp = 1, out.width="80%"}
n=300
t1=1:n
t0=seq(3,2*n+1,2)%%n
t2=t0+(t0==0)*n
df=data.frame(x=cos((t1-1)*2*pi/n), 
y=sin((t1-1)*2*pi/n),
x2=cos((t2-1)*2*pi/n),
y2=sin((t2-1)*2*pi/n))
ggplot(df,aes(x,y,xend=x2,yend=y2)) +
geom_segment(alpha=.1)+theme_void()
```

Ziemlich beeindruckend, oder?

Das soll hier aber nur ein kleiner Einblick in das sein, was alles möglich ist. In diesem Tutorial starten wir natürlich bei den Basics und fokussieren uns darauf grundständige Diagramme zu zeichnen. Mit diesem Grundwissen kannst du dir dann auch selbst beibringen solche abgefahrenen Diagramme zu erstellen.

In den Links über den Grafiken findest du detaillierte Anleitungen, wenn du dann soweit bist.

Wie gesagt, wir fangen Schritt für Schritt an und daher sind das hier die Ziele für heute:

### Lernziele

<input type="checkbox" unchecked> Balkendiagramm (*barplot*) erstellen </input>

<input type="checkbox" unchecked> Histogramm (*histogram*) erstellen </input>

<input type="checkbox" unchecked> *Boxplot* erstellen </input>

<input type="checkbox" unchecked> Punktdiagramm (*scatterplot*) erstellen </input>

<input type="checkbox" unchecked> Liniendiagramm (*linegraph*) erstellen </input>

<input type="checkbox" unchecked> Schnelle Grafikfunktionen, um einen Überblick zu gewinnen </input>

<input type="checkbox" unchecked> Grafiken mit `ggplot2` nach dem Baukasten der *Grammar of Graphs* erstellen </input>

<input type="checkbox" unchecked> colorblind-friendly sein </input>

### Die fünf essentiellen Diagrammtypen

```{r echo=FALSE}
de <- c("Balkendiagramm", "Histogramm","Boxplot", "Punktdiagramm","Liniendiagramm")
en <- c("barplot", "histogram", "boxplot", "scatterplot","linegraph")
vars <- c("1 kategoriale Variable", "1 stetige Variable", "1 kategoriale & 1 stetige Variable", "2 stetige Variablen", "1 stetige und 1 zeitlich geordnete Variable")
tibble(` `= c("1.", "2.", "3.", "4.", "5."), de, en, `geeignet für` = vars) |>
  kbl() |>
  kable_styling()
```

```{r fiveplots, fig.height=8, out.width="100%"}
par(mfrow = c(3, 2),
    bty = "n")
barplot({einkaufen$verkehrsmittel |> table()}[1:5],
        main = "1.",
        axes = F,
        ylab = NA,
        xlab = NA,
        names.arg = NA)
hist(heated$maxtemp,
     main = "2.",
     axes = F,
     ylab = NA,
     xlab = NA)
boxplot(heated$maxtemp ~ factor(lubridate::month(heated$enddate)),
        main = "3.",
        axes = F,
        ylab = NA,
        xlab = NA)
plot(heated[ ,c("maxtemp", "edvisits")],
     main = "4.",
     axes = F,
     ylab = NA,
     xlab = NA)
plot(heated$enddate[heated$enddate > as.Date("2022-03-24")], 
     heated$maxtemp[heated$enddate > as.Date("2022-03-24")],
     type = "l",
     main = "5.",
     axes = F,
     ylab = NA,
     xlab = NA)
# reset par
par(mfrow = c(1, 1),
    bty = "o")
```

## Einführung

Es gibt (wie immer) tausend verschiedene Wege, Visualisierungen mit R zu erstellen. Aber einer hat sich über die Jahre als besonders beliebt erwiesen, und das ist das Paket `ggplot2`.

Der Grund, warum wir dir diesen Weg beibringen:

-   **klares Baukastenprinzip**: Auch später können komplexe Anpassungen der Grafik an die eigenen Vorstellungen relativ schmerzfrei umgesetzt werden
-   **Popularität**: Es gibt auf Google viele gute Anleitungen. 

- **Funktionalität**: `ggplot2` kann eigentlich alles, was du brauchst, und wenn es etwas nicht kann, gibt es dafür mit hoher Wahrscheinlichkeit bereits ein Paket 

### Grammar of Graphs

Das `gg` im Paketnamen `ggplot2` steht für *Grammar of Graphs*.

Leland Wilkinson ist der Gründer des Grammar of Graphs-Ansatzes. Im Grunde ist das eine Theorie darüber, mit welchen Regeln und Bausteinen statistische Grafiken gut und übersichtlich erstellt werden können [@wilkinson2005].

`ggplot2` ist die Umsetzung dieses theoretischen Baukastens. Es wurde von Hadley Wickham geschrieben und ist ein relativ altes Paket im R-Ökosystem [@wickham2009].

#### benötigtes Paket

::: aufgabe
Der erste Schritt für dieses Tutorial ist, das Paket `ggplot2` in die aktive Sitzung zu laden. Tu das mittels `library()`. (Installiert hast du es schon, sonst wären alle anderen Tutorials nicht gelaufen.)
:::

```{r lib, exercise = TRUE, exercise.cap = "ggplot2 laden"}
library()
```

```{r lib-solution}
library(ggplot2)
```

### Einordnung in das R-Ökosystem

`ggplot2` ist nur eins von mehreren Interfaces für die unterhalb der Oberfläche liegenden Grafik-Strukturen von R. Es ist also nur eine Spitze des Eisbergs, und der Eisberg hat mehrere Spitzen, zum Beispiel das Paket `lattice` oder Visualisierungsfunktionen aus base R.

Ein Beispiel:\
Wenn du im Internet nach „Balkendiagramm erstellen mit R“ suchst, wirst du vermutlich Anleitungen für die base R-Variante `barplot()` finden. Trotzdem geht das auch mit `ggplot2`. Du kannst am Ende den Weg verwenden, der dir näher liegt. Wir denken, dass `ggplot2` zu einem intuitven Interface für dich werden kann, aber möchten dir bewusst machen, dass es keinesfalls das einzig Wahre ist! Jede Variante hat eigene Vor- und Nachteile.

Letztlich nutzen alle *higher level* Grafik-Funktionen unter der Oberfläche entweder `grid` oder `graphics`, um Grafiken zu erstellen. `ggplot2` gehört zur Familie der `grid`-basierten Grafikpakete. 

![](images/compress/deep_r_gagolewski.png){width="80%"}

Bild aus: [@gagolewski2023]: [Deep R Programming](https://deepr.gagolewski.com/chapter/250-graphics.html)

### Einordnung in den Prozess

Die Daten sind erhoben, importiert und nun kommen die Grafiken. Sie sind ein guter Weg, Zusammenhänge in den Daten sichtbar zu machen. Zum einen, um sich selbst in den Daten zu orientieren, und zum anderen, um die Ergebnisse der Analyse zu präsentieren. Visualisierungen werden also an zwei Stellen im Prozess benötigt:

-   um einen **Überblick** zu gewinnen
-   um am Ende **Ergebnisse** zu **kommunizieren**

![](images/compress/prozess.png){width="80%"}

Welche Grafik du wann anwenden kannst, hängt vom Skalenniveau der Daten und der Anzahl von Variablen ab.

Grob kann unterschieden werden zwischen:

-   Plots, die die **Verteilung einer** einzelnen Variablen darstellen
-   Plots, die den **Zusammenhang** zwischen **zwei oder mehr** Variablen zeigen

Die am häufigsten verwendeten und in diesem Tutorial vorgestellten Plots sind:

|                             | kategorial                      | kontinuierlich                    |
|------------------|:-----------------------|:-----------------------------|
| **keine**                   | Balkendiagramm <br>`geom_bar()` | Histogramm <br>`geom_histogram()` |
| **kategorial**              | (`geom_count()`)                | Boxplot<br>`geom_boxplot()`       |
| **kontinuierlich**          | \-                              | Punktdiagramm<br>`geom_point()`   |
| **sequentiell (z.B. Zeit)** | \-                              | Liniendiagramm<br>`geom_line()`   |

Steigen wir direkt ein!

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verfügbaren Online-Lehrbuch namens [*Modern Dive*](https://www.moderndive.com) [@ismay2022]. Wir haben die Reihenfolge geändert, Sachen übersetzt und paraphrasiert und unsere eigenen Gedanken hinzugefügt.

<hr>

## 1. Balkendiagramm

::: infobox
Balkendiagramme sind geeignet, um die **Verteilung** einer **einzelnen**, **kategorialen** Variable zu zeigen.

Funktion: `ggplot() + geom_bar()`
:::

<br>

::: aufgabe
So sieht Code aus, um mit `ggplot2` ein einfaches Balkendiagramm zu erstellen (das schön machen kommt später). Führe ihn aus.
:::

```{r barplot, exercise = TRUE, exercise.cap = "Einfacher Barplot"}
ggplot(data = einkaufen,
       mapping = aes(x = verkehrsmittel)) +
  geom_bar()
```

Dabei wird deutlich, dass der Code durch eine klare Sprache organisiert ist:

-   in `data` wird ein Datensatz an die Funktion übergeben
-   in `mapping` wird festgelegt, welche Variablen aus dem Datensatz wo gezeigt werden
-   das `+` fügt eine neue Ebene hinzu, genau wie in Photoshop / Gimp / bei Overhead-Folien
-   `geom_bar()` fügt ein `geom`etrisches Objekt, nämlich die Balken (`bar`s), hinzu

Mehr dazu, wie genau dieses Mapping funktioniert, folgt später.

### Baukasten-Prinzip

Leland Wilkonson, Begründer der *Grammar of Graphs*-Theorie sagt, dass sich jede statistische Grafik durch diese drei Kernbestandteile beschreiben lässt:

-   `data`
-   `aesthetic mapping`
-   `geom`etric objects

Mit data kennst du dich ja jetzt schon aus, daher können wir direkt zum *mapping* übergehen. Wichtig ist nur zu wissen, dass `ggplot()` nur *data frames* als Daten akzeptiert.

### aesthetic mapping

`aes()` steht für *aesthetic attributes*. Beim `aesthetic mapping` (oben im Code: `mapping = aes(x = verkehrsmittel)`) wird einer Variable eine *grafische Eigenschaft* zugeordnet. Grafische Eigenschaften sind:

-   Achsen (`x`, `y`)
-   Farbe (`colour`)
-   Füllung (`fill`)
-   Größe (`size`)
-   Transparenz (`alpha`)

Im Diagramm oben wurde der *x-Achse* die Variable *Verkehrsmittel* zugewiesen.

::: aufgabe
Ändere den Code so, dass die Variable Verkehrsmittel statt auf der `x`-Achse nun auf die `y`-Achse gemappt wird. Wie wird sich das Diagramm wohl verändern?
:::

<br>

::: blau-nb
Beachte, dass hier die Argumentnamen `data` und `mapping` weggelassen wurden, so wie es in der Praxis üblicherweise auch getan wird. Das ist möglich, da die Reihenfolge der Argumente beachtet wird, also erst `data`, dann `mapping` und schließlich `geom`etric objects.
:::

```{r ybarplot, exercise = TRUE, exercise.cap = "Mapping ändern auf y-Achse"}
ggplot(einkaufen, aes(x = verkehrsmittel)) +
  geom_bar()
```

```{r ybarplot-solution}
ggplot(einkaufen, aes(y = verkehrsmittel)) +
  geom_bar()
```

Es gibt, wie oben erwähnt, noch mehr *aesthetic attributes* außer der `x`-Achse und der `y`-Achse, die bekommen später noch ihren Raum.

### `geom_bar`

Und was ist dieses `geom_bar()`? Das wird am ehesten deutlich, wenn es weggelassen wird!

::: aufgabe
Schau dir an, wie der Plot aussieht ohne die Ebene mit`geom_bar()`!
:::

```{r plotwithoutgeom, exercise = TRUE, exercise.cap = "Ohne geom"}
ggplot(einkaufen, aes(x = verkehrsmittel))
```

Jetzt versteht du vielleicht, wofür die `geom_bar()`-Funktion da ist: Geometrische Formen, in diesem Fall Balken, in den Plot zu zeichnen! Der Plot ist leer, aber die Achsen sind bereits beschriftet und perfekt vorbereitet, aber es fehlt noch das geometrische Objekt.

Innerhalb der `geom_bar()`-Funktion finden Berechnungen statt: die einzelnen Ausprägungen der Verkehrsmittel werden gezählt, um die Höhe der Balken zu bestimmen. Aber das passiert alles im Hintergrund.

Und jetzt kommt das Ding: Es gibt auch noch andere `geom_...()` Funktionen. Zum Beispiel `geom_point()`, welche dem Plot Punkte hinzufügt! Oder `geom_histogram()`, welche ein Histogramm zeichnet, siehe nächster Abschnitt.

::: aufgabe
Probiere das doch einfach mal aus und tausche `geom_bar()` durch `geom_point()`.
:::

```{r error-solution}
ggplot(einkaufen, aes(x = verkehrsmittel)) +
  geom_point()
```

```{r error, exercise = TRUE, exercise.cap = "Fehlermeldung"}
ggplot(einkaufen, aes(x = verkehrsmittel)) +
  geom_bar()

```

Dass hier eine Fehlermeldung aufploppt, ist völlig normal! Fehlermeldungen sind freundlich, denn Programmierer\*innen geben sich (oft) viel Mühe, diese möglichst informativ und genau zu machen. Also hab keine Angst, und lies dir tatsächlich mal durch was da steht!

```         
! Problem while setting up geom.
ℹ Error occurred in the 1st layer.
Caused by error in `compute_geom_1()`:
! `geom_point()` requires the following missing aesthetics: y
```

-   Schon die erste Zeile gibt dir eine wichtige Information: Der Fehler trat beim Hinzufügen des `geom`etrischen Objekts auf und nicht an irgendeiner anderen Stelle
-   Die zweite Zeile sagt, dass der Fehler in der ersten Zeile / Ebene passiert ist. Das wird relevant, wenn du mehrere Ebenen mit `+` übereinanderlegst in deinem Plot.
-   Die dritte Zeile musst du nicht genau verstehen, das ist irgendwas internes von `ggplot2`
-   die vierte Zeile schließlich sagt dir ganz genau, wo das Problem ist: Du brauchst eine zweite Variable. Und zwar auf der y-Achse. Das ergibt auch Sinn, denn ein Punkt hat immer zwei Koordinaten, eine `x`- und eine `y`-Koordinate! Logischerweise kann kein Punkt gezeichnet werden, wenn du nur eine `x`-Koordinate angibst.

::: aufgabe
Löse das Problem, indem du in `aes()` noch das Argument `y = weg` angibst. Denk daran, Argumente werden durch Kommata getrennt.

"`weg`" ist eine stetige Variable, die den zurückgelegten Anreiseweg der Person zum Laden, wo die Erhebung stattfand, in km enthält.
:::

```{r weg, exercise = TRUE, exercise.cap = "aesthetic mapping hinzufügen für y-Achse"}
ggplot(einkaufen, aes(x = verkehrsmittel)) +
  geom_point()
```

```{r weg-solution}
ggplot(einkaufen, aes(x = verkehrsmittel, y = weg)) +
  geom_point()
```

Ok, das Diagramm ist vielleicht nicht ultra informativ, weil ganz viele Punkte übereinandergelagert wurden an manchen Stellen. Es gibt definitiv ein anderes, geeigneteres Diagramm! Hier ging es nur darum, das Prinzip zu zeigen: Fehlermeldungen sind freundlich, `ggplot` funktioniert wie ein Baukasten, und das `geom` können wir austauschen, so lange dafür gesorgt wird, dass in den `aes`thetic mappings Variablen und Skalenniveau zu dem jeweiligen `geom` passen!

```{r weg-quest}
quiz(caption = "Quiz zu den Balkendiagrammen",
     question("Welche Daten lassen sich gut mit Balkendiagrammen darstellen?",
               answer("Eine einzelne, kategoriale Variable.",
                      correct = TRUE),
               answer("Eine einzelne, stetig Variable.",
                      message = "Schon fast richtig. 
                      Es ist eine einzelne Variable, aber sie ist nicht stetig, versuch es nochmal. Für diese Datenart eignet sich ein Histogramm."),
               answer("Zwei kategoriale Variablen.",
                      message = "Schon fast richtig. Die Variable ist kategorial, aber es sind nicht zwei. Für diese Datenart eignet sich eine Kreuztabelle."),
               answer("Zwei stetige Variablen.",
                      message = "Für diese Datenart eignet sich ein Punktdiagramm."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question_radio("Wie fügst du eine neue Ebene zum Plot hinzu?",
         answer("Mit dem `+`", correct = TRUE),
         answer("Mit dem Pipe-Operator `|>` oder `%>%`"),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("Welche drei Kernbestandteile hat laut der Grammar of Graphs Theorie von Leland Wilkinson 
         jede statistische Grafik?",
               answer("Daten",
                      correct = TRUE),
               answer("Ästhetische Attribute",
                      correct = TRUE),
               answer("Geometrische Objekte",
                      correct = T),
               answer("Statistische Kennzahlen",
                      message = "Statistische Kennzahlen können Teil einer Grafik sein, müssen es jedoch nicht."),
                        allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),
         
    question_radio("Wo spezifizierst du, welche Variable auf welcher Achse angezeigt wird?",
                   answer("In der Funktion `aes()` (*aesthetic mappings*)",
                          correct = TRUE),
                   answer("In der `library()` ganz zu Beginn des Skripts"),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),
question_radio("Wie kannst du Variablen in `aes()` angeben?",
               answer("Mit der gewohnten Schreibweise: `einkaufen$alter`. Damit weiß R, dass `alter` im Datensatz `einkaufen` zu finden ist.",
                      message = "Das funktioniert zwar, aber ist unübersichtlicher und unüblich."),
               answer("Einfach nur den Variablennamen `alter`, da der Datensatz bereits vorher angegeben wurde. So weiß R, wo die Variable `alter` zu finden ist", correct = TRUE),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               incorrect = random_encouragement(language = "de")),
question_radio("Was passiert, wenn du `ggplot()` ohne eine `geom`-Ebene ausführst?",
               answer("Ein leerer Plot mit korrekten Achsenbeschriftungen wird gezeichnet, aber ohne geometrische Formen", correct = TRUE),
               answer("Es kommt zu einer Fehlermeldung!"),
               allow_retry = TRUE,
               incorrect = random_encouragement("de"),
               correct = random_praise("de")),
question_radio("Zusatz**: Welche Art von Daten wird akzeptiert durch `ggplot()`?",
               answer("Nur Vektoren"),
               answer("Nur Data Frames", correct = TRUE),
               random_answer_order = TRUE,
               allow_retry = TRUE,
               incorrect = random_encouragement("de"),
               correct = random_praise("de"))

)
```

## 2. Histogramm

::: infobox
Histogramme sind geeignet, um die Verteilung einer **einzelnen**, **stetigen** Variable zu zeigen.

Funktion: `geom_histogram()`
:::

<br>

Unser Go-To-Beispiel für eine stetige Variable ist `einkaufen$alter`, die dir schon in den letzten Tutorials begegnet sein sollte. Beachte, dass du innerhalb eines `ggplot`-Codes den `$`-Operator nicht benutzen musst. Das liegt daran, dass `ggplot` aufgrund des ersten Arguments schon weiß, in welchem Datensatz die Variable gesucht werden muss.

Hier ist `ggplot2`-Code für ein einfaches, absolut nicht schönes Histogramm. In diesem Abschnitt wird es deswegen auch mal Zeit, über Farben und Verschönerungen zu sprechen.

```{r hist, exercise = TRUE, exercise.cap = "einfaches Histogramm erstellen"}
ggplot(einkaufen, aes(alter)) +
  geom_histogram()
```

### Was ist ein Histogramm?

Bei einem Histogramm werden auf der x-Achse die möglichen Ausprägungen der Variable aufgelistet, und auf der y-Achse die Häufigkeit. Es ist also genau das gleiche Prinzip wie bei einem Balkendiagramm, nur dass du dich hier zusätzlich noch mit der Kategorienbreite (*binwidth*) auseinandersetzen musst.

Denn: Balkendiagramme sind für diskrete Daten, und diskrete Daten haben natürliche Kategorien. Zum Beispiel ist das Verkehrsmittel ÖPNV etwas anderes als Motorrad - die Kategorien liegen also schon in der Natur der Sache.

Das ist bei stetigen (kontinuierlichen) Daten anders: Von Natur her gibt es bei stetigen Daten immer unendlich viele mögliche Ausprägungen, und also auch immer unendlich viele mögliche Kategorien.

Zum Beispiel kann ein Meter in unendlich feine Messeinheiten aufgeteilt werden:

-   Meter
-   Dezimeter
-   Zentimeter
-   Millimeter
-   Mikrometer
-   Nanometer
-   Picometer
-   Femtometer
-   Attometer ...

Da es unendlich Möglichkeiten gibt einen Meter einzuteilen, gehen keine natürlichen Kategorien daraus hervor. Deswegen können die Kategorien beliebig gebildet werden.

Beim Histogramm des Alters oben sind die Balken zum Beispiel immer 2.5 Jahre breit, komplett random also. Darüber informiert `ggplot` auch beim Erstellen des Diagramms mit einer Nachricht:

```         
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`
```

`ggplot` sagt damit: „Hey, ich habe deine Daten einfach mal in 30 gleich große Kategorien eingeteilt, aber das ist ein default-Wert, den du bitte anpassen solltest.“

### Kategorienbreite anpassen

In der Warnmeldung wurde bereits das Argument `binwidth` erwähnt. Hier ist Code, mit dem die Kategorienbreite auf 5 (Jahre) festgelegt wird.

```{r binwidth, exercise = TRUE, exercise.cap = "Kategorienbreite einstellen"}
ggplot(einkaufen, aes(x = alter)) +
  geom_histogram(binwidth = 5)
```

### `colour` und `fill`

Da die Balken gerade visuell in einer großen grauen Masse verschwinden, wird noch nicht so ganz deutlich worum es eigentlich geht. Deswegen wäre es hilfreich, wenn alle Balken eine schwarze Umrandung hätten und etwas hellgrauer wären. Beachte, dass jetzt nach dem `binwidth`-Argument dafür noch die Argumente `color` und `fill` stehen.

Fun fact: in `ggplot` ist es für R egal, ob du die UK Variante von `colour` schreibst oder das amerikanische `color`. Wie das geschrieben wird ist in diesem Fall reine Geschmackssache.

```{r color, exercise = TRUE, exercise.cap = "Color und Fill"}
ggplot(einkaufen, aes(x = alter)) +
  geom_histogram(binwidth = 5,
                 color = "black",
                 fill = "grey")
```

Später in diesem Tutorial wird es noch ein eigenes Kapitel zu Farben geben.

### `boundary`

Das sieht schon mal ein Stück weit besser aus. Jetzt ist noch etwas störend, dass die Kategorien nicht bei den markanten Zahlen anfangen, sondern z.B. die 50 in der Mitte einer Kategorie liegt. Dafür kannst du das Argument `boundary` nutzen, um einen Grenzwert zu bestimmen, der die Kategorien an diesem Punkt teilt (sog. "bin break"):

```{r boundary, exercise = TRUE, exercise.cap = "Boundary-Argument"}
ggplot(einkaufen, aes(x = alter)) +
  geom_histogram(binwidth = 5,
                 boundary = 50,
                 color = "black",
                 fill = "grey")
```

```{r hist-quest}
quiz(caption = "Quiz zu den Histogrammen",
     
question("Welche Daten lassen sich gut im Histogramm darstellen?",
               answer("Eine einzelne, kategoriale Variable.",
                      message = "Fast richtig. Nur dass die Variable stetig ist und nicht kategorial. 
                      Hier würde sich ein Balkendiagramm anbieten."),
               answer("Eine einzelne, stetige Variable.",
                      correct = T),
               answer("Zwei kategoriale Variablen.",
                      message = "Für diese Datenart eignet sich eine Kreuztabelle."),
               answer("Zwei stetige Variablen.",
                      message = "Fast richtig. Es geht um stetige Daten, aber eben nur um eine einzelne Variable. 
                      Für diese Datenart eignet sich ein Punktdiagramm."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = random_praise("de"),
               incorrect = random_encouragement("de")),

question("Warum ein Histogramm und kein Balkendiagramm?",
               answer("Weil die abgebildete Variable stetig und nicht diskret ist.",
                     correct = T),
               answer("Weil die abgebildete Variable diskret und nicht stetig ist.",
                      message = "Genau anders herum. 
                      Die abgebildete Variable ist stetig (hat keine natürlichen Kategorien) 
                      und muss deswegen in Intervallen abgebildet werden."),
               answer("Weil Statistiker*innen gerne möglichst viele Möglichkeiten haben, 
                      um es maximal kompliziert zu machen.",
                      message = "Es mag manchmal so anmuten aber eigentlich geht es ja darum, 
                      die Sachverhalten möglichst übersichtlich und korrekt abzubilden :)"),
               answer("Weil stetige Variablen keine natürlichen Kategorien bilden.",
                      correct = T),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question_radio("Warum verändert sich die Höhe zwischen den beiden ersten Histogrammen beim Alter um die 25 von 17 auf 25??",
               answer("Weil wir die Kategorien breiter gemacht haben und jetzt mehr Menschen in einer Kategorie zusammengefasst werden.",
                      correct = TRUE),
               answer("Weil das Alter entsprechend angepasst wurde.",
                      message = "Die 25 Beobachtungen haben nichts mit dem Alter 25 zu tun."),
               answer("Weil wir die Kategorien schmaler gemacht haben und somit mehr Menschen pro Kategorie zusammenkommen.",
                      message = "Genau anders herum: wenn die Kategorien breiter werden, werden mehr Menschen in einer Kategorie zusammengefasst."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = random_praise("de"),
               incorrect = random_encouragement("de")),
question_radio("Wie legst du die Farbe der Umrandung der Balken fest?",
               answer("Mit dem Argument `fill`.",
                      message = "`fill` bestimmt die Füllung der Balken."),
               answer("Mit dem Argument `colour`.", correct = TRUE),
               random_answer_order = TRUE,
               allow_retry = TRUE,
               correct = random_praise("de"),
               incorrect = random_encouragement("de")),

question_radio("Was stimmt zur Schreibweise des Arguments `colour`?",
               answer("`colour` kann auch `color` geschrieben werden.",
                      correct = TRUE),
               answer("R ist case sensitive, deswegen muss das Argument `colour` stehts mit ou geschrieben werden.",
                      message = "Das ist teilweise richtig. R ist case sensitive, was heißt, dass es Groß- und Kleinschreibung beachtet. `colour` kann allerdings in diesem Fall sowohl mit `ou` als auch nur mit `o` geschrieben werden."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = random_praise("de"),
               incorrect = random_encouragement("de")),

question_radio("Was stimmt bzgl. des Arguments `boundary`?",
               answer("Spezifiziert den Grenzpunkt zwischen zwei Kategorien",
                      correct = TRUE),
               answer("Spezifiziert die Grenzen des gesamten Plots.",
                      message = "Dafür gibt es andere Funktionen (z.B. `coord_cartesian()`)."),
               answer("Umrandet die bins in einer frei gewählten Farbe.",
                      message = "Das gesuchte Argument heißt `colour`."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = random_praise("de"),
               incorrect = random_encouragement("de")),

question_radio("Letzter Plot: Wie alt ist die älteste Person?",
               answer("Zwischen 85 und 90 Jahren.",
                      correct = TRUE),
               answer("89 Jahre, 11 Monate und 3 Tage.",
                      message = "Das könnte zwar sein, könnte aber auch nicht sein. Du kannst nur wissen, das diese Person sich im Intervall zwischen 85 und 90 Jahren befindet."),
               answer("100",
                      message = "Die höchste Kategorie hört bei 90 aus, also maximal 90 Jahre."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = random_praise("de"),
               incorrect = random_encouragement("de"))

)
```

## 3. Boxplot

::: infobox
Ein Boxplot ist eine effektive und robuste Methode, um die Verteilung **einer stetigen** Variable aufgeschlüsselt nach den Auprägungen **einer kategorialen** Variable zu visualisieren und Ausreißer zu identifizieren.

Funktion: `geom_boxplot()`
:::

<br>

Du erinnerst dich vielleicht daran im letzten Tutorial selbst bereits einen Boxplot gezeichnet zu haben. Hier noch einmal die Übersicht, welche Daten in einem Boxplot enthalten sind:

![](images/boxplot.png){width="90%"}

[image source](https://leansigmacorporation.com/box-plot-with-minitab/)

Boxplots werden eigentlich niemals einzeln gezeigt, sondern immer im Vergleich neben anderen Boxplots. Das heißt dann *side-by-side boxplot*. Das macht auch Sinn, denn für die Verteilung einer einzelnen stetigen Variablen haben wir ja bereits das Histogramm. Boxplots hingegen sind gut darin, mehrere Verteilungen übersichtlich zu vergleichen. Histogramme sind gut darin, eine einzelne Verteilung detailliert darzustellen.

*Side-by-side boxplots* entstehen, wenn zu der **stetigen** noch eine **kategoriale** Variable hinzukommt. Im Plot unten wird die stetige Variable `alter` nach der kategorialen Variable `verkehrsmittel` aufgeschlüsselt. Für jedes Verkehrsmittel ergibt sich nun eine eigene Altersverteilung. Da zeigen sich dann die ersten spannenden Zusammenhänge!

```{r sidebysideboxplot, exercise = TRUE, message=FALSE, warning=FALSE}
ggplot(einkaufen, aes(x = verkehrsmittel, y = alter)) +
  geom_boxplot()
```

<details>

<summary><a>**▼ \* Zusatz: Zusammenfassen von Kategorien**</a></summary>

Es wird auch deutlich, dass die Kategorien "E-Roller" und "Motorrad" so klein sind, dass sie sich nicht als eigene Analyse-Kategorie eignen, deswegen werden sie mit "Andere" zusammengefasst. Hierfür wird ein neuer Datensatz mit dem Namen `einkaufen_recoded` erstellt. Die NAs dürfen allerdings nicht einfach umgecodet werden, weil wir es in diesem Fall einfach wirklich nicht wissen.

::: rot
Das Zusammenfassen von Kategorien sollte vor der Datenerhebung geplant sein, damit nicht nachträglich Kategorien zusammengefasst werden und dadurch die Ergebnisse verändert werden können. Wenn es nachträglich geschieht, muss es auf jeden Fall gut begründet und **dokumentiert** werden, sonst ist das wissenschaftlicher Betrug!
:::

```{r bp_neuerdf, exercise = TRUE}
# Erstelle ein neues Objekt und speichere den bisherigen Datensatz darin
einkaufen_recoded <- einkaufen

# Verändere Variablen nach deinen Wünschen im NEUEN Objekt
# in diesem Fall mit der recode Funktion aus dem Paket dplyr
# die bisherige Variable wird einfach mit der neuen überschrieben
einkaufen_recoded$verkehrsmittel <- recode(einkaufen$verkehrsmittel,
      "E-Roller" = "Andere",
      "Motorrad" = "Andere"
)

# und nochmal der gleiche Plot
ggplot(einkaufen_recoded, aes(x = verkehrsmittel, y = alter)) +
  geom_boxplot()
```

</details>

```{r question_boxplot}
quiz(caption = "Interpretation üben",
     question("Welche Daten lassen sich gut im Boxplot darstellen?",
               answer("Eine einzelne, kategoriale Variable.",
                      message = "Fast richtig. Nur dass noch eine weitere, stetige Variable benötigt wird. Hier würde sich ein Balkendiagramm anbieten."),
               answer("Eine einzelne, stetige Variable.",
                      message = "An sich nicht falsch, aber Histogramme sind geeigneter in diesem Fall."),
               answer("Eine stetige Variable aufgeteilt nach den Kategorien einer kategorialen Variable",
                      correct = T),
               answer("Zwei stetige Variablen.",
                      message = "Fast richtig. Nur dass die zweite Variable kategorial ist und nicht stetig. 
                      Für diese Datenart eignet sich ein Punktdiagramm."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),
     
question("Wie ist das obere und untere Ende der Box bei den Autofahrenden zu interpretieren? Der untere Rand der Box liegt ungefähr bei 37, der obere bei ca. 60 Jahren.",
               answer("Diese Altersspanne umfasst die mittleren 50% der Autofahrenden",
                      correct = TRUE,
                      message = "Das entspricht der IQR (*interquartile range*), also dem Abstand zwischen drittem und erstem Quartil, oder anders gesagt zwischen dem 75%-Quantil und dem 25%-Quantil."),
               answer("Diese Altersspanne umfasst die mittleren 75% der Autofahrenden",
                      message = "Das obere Ende der Box kennzeichnet das 75%-Quantil oder auch drittes Quartil, das untere das 25%-Quantil oder auch 1. Quartil. Der Abstand zwischen 75 und 25 % beträgt 50%."),
               answer("Diese Altersspanne umfasst die mittleren 25% der Autofahrenden",
                      message = "Das obere Ende der Box kennzeichnet das 75%-Quantil oder auch drittes Quartil, das untere das 25%-Quantil oder auch 1. Quartil. Der Abstand zwischen 75 und 25 % beträgt 50%."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question_numeric("Wie lautet der Median des Alters aller Autofahrenden? (grob)",
                 answer(50, correct = TRUE),
                 tolerance = 2,
                 allow_retry = T,
                 incorrect = "Der Median ist der dicke Strich in der Mitte der Box."),

question_radio("Wie ist der Median zu interpretieren?",
               answer("Der Median ist das Alter, was die Autofahrenden in zwei gleich große Hälften teilt", correct = TRUE, 
                      message = "Wenn die Autofahrenden dem Alter nach aufgestellt würden, wäre der Median das Alter der Person in der Mitte der Aufstellung."),
               answer("Der Median ist das Alter, was am häufigsten vorkommt.", 
                      message = "Die häufigste Ausprägung nennt sich „Modus“ und wird üblicherweise für kategoriale Daten angegeben. Der Median ist etwas anderes: Wenn die Werte der Reihenfolge nach sortiert werden, ist der Median derjenige, der in der Mitte der Reihenfolge steht."),
               answer("Der Median darf hier nicht interpretiert werden, da das Alter stetig ist.", 
                      message = "Der Median darf zwar bereits für ordinale, diskrete Daten berechnet werden, aber das heißt nicht dass er für höhere Skalenniveaus verboten ist."),
               allow_retry = T,
               random_answer_order = T,
               incorrect = "Leider nicht richtig, probier es noch mal!"),
question_radio("Zeigt der Boxplot die Gruppengröße jedes Verkehrsmittels?",
               answer("Nein, es wird nur die Verteilung gezeigt, aber nicht auf wie vielen Datenpunkten diese Verteilung beruht!",
                      correct = TRUE,
                      message = "Das schauen wir uns im nächsten Abschnitt genauer an."),
               answer("Ja, die Größe der Box kennzeichnet auch die Anzahl an Personen.",
                      message = "Das ist leider falsch. Ganz im Gegenteil. Wenn die Box sehr klein ist, können das tausende von Personen sein, die einfach alle innerhalb einer sehr geringen Altersspanne liegen."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               incorrect = random_encouragement(language = "de"))
)
```

### \# Show your data!

Der obige Boxplot hat einen großen Nachteil: Es ist nicht zu sehen, wie viele Personen in jeder Gruppe sind. Dabei wissen wir eigentlich, dass die Gruppengröße der unterschiedlichen Verkehrsmittel unterschiedlich ist. Manchmal wird halt ein ganzer Boxplot gezeichnet, während lediglich 6 Personen dahinter stehen, und er ist nicht zu unterscheiden von einem für ein Verkehrsmittel, was 100 Menschen nutzen. 

Du kannst dem Plot die fehlenden Informationen in einer neuen Ebene hinzufügen!

Die Funktion `geom_jitter()` zeichnet genau wie `geom_point()` einzelne Datenpunkte, nur dass ein bisschen zufälliger *jitter* angewandt wird, um sie ein bisschen durcheinander zu schütteln, sodass nicht mehr alle Punkte übereinander liegen und Information verloren geht an der Stelle. 

- `size` kennzeichnet die Größe der Punkte
- `alpha` bestimmt die Transparenz der Punkte (von 0 - 1)
- `width` ist die Stärke des horizontalen zufälligen Jitters,
`height` wäre für den vertikalen Jitter


```{r showyourdata, exercise = TRUE, echo=TRUE}
ggplot(einkaufen, aes(x = verkehrsmittel, y = alter)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.2, 
              width = 0.1, 
              size = 3)
```

::: infobox
Hier siehst du, was ein Boxplot tatsächlich aussagt: Er zeigt wirklich nur die Quartile, Minimum und Maximum und den Median (das ist ja ein Quartil).
:::

<br>

Achte mal auf das Verkehrsmittel "Andere". Dort gibt es wirklich nur eine handvoll Punkte, aber die Box ist kaum von den anderen Verkehrsmitteln zu unterscheiden. Aber mithilfe der Punkte können wir nun sehen, dass dort weit weniger Datenpunkte vorliegen und wir daher bei der Interpretation dieser Gruppe Vorsicht walten lassen sollten, da sie von der Gruppengröße her nicht mit den anderen zu vergleichen ist, von Motorrad, E-Roller und NA ganz zu schweigen.

::: aufgabe
**Aufgabe**

Probiere es doch mal aus, und schaue welche anderen zwei Variablen aus dem Beispieldatensatz `einkaufen` du gut für einen Boxplot nutzen kannst.

Achte darauf, immer eine **metrische** mit einer **kategorialen** Variable zu kombinieren! Sonst gibt es komische Fehlermeldungen / komisch aussehende Plots.

Hier eine Auflistung der Variablennamen:

**Kategorial:**

-   `essen`: Das Lieblingsessen der Person. Nominal, 97 verschiedene Ausprägungen
-   `verkehrsmittel`: Das Verkehrsmittel, mit dem die Person zum Laden gefahren ist. Nominal, 7 Auprägungen
-   `frequenz`: Wie oft die Person in einen Bioladen geht. Ordinal, 5 Stufen
-   `ort`: Befragungsort. Nominal, 5 Ausprägungen
-   `bioladen`: Ob der Laden ein Bioladen war. Nominal, binär
-   `befragung`: Kürzel der Studierenden, die die Daten erhoben haben. Nominal, 8 Ausprägungen

**Metrisch:**

-   `weg`: Die Länge der Anreise zum Laden in km, Verhältnisskala
-   `alter`: Alter der Person, Verhältnisskala
-   `kochen`: Anzahl der Tage pro Woche, an denen selber gekocht wird, Absolutskala

**Andere:**

-   `id`, `datum`, `uhrzeit` sind Metadaten die wir gerade nicht brauchen.
:::

```{r boxplot, exercise = TRUE, exercise.cap = "Boxplot Exploration"}
ggplot(einkaufen, aes(x = , y =  )) +
  geom_boxplot()
```

::: infobox
**Tipp:** Wenn du die Beschriftungen einer kategorialen Variable auf der `x`-Achse nicht mehr lesen kannst, weil sie übereinandergedruckt werden: Pack die Variable einfach auf die `y`-Achse! Dann werden die Beschriftungen untereinander dargestellt und überlappen sich nicht.
:::

```{r boxplot-quest}
question_text("Welche Variablen hast du gefunden, die sich für einen Boxplot mit 2 Variablen eignen?",
              answer_fn(\(x) correct(messages = "Wie oben erwähnt, ist es am aussagekräftigsten eine metrische Variable und eine kategoriale Variable zu verwenden. Zum Beispiel Ort (kategorial) und Weg (kontinuierlich).")),
              placeholder = "Musterlösung erscheint bei Abgabe deiner Antwort...")
```

### Boxplot-Quiz

```{r boxquiz}
quiz(caption = "Quizfragen zum Boxplot",
     question_radio("Welche Information zeigt ein klassischer Boxplot **nicht**?",
                     answer("Die Gruppengröße", correct = TRUE),
                     answer("Den Median"),
                     answer("Minimum und Maximum"),
                     answer("Den Interquartilsabstand"),
                     answer("Extreme Werte"),
                     correct = random_praise("de"),
                     incorrect = random_encouragement("de"),
                     allow_retry = TRUE,
                     random_answer_order = TRUE),
     question_radio("Wofür ist ein Boxplot *besonders* gut geeignet?",
                    answer("Die Verteilung einer stetigen Variablen über die Ausprägungen einer kategorialen Variablen hinweg zu betrachten", correct = TRUE),
                    answer("Die Verteilung einer einzelnen kategorialen Variable darzustellen",
                           message = "Dafür eignen sich Balkendiagramme."),
                    answer("Die Verteilung einer einzelnen, stetigen Variable darstellen",
                           message = "Das geht zwar mit einem Boxplot, aber Histogramme sind eventuell informativer an dieser Stelle!"),
                    answer("Den Zusammenhang zweier stetiger Variablen grafisch darzustellen",
                           message = "Dafür sind Punktdiagramme gedacht."),
                    correct = random_praise("de"),
                    incorrect = random_encouragement("de"),
                    allow_retry = TRUE,
                    random_answer_order = TRUE),
     question_radio("Wofür steht die Länge der Box in einem Boxplot?",
                    answer("Für den Interquartilsabstand (IQR)", 
                           correct = TRUE,
                           message = "Die IQR *interquartile range* ist der Abstand zwischen erstem und drittem Quartil, und kennzeichnet die mittleren 50% der Datenreihe."),
                    answer("Für die Spannweite (range)",
                           message = "Spannweite wird durch Minimum und Maximum bestimmt."),
                    answer("Für die Gruppengröße (n)",
                           message = "Die Gruppengröße fließt nicht in einen Boxplot mit ein."),
                    correct = random_praise("de"),
                     incorrect = random_encouragement("de"),
                     allow_retry = TRUE,
                     random_answer_order = TRUE)
     
     )
```


## 4. Punktdiagramm

::: infobox
Punktdiagramme sind geeignet, um den Zusammenhang **zweier stetiger** Variablen zu zeigen.

Funktion: `geom_point()`
:::

<br>

Punktediagramme können dir auch unter den Namen: *Streudiagramm*, *Punktewolke* oder englisch *Scatterplot* begegnen.

```{r scatterplot, exercise = TRUE, exercise.cap = "Streudiagramm"}
ggplot(einkaufen, aes(x = alter, y = weg)) +
  geom_point()
```

Schau dir das Diagramm mal an. Einige Extremwerte der Variable `weg` definieren die Skala der y-Achse auf 0 - 600 km, wodurch die "normalen" Werte am unteren Rand zu einer undifferenzierbaren Masse zusammenschrumpfen. Im nächsten Kapitel erfährst du Möglichkeiten, mit extremen Werten umzugehen, und wie das Punktdiagramm ohne sie aussehen würde.

```{r scatterquiz}
question_checkbox("Verständnis-Check: Wie alt ist die Person, die 600km Anreiseweg hat?",
               answer("ca. 40 Jahre alt.",
                     correct = T),
               answer("Über 75 Jahre alt."),
               answer("Unter 25 Jahren."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!")
```

### "Lügen" mit log-transformierten Achsen

Bevor wir versuchen, die extremen Werte auszuschließen, hier noch ein alternativer Weg, die undifferenzierbare Masse am unteren Rand der Grafik besser darzustellen: Die y-Achse logarithmisch transformieren! Das geht in `ggplot` sehr einfach, du musst nur eine neue Ebene zum Plot hinzufügen mit der Funktion `scale_y_log10()`. 

Die logarithmische Transformation ist sehr praktisch, um extreme Werte mit auf der Bildschirmfläche unterzubringen, und gleichzeitig eine sinnvolle Skalierung der normalen Werte aufrecht zu erhalten. Das kann natürlich missbraucht werden,
deswegen sollte das immer deutlich gekennzeichnet werden!

```{r logtransform, exercise = TRUE, exercise.cap = "log-transformiertes Streudiagramm"}
ggplot(einkaufen, aes(x = alter, y = weg)) +
  geom_point() +
  scale_y_log10()
```

## Extreme Werte

In diesem Abschnitt hast du die Mögichkeit, einen Blick in die Praxis zu werfen: Der Umgang mit Ausreißerwerten. Es ist komplett freiwillig. Wenn du lieber mit dem rein grafischen weitermachen willst, springe zu Kapitel 5: Liniendiagramme.

Das ist ein klassischer Fall von Datenaufbereitung. Es wird **vor** den Analysen gemacht, s. Tutorial Data Wrangling.

Und genau deswegen ist es so cool, dass wir diesen echten Datensatz zur Verfügung haben: Du wirst mit Problemen konfrontiert, die dir auch in Praxis begegnen werden, aber eben nicht in simulierten Datensätzen.

Wie du in der Grafik siehst gibt es einzelne Werte, die doll von allen anderen abweichen. Das verzerrt nicht nur die Grafik sondern auch die Analyse. Das sind sog. Ausreißer. Es gibt, wie eigentlich immer in der Statistik, nicht den einen Weg, damit umzugehen. Was allerdings immer gilt, wenn Ausreißer auftreten: **Check your data!** Extreme Werte können unterschiedlichste Gründe haben. Und je nachdem woher sie kommen, können sie behandelt werden.

Das Anschauen der Daten geht sowohl numerisch als auch optisch.

::: aufgabe
Nutze eine der dir bekannten Möglichkeiten, dir die Spalte `weg` aus dem `einkaufen`-Datensatz numerisch und optisch anzuschauen.
:::

```{r ausreisser-solution}
summary(einkaufen$weg)

ggplot(einkaufen, aes(x = weg)) +
  geom_histogram()
```

```{r ausreisser, exercise = TRUE, exercise.cap = "Daten checken"}

```

Der Median liegt bei 3 km, das bedeutet: 50% der Personen haben einen Anfahrtsweg von höchstens 3 km. Das 3. Quantil ist bei 7 km: 75% der Personen haben einen Anfahrtsweg von höchstens 7km. Und das arithmetische Mittel liegt bei 12.76 km. Das deutet sehr stark auf Ausreißerwerte hin. Das Maximum liegt bei 600, was die Vermutung noch bestärkt. Auch optisch im Histogramm wird deutlich, dass fast alle Ausprägungen unter 100 km liegen.

### Ursachenanalyse

Dass die Ausreißer da sind kann, auch in diesem Fall, verschiedene Gründe haben:

1. Ein Laden, nämlich der Biomarkt Greger, liegt in der Nähe eines ICE-Bahnhofs. Die Ausreißer könnten also von Fernreisenden kommen. Wenn das stimmt, dann müssten die Ausreißerwerte in diesem Laden erhoben worden sein (`ort`).

Das lässt sich prüfen. (In diesem Unterkapitel wird nur nach Optik geprüft. In der freien Wildbahn wären statistische Analysen notwendig!)

```{r ausreisser2, exercise = TRUE,  exercise.cap = "Ursachenanalyse"}
ggplot(einkaufen, aes(x = weg, y = ort)) +
  geom_boxplot()
```

Die Vermutung wird durch die Daten nicht wirklich gestützt. Bei Greger in der Willi-Allee zeigt der Boxplot gerade mal einen Wert außerhalb von $Q3 + 1.5\cdot IQR$ (gekennzeichnet als Punkt). Manche Studierende haben leider nicht dokumentiert, an welchem Laden sie Daten gesammelt haben, deswegen gibt es `NA`s bei der Variable `ort`. `NA` heißt, es ist nicht klar, um welchen und wie viele Läden es sich handelt.

Es wurde miterhoben, wer welche Beobachtung aufgeschrieben hat (`befragung`), vielleicht gibt das Aufschluss. Sowohl numerisch, als auch optisch. `geom_count()` ist eine Möglichkeit, Kreuztabellen optisch darzustellen.

```{r ausreisser3, exercise = TRUE,  exercise.cap = "Verteilung checken"}
# numerisch
table(einkaufen$ort, einkaufen$befragung, useNA = "always")

# grafische Darstellung
ggplot(einkaufen, aes(x = befragung, y = ort)) +
  geom_count()
```

Sowohl in der Kreuztabelle als auch in der Grafik kannst du sehen, dass jede Person lediglich in 1 Laden erhoben hat. LE hat scheinbar bei einer Person vergessen, den Laden einzutragen. LM und DS haben beide keinen Laden eingetragen. Es könnte also ein Laden sein oder auch 2, das können wir aus den Daten nicht wissen.

Sidefact: Die erhebenden Personen sind btw. klassische Metadaten - also Daten über Daten. Sie scheinen erstmal relativ wenige aussagekräftig. Das ist natürlich quatsch, Metadaten sind richtig mächtig. Hier ist ein sehr unterhaltsames [Beispiel](https://www.youtube.com/watch?v=-YpwsdRKt8Q).

### Ausschluss

Jetzt ist ein wenig mehr Orientierung bzgl. der Ausreißer da. Die Entscheidung, wie damit umgegangen wird ist nach wie vor offen. Spätestens jetzt ist es sehr wichtig, sich nochmal die Eingangsfrage der eigenen Forschung zu stellen: Was wollte ich eigentlich untersuchen? In diesem Fall ging es um die Frage, ob es einen Zusammenhang zwischen Einkaufsweg und Alter gibt. Wenn da Fernreisende mit drin sind, bieten diese logischerweise keine interessante Info für die Frage. Eine Möglichkeit wäre, den Laden am Bahnhof kategorisch auszuschließen. Allerdings ist unklar, ob in den NA Werten nur dieser Laden hinter steckt, deswegen müssten wir alle NAs rausschmeißen, was zum Verlust von 42 Beobachtungen führen würde. Das ist absurd viel. Außerdem kann davon ausgegangen werden, dass Menschen auch ihre Alltagseinkäufe dort machen, die wären dadurch kategorisch auch ausgeschlossen. Die nächste Möglichkeit wäre, eine feste Grenze zu setzen. Klassischerweise könnte diese aus der bestehenden Literatur bezogen werden. Also wenn es zB ein Paper geben würde, dass sagen würde: klassische Einkäufe finden in einem Umkreis von 10km statt, könnten alle Werte über 10km ausgeschlossen werden. Das wären schon deutlich weniger. Eine andere Möglichkeit ist die statistische: entweder die Werte außerhalb des Intervalls $[Q_1 - 1.5 \cdot IQR; Q_3 + 1.5 \cdot IQR]$ oder die Werte außerhalb des Intervalls $[\mu \pm 3 \cdot \sigma]$. Wenn die Daten normalverteilt sind (wie angenommen wird für die allermeisten statistischen Analysen, wenn nicht, haben wir noch ganz andere Probleme!), liegen in diesem Bereich 99.8% aller Werte. Es gibt keine Funktion in R, die automatisiert entsprechende Werte rausschmeißt. Das liegt daran, dass die Entscheidung so situationsabhängig ist und es einfach wichtig ist, sich jedes Mal wieder Gedanken zu machen, wie du damit umgehen möchtest. Hier sind beide Möglichkeiten:

```{r ausreisser4, exercise = TRUE,  exercise.cap = "Verschiedene Definitionen"}
quantile(einkaufen$weg, .75, na.rm = T) + (1.5 * IQR(einkaufen$weg, na.rm = T))

mean(einkaufen$weg, na.rm = T) + (3 * sd(einkaufen$weg, na.rm = T))
```

Es wird sehr deutlich, dass die Quantilversion die robustere ist. 15 km Anfahrtsweg für Alltagseinkäufe scheinen deutlich logischer als 172. In diesem Fall wäre also eine Möglichkeit, alle Werte überhalb von 15km auszuschließen. Das geht dann so:

```{r ausreisser5, exercise = TRUE, exercise.setup = "bp_neuerdf",  exercise.cap = "Ausreißer raus"}
# Maximalwert festlegen
maximalwert <- quantile(einkaufen$weg, .75, na.rm = T) + (1.5 * IQR(einkaufen$weg, na.rm = T))

# Ein Subset aus dem aktuellen Datensatz treffen und in dem schon oben neu angelegten Objekt speichern
einkaufen_recoded <- einkaufen_recoded[einkaufen_recoded$weg < maximalwert, ]

# und NAs entfernen
einkaufen_recoded <- einkaufen_recoded[!is.na(einkaufen_recoded$weg), ]
```

::: rot
#### Dokumentation

**Ganz wichtig!**: Wenn du Daten ausschließt **musst** du das, inklusive der Argumentation warum, gut dokumentieren. Sonst ist das wissenschaftlicher Betrug!

Im Normalfall sollte bereits vor der Datenerhebung festgelegt werden, nach welchen Kriterien Daten ausgeschlossen werden müssen - damit die Versuchsleiter nicht nachträglich die Möglichkeit haben, das Ergebnis in eine bestimmte Richtung zu lenken.
:::

Und jetzt nochmal der Plot ganz vom Anfang:

```{r sp_dokumentation, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "Scatterplot ohne Ausreißer"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg)) +
  geom_point()
```

Das sieht doch deutlich stimmiger aus.

```{r scatter-quest}
quiz(caption = "Quiz zum Punktediagramm",
     
question("Welche Daten lassen sich gut in einem Punktediagramm darstellen?",
               answer("Eine einzelne, kategoriale Variable.",
                      message = "Fast richtig. 
                      Nur dass die Variable stetig ist und nicht kategorial. 
                      Hier würde sich ein Balkendiagramm anbieten."),
               answer("Eine einzelne, stetig Variable.",
                      message = "Dafür eignet sich ein Histogramm."),
               answer("Zwei kategoriale Variablen.",
                      message = "Für diese Datenart 
                      eignet sich eine Kreuztabelle."),
               answer("Zwei stetige Variablen.",
                      correct = TRUE),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("Was ist zu tun bei extremen Werten?",
               answer("Alle Entscheidungen kleinstschrittig dokumentieren.",
                      correct = TRUE),
               answer("Willkürlich einen Wert festlegen, 
                      über- oder unterhalb dessen einfach alle Daten rausgeworfen
                      werden.",
                      message = "Das geht gar nicht. 
                      Es muss alles begründet sein!"),
               answer("Sich die Zusammenhänge anschauen und Ideen sammeln, 
                      womit die extremen Werte zu tun haben könnten.",
                      correct = T),
               answer("Ignorieren.",
                      message = "Auch quatsch. 
                      Wenn du dich entschließt, sie drin zu behalten, 
                      dann sollte auch das gut argumentiert sein."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("Was sind zwei übliche Daumenregeln für die Definition von Ausreißern??",
               answer("Mittelwert plus/minus 3 Standardabweichungen",
                      correct = TRUE),
               answer("Q1 - 1.5 * IQR bzw. Q3 + 1.5 * IQR",
                      correct = T),
               answer("Mittelwert plus/minus 1.96 Standardabweichungen",
                      message = "Mittelwert plus/minus 1.96 Standardabweichungen 
                      umschließen bei der Standardnormalverteilung genau 95% der 
                      Fläche, sind also sehr relevant zur Errechnung des p Wertes.
                      Für die extremen Werte ist dieses Intervall jedoch
                      irrelevant."),
               answer("Mittelwert plus/minus 1.5 * IQR",
                      message = "Da hast du zwei, zugegeben sehr ähnliche, Maßen
                      durcheinander bekommen. 
                      Lies dir den Abschnitt nochmal zur Erinnerung durch :)"),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!")
)
```

## 5. Liniendiagramm

::: infobox
Liniendiagramme sind geeignet, um Verläufe und Entwicklungen darzustellen. Dafür braucht es **zwei Variablen**: eine **stetige** Variable, und eine andere mit einer **sequentiellen Abfolge** (wie z.B. die Zeit).

Die sequentielle Variable kommt dabei immer auf die `x`-Achse.

Funktion: `geom_line()`
:::

<br>

Hierfür wird ein anderer Datensatz benötigt, da wir für ein Liniendiagramm eine wiederholte Messung brauchen. `einkaufen` enthält 160 unabhängige Messungen, keine der Personen wurde ein zweites Mal befragt. Deswegen ist `einkaufen` nicht geeignet um einen Verlauf über die Zeit darzustellen.

<!-- Maybe use the `economics` data set from ggplot2 here -->

```{r include = FALSE}
ggplot(economics, aes(date, unemploy)) +
  geom_line()
```

Im Datensatz `rtutorials::heated` ist die maximale Tagestemperatur (`maxtemp`) in Grad Fahrenheit sowie das Tagesdatum (`enddate`) gespeichert. Es handelt sich um wiederholte Messungen, weil der gleiche Gegenstand (die Temperatur in New York) immer wieder (täglich) erhoben wurde.

```{r linegraph, exercise = TRUE, exercise.cap = "Liniendiagramm"}
ggplot(heated, aes(x = enddate, y = maxtemp)) +
  geom_line()
```

Zwischen den Jahren sind komische, gerade Linien. Das liegt daran, dass nur die Monate Mai bis September im Datensatz vorhanden sind. Dieses geometrische Objekt `geom_line()` (Liniendiagramm) verbindet alle Punkte, die ihm zur Verfügung gestellt werden miteinander. Wenn dann länger keine Daten da sind, wird der Verbindungsstrich einfach zum nächsten vorhandenen Datenpunkt gezogen. Das Problem ist, dass dieser Verbindungsstrich den Anschein erweckt, als gäbe es Daten, die eben in echt gar nicht gibt. Um damit gut umzugehen braucht es in den `aes`thetics das `group` Argument. Das sagt dem geometrischen Objekt in welchen Gruppen es die Daten behandeln soll. In diesem Fall wäre eine Gruppe für jedes Jahr sinnvoll.\
Der Umgang mit Datumsformaten in R würde hier komplett den Rahmen sprengen, aber die Lösung ist:\
Mit der Funktion `year()` aus dem Paket `lubridate()` ziehst du *nur* das Jahr aus dem Datum und erschaffst somit eine Gruppe pro Jahr.

```{r linegraph2, exercise = TRUE,  exercise.cap = "Daten Gruppieren!"}
ggplot(heated, aes(x = enddate, 
                   y = maxtemp, 
                   group = lubridate::year(enddate))) +
  geom_line()
```

Sehr gut, jetzt werden keine Zusammenhänge mehr angedeutet, wo gar keine sind. Und weils noch schöner ist, wenn die lesende Person intuitiv die Zahlen deuten kann wird im letzten Schritt die Grad Fahrenheit Skala in eine Grad Celsius Skala umgerechnet. Dies geht mit der Funktion `convert_temperature()` aus dem Paket `weathermetrics`.

```{r linegraph3, exercise = TRUE,  exercise.cap = "Sauberes Liniendiagramm"}

# hier werden die Temperaturen konvertiert und in einer neuen Spalte gespeichert
heated$maxtemp_celsius <- weathermetrics::convert_temperature(heated$maxtemp,
                                                              old_metric = "f", 
                                                              new_metric = "c")

ggplot(heated, aes(x = enddate, 
                   y = maxtemp_celsius, 
                   group = lubridate::year(enddate))) +
  geom_line()
```

Für schöne Achsenbeschriftungen siehe das Kapitel „Themes und Labs“.

```{r line-quest}
quiz(caption = "Quiz zum Liniendiagramm",
     
question("Welche Daten lassen sich gut in einem Liniendiagramm darstellen?",
               answer("Eine einzelne, stetig Variable.",
                      message = "Das ist schon ein guter Anfang.Es fehlt noch eine weitere, sequentielle Variable. Für diese Datenart eignet sich ein Histogramm."),
               answer("Zwei kategoriale Variablen.",
                      message = "Für diese Datenart 
                      eignet sich eine Kreuztabelle."),
               answer("Zwei stetige Variablen.",
                      message = "Fast richtig. 
                      Es geht um zwei stetige Variablen, 
                      aber für ein Liniendiagramm ist es essentiell, 
                      dass eine von ihnen sequentiell ist. 
                      Für diese Datenart eignet sich ein Punktdiagramm."),
                answer("Eine stetige und eine sequentielle Varible.",
                      correct = T),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("Plot 1: Was ist richtig?",
               answer("Es werden sechs Jahre abgebildet.",
                     correct = T),
               answer("Es existieren Daten für jeden einzelnen Tag in der
                      angegebenen Zeit.",
                      message = "Die Wintermonate fehlen"),
               answer("Die fehlenden Werte werden einfach mit einem Strich
                      überbrückt.",
                      correct = T),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("Letzte Grafik: Was stimmt?",
              answer("Es werden sechs Jahre abgebildet.",
                     correct = T),
               answer("Die Wintermonate wurden einfach rausgelöscht.",
                      message = "Die Wintermonate waren nie vorhanden!"),
               answer("Das Argument `group` ist essentiell, damit R weiß, 
                      welche Werte wie zusammengehören.",
                      correct = T),
               answer("`lubridate` ist ein super Paket, 
                      um mit Daten und Zeitangaben umzugehen",
                      correct = T),
               answer("`weathermetrics` ist ein super Paket, 
                      um mit Wetterdaten zu rechnen.",
                      correct = T),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!")
)
```

## 6. Aesthetic Mapping

Jetzt kennst du die 5 häufigsten Diagrammformen. Jetzt kommt Farbe ins Spiel. Wie im ersten Kapitel bereits besprochen ist: Die ästhetischen Attribute eines Plots werden festgelegt. Bisher haben wir lediglich die Zuweisung zur x und ggf. y Achse genutzt, da geht allerdings noch viel mehr. Als Erinnerung:

::: infobox
`aes()` steht für *aesthetic attributes*, und weist den einzelnen Variablen, wie z.B. dem Verkehrsmittel, eine *grafische Eigenschaft* zu. Grafische Eigenschaften sind:

-   Achsen (`x`, `y`)
-   Farbe (`colour`)
-   Füllung (`fill`)
-   Form (`shape`)
-   Größe (`size`)
-   Transparenz (`alpha`)
:::

Also: jeder Variable wird ein ästethisches Attribut zugeordnet. Bedeutet umgekehrt: Es lassen sich bis zu 6 verschiedenen Variablen in einem Plot unterbringen. Wie sinnvoll es ist, das auszureizen, sei dahingestellt.

### Füllung und Farbe

#### Fill

Was allerdings in vielen Fällen sinnvoll ist, ist eine weitere Variable über das Attribut Füllung (`fill`) zu plotten. Das gilt sowohl für *kategoriale* als auch *metrische* Daten.

```{r aestheticmapping, exercise = TRUE,  exercise.cap = "fill"}
ggplot(einkaufen, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar()
```

Dazu kommt nun, dass unterschieden werden kann zwischen Bio- und Nicht-Bioläden. Aber **Achtung**: Es ist kein ausgewogenes Design, es wurde in deutlich mehr Bio- als Nicht-Bioläden erhoben. Das kann in der statistischen Analyse später noch besondere Beachtung benötigen. Doch zu dem Plot: Scheint erstmal recht einleuchtend. Was jedoch noch besser wäre, um es vergleichbarer zu machen, wäre wenn die farbigen Balken *nebeneinander* und nicht aufeinander stünden. Das lässt sich mit dem Argument `position = "dodge"` erreichen:

```{r am_fuellung, exercise = TRUE,  exercise.cap = "position dodge"}
ggplot(einkaufen, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar(position = "dodge")
```

Jetzt ist nur noch bisschen hässlich, dass die Balken unterschiedlich breit sind, je nachdem, ob eine oder beide Faktorstufen vorkommen. Das lässt sich mit dem Argument `position = position_dodge(preserve = "single")` umgestalten:

```{r am_f_fill, exercise = TRUE,  exercise.cap = "postion dodge in single"}
ggplot(einkaufen, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar(position = position_dodge(preserve = "single"))
```

#### Colour

Farbe (`colour`) ist ein bisschen tricky: Bei Balkendiagrammen, Histogrammen und Boxplots wird damit die Umrandung der Balken beeinflusst. Hier braucht es noch das Attribut `Füllung`.

```{r am_f_colour, exercise = TRUE,  exercise.cap = "colour"}
ggplot(einkaufen, aes(x = verkehrsmittel, colour = bioladen)) +
  geom_bar()
```

Bei Punktdiagrammen und Liniendiagrammen wird die Punkt- bzw. Linienfarbe durch `colour` bestimmt. Wird das Attribut Füllung vergeben passiert einfach nichts.

```{r am_f_colour_2, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "colour im Scatterplot"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg, colour = bioladen)) +
  geom_point()
```

Eine Ausnahme gibt es: Die Formen 21, 22, 23, 24, 25 in einem Punktediagramm haben sowohl ein Farben als auch ein Füllungsattribut. Doch dazu später mehr.

#### kontinuierlich

Das fill bzw colour Attribut kann genauso gut auf kontinuierliche Variablen angewendet werden:

```{r am_f_c_kontinuierlich, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "continuous colour"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg, colour = kochen)) +
  geom_point()
```

### Shape

Die Form eignet sich, um in Punktediagrammen eine weitere kategoriale Variable einzubauen.

```{r am_shape, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "shape"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg, shape = verkehrsmittel)) +
  geom_point()
```

Insbesondere wenn es kombiniert wird mit `colour` wird es besonders eindeutig

```{r am_shape_2, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "shape & colour"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg, shape = verkehrsmittel, colour = verkehrsmittel)) +
  geom_point()
```

### Size

Auch Mittels Größe kann eine weitere Dimension rein gebracht werden. Das ist allerdings mit vorsicht zu genießen, da es in vielen Fällen die Wahrnehmung zu bestimmten Zusammenhängen verzerrt:

```{r am_size, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "size"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg, size = bioladen)) +
  geom_point()
```

Bei diesem Beispiel wird deutlich: Dieses Attribunt ist ungünstig verteilt. es macht den Plot viel unübersichtlicher im Vergleich zu der Info, die die lesende Person daraus ziehen kann. colour aus dem vorherigen Abschnitt war die deutlich bessere Wahl.

Im Grunde gibt es nur 3 Gründe, `size` als ästhetisches Attribut zu nutzen:

1.  Bei diskreten Daten, wo die Punkte sonst so sehr übereinander liegen würden, dass die Grafik total Gegenstandslos wäre. (Hierfür wurde allerdings das `geom_count()` entwickelnt)
2.  In Momenten, in denen mit der Größe wirklich eine Relation ausgedrückt werden kann (bspw. Gewicht, Quadratmeter oder Bruttoinlandsprodukt)
3.  In Korrelationstabellen.

### Alpha

Zu guter letzt folgt die Dichte. Die ist grundsätzlich auch eher ungeeignet. Der Vollständigkeit halber, lernst du sie hier trotzdem kennen:

```{r am_alpha, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "alpha"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg, alpha = kochen)) +
  geom_point()
```

Hier gilt das gleiche wie bei size: die unterschiedlichen alpha Werte nehmen eine Gewichtung vor, die die Wahrnehmung von Daten verzerren kann.

### Ästhetische Attribute ohne Mapping

Jetzt kennst du die Möglichkeiten, ästhetische Attribute Variablen zuzuweisen, um noch mehr Information abzubilden. Was du bisher noch nicht gelernt hast ist, diese ästhetischen Attribute auch ohne Mapping (also ohne sie einer Variable, also noch mehr Informationen, zuzuweisen) zu nutzen. Einfach, weil es gut aussieht und Grafiken übersichtlicher und lesbarer macht. Einige Beispiele wurden dir im bisherigen Tutorial schon untergemogelt. Hier sollen sie nochmal den gebührenden Platz finden.

::: aufgabe
Schaue dir den folgenden Codeabschnitt an, führe den Code aus und finde den Unterschied zwischen den verschiedenen Plots
:::

```{r am_aesthetische, exercise = TRUE,  exercise.cap = "aes ohne mapping"}
ggplot(einkaufen, aes(x = alter, colour = bioladen)) +
  geom_histogram(binwidth = 5, boundary = 50, fill = "grey", position = "identity", alpha = .5)

ggplot(einkaufen, aes(x = alter, fill = bioladen)) +
  geom_histogram(binwidth = 5, boundary = 50, colour = "black", position = "identity", alpha = .5)
```

Richtig erkannt: sobald ein ästhetisches Attribut in der Funktion `aes()` steht, wird ihr eine Variable zugeordnet, sie bringt neue Information mit in den Plot. Das erkennst du auch daran, dass per default eine Legende erstellt wird. Steht eine Attribut einfach in einer geom-Funktion wird der Inhalt auf *alle* Informationen im Plot angewendet, ihr wird ein einzelner Wert zugeordnet und es wird keine Legende erstellt.

Dieses Prinzip gilt für alle oben vorgestellten ästhetischen Attribute. Deiner Phantasie sind keine Grenzen gesetzt. Bevor du jetzt anfängst, wild mit Farben um die zu schmeißen wäre es allerdings wichtig, dass du das Unterkapitel Barrierefreiheit liest - da ist eine wunderschöne Palette vorgestellt, die so richtig Spaß macht :)

```{r aes-quest}
quiz(caption = "Quiz zum aesthetic mapping",
     
question("Welche der folgenden Attribute können als ästhetische Attribute genutzt
         werden?",
         answer("x Achse",
                 correct = T),
         answer("y Achse",
                 correct = T),
        answer("colour",
                 correct = T),
        answer("fill",
                 correct = T),
         answer("shape",
                 correct = T),
         answer("size",
                 correct = T),
         answer("alpha",
                 correct = T),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("Füllung und Farbe, was stimmt??",
               answer("fill geht grundsätzlich nur für kategoriale Daten.",
                     message = "Gerade in Heatmaps funktioniert fill für stetige
                     Daten ganz wunderbar."),
               answer("colour bestimmt immer die Farbe der geometrischen Objekte.",
                      message = "Jain. 
                      Bei Balkendiagrammen und Histogrammen wird mit colour die
                      Umrandungsfarbe der Balken bzw. Intervalle festgelegt."),
               answer("colour kann als ästhetisches Atrribut eine weitere Variable
                      abbilden.",
                      correct = T),
                answer("fill kann als ästhetisches Atrribut eine weitere Variable
                      abbilden.",
                      correct = T),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("Shape: Was stimmt?",
              answer("shape kann als ästhetisches Atrribut eine weitere Variable
                      abbilden.",
                      correct = T),
              answer("Shape ist vor allem für Punktdiagramme ein relevantes
                     Attribut.",
                     correct = T),
               answer("Mit shape ist es möglich, 
                      der Punktewolke eine Form nach eigener Wahl zu geben.",
                      message = "Das ist mit keiner einzigen Funktion möglich. 
                      Das wäre nämlich basically wissenschaftlicher Betrug. 
                      Shape gibt den einzelnen Punkten eine Form der eigenen
                      Wahl."),
               answer("Shape kann stetige Variablen abbilden.",
                      message = "Das ist Quatsch. 
                      Einzelne Formen bilden aus sich heraus natürliche Kategorien,
                      deswegen können sie auch nur für Variablen verwendet werden,
                      die das auch tun (= kategoriale)"),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("size: Was stimmt?",
              answer("size kann als ästhetisches Atrribut eine weitere Variable
                      abbilden.",
                      correct = T),
              answer("size ist vor allem für Punktdiagramme ein relevantes
                     Attribut.",
                     correct = T),
               answer("size ist das Mittel der Wahl, 
                      um eine weitere Variable in den Plot einzubinden.",
                      message = "Auf gar keinen Fall. 
                      Mittel der Wahl sind fill und colour. 
                      Nur in dezidierten Fällen ist size eine geeignete Wahl."),
               answer("size bestimmt die Größe des gesamten Plots.",
                      message = "size bestimmt die Größe der Punkte IM Plot."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("alpha: Was stimmt?",
              answer("alpha kann als ästhetisches Atrribut eine weitere Variable
                      abbilden.",
                      correct = T),
              answer("alpha ist vor allem für Punktdiagramme ein relevantes
                     Attribut.",
                     correct = T),
               answer("alpha ist das Mittel der Wahl, 
                      um eine weitere Variable in den Plot einzubinden.",
                      message = "Auf gar keinen Fall. 
                      Mittel der Wahl sind fill und colour. 
                      Nur in dezidierten Fällen ist alpha eine geeignete Wahl."),
               answer("alpha bestimmt das Maß der Durchsichtigkeit des
                      Hintergrundes des gesamten Plots.",
                      message = "alpha bestimmt die Durchsichtigkeit der Punkte IM
                      Plot."),
                answer("alpha lohnt sich besonders als ästhetisches Attribut ohne mapping.",
                      correct = T),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),

question("aesthetic mapping: Was stimmt?",
              answer("Ästhetische Attribute können auch ohne mapping genutzt
                     werden.",
                      correct = T),
              answer("Wenn ästhetische Attribute ohne mapping angewendet werden,
                     geht es wirklich um rein ästhetische Aspekte, nicht darum,
                     noch eine weitere Variable (also mehr Information)
                     einzufügen.",
                     correct = T),
               answer("Farben werden auf englisch und in Anführungszeichen
                      geschrieben.",
                      correct = T),
               answer("Ästhetische Attribute, die nicht gemapped werden sollen kommen ebenfalls in die aes() Funktion.",
                      message = "Da kommen genau nur die Attribute rein, 
                      die gemapped werden sollen."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!")
)
```

## 7. Special: Facets

::: infobox
Facets sind geeignet, um die Daten anhand von ein oder zwei Variablen aufzuteilen und mehr Information bei relativ guter Übersichtlichkeit in die Darstellung zu bekommen.

Funktion: `facet_grid()` und `facet_wrap()`.
:::

<br>

### `facet_grid()`

Für eine oder zwei Variablen. Wie auch bei anderen Indizierungen in R gilt: bei der 1. Stelle werden die Zeilen benannt, in der 2. die Spalten. In diesem Fall werden sie durch eine Tilde (`~`) verbunden. Wenn du nur eines von beiden willst kannst du einfach die Stelle vor bzw. nach der Tilde leer lassen.

In diesem Fall wird der veränderte Datensatz verwendet. Alle Veränderungen wurden im Laufe des bisherigen Tutorials argumentiert und dokumentiert.

::: aufgabe
Führe den Code aus und mache dich mit dem Ergebnis vertraut. Lösche jeweils einmal die Variable vor sowie nach der Tilde heraus und schaue, wie sich das Ergebnis verändert.
:::

```{r special, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "facet_grid()"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg)) +
  geom_point() +
  facet_grid(bioladen ~ verkehrsmittel)
```

Beachte: Hier wird (erneut) deutlich, welche Auswirkungen ein unbalanciertes Design hat. Da es sehr viel weniger Beobachtungen aus nicht Bioläden gibt, können die Zusammenhänge im Zweifel nicht wirklich dargestellt werden.

### `facet_wrap()`

Für den Fall, dass die Facetten nur anhand einer Variable aufmachen möchtest, du aber flexibler in der Form bleiben möchtest. Du kannst die Zeilen- **oder** die Spaltenanzahl bestimmen durch die Argumente `ncol` bzw. `nrow`.

::: aufgabe
Führe den Code aus, mach dich mit den Auswirkungen von `nrow` vertraut und setze anstatt dessen `ncol` ein.
:::

```{r s_facet, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "facet_wrap()"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg)) +
  geom_point() +
  facet_wrap(~verkehrsmittel, nrow = 3)
```

```{r facets-quest}
quiz(caption = "Quiz zu den facets",
     
question("Facetten: Was stimmt?",
         answer("Facetten ermöglichen es auf eine sehr übersichtliche Weise noch weitere Variablen (Informationen) mit in die Grafik zu bringen.",
                 correct = T),
         answer("facet_grid() ist besonders für 2 Variablen im Stile einer
                Kreuztabelle geeignet.",
                 correct = T),
        answer("facet_wrap() ist besonders für eine Varibale in einer selbst
               gewählten Anordnung geeignet.",
                 correct = T),
        answer("Die Tilde (~) verbindet die beiden Variablen, 
               die abgebildet werden sollen",
                 correct = T),
         answer("Facetten sind wie verschiedene Fenster im Browser, 
                zwischen denen man hin und her wechseln kann.",
                 message = "Sie ermöglichen alle Infos auf einen Blick zu bekommen."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!")
)
```

## 8. Das Drumherum: Themes, Labs und Legenden

Was noch fehlt um die Grafiken ganz grundlegend ein bisschen schöner zu machen ist die grundsätzliche Gestaltung der Plots sowie die grundsätzlichen Beschriftungen.

### Themes

Es gibt verschiedene Themes, welche Hintergrundfarbe, Umrandungen etc. bestimmen. Eine Übersicht findest du [hier](https://ggplot2.tidyverse.org/reference/ggtheme.html). Themes werden als eine weitere Lage dem Plot hinzugefügt.

::: aufgabe
Suche dir ein Theme deiner Wahl aus und füge es dem untenstehenden Plot hinzu
:::

```{r drumherum-solution}
# Ein Beispiel:
ggplot(einkaufen_recoded, aes(x = alter, y = weg)) +
  geom_point() +
  theme_bw()
```

```{r drumherum, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "themes"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg)) +
  geom_point()
```

### Labs

Die Beschriftungen sind ebenfalls eine weitere Lage und werden mittels `labs()` Funktion hinzu gefügt.

::: aufgabe
Ändere die Beschriftungen so, dass sie informativ sind.
:::

```{r d_labs, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "labs"}
ggplot(einkaufen_recoded, aes(x = alter, y = weg)) +
  geom_point() +
  labs(
    title = "Titel",
    subtitle = "Untertitel",
    x = "x-Achse",
    y = "y-Achse",
    caption = "Fußnote"
  )
```

### Legends

[ ](images/legends.webp){width="50%"}

[source](https://www.reddit.com/media?url=https%3A%2F%2Fpreview.redd.it%2Fgbjhlcz41i871.jpg%3Fauto%3Dwebp%26s%3D7a940a1c20340cefabf513e1a5987359542a3b72)

Die Legende sind eine Sache für sich. Es wird hier nur angeschnitten, solltest du damit arbeiten wollen, wirst du eh auf den bekannten Seiten (su.) nachschauen. Obacht: Das ist ein klassischer Fall, in dem ChatGPT häufig mehr Verwirrung als Klarheit reinbringt. Im Folgenden sind die ganz grundlegenden Mechanismen erklärt. Wenn du die verstanden hast sollte die Nutzung von ChatGPT tatsächlich einigermaßen flüssig funktionieren (wenn du es dann überhaupt noch nutzen möchtest und nicht viel lieber in der deutlich besser strukturierten [R Graph Gallery](https://r-graph-gallery.com/239-custom-layout-legend-ggplot2.html), der [Hilfeseite](https://ggplot2.tidyverse.org/reference/guide_legend.html) oder dem [Cookbook](http://www.cookbook-r.com/Graphs/Legends_(ggplot2)/) nachschauen willst ;)).

Es gibt sehr viele Wege, sie zu verändern und anzupassen und je nach Ausgangslage und Ergebnisvorstellung haben viele ihr Für und Wider. Eine dicke Empfehlung ist, es konsistent innerhalb von einem Plot zu machen (und spätestens hier verliert ChatGPT!).

Im Grunde gibt es zwei Möglichkeiten, etwas an der Legende zu ändern:

1.  Im Vektor an sich (also vorher)
2.  In der Legende (also im ggplot an sich)

**Zu 1**: Bietet sich an, wenn es die Daten dadurch noch übersichtlicher macht bzw. nichts an Übersichtlichkeit verloren geht. Im Beispiel der Variablen `bioladen`: aktuell noch logical würde sie durchaus übersichtlicher werden, wenn Einträge "bio" und "konventionell" wären. Hier begegnen wir unserem alten Bekannten, dem `factor`, wieder. Es wird eine neue Variable mit dem Namen "ladenart" erstellt. Es wäre allerdings auch denkbar, die alte zu überschreiben. - **Pro:** Geringere Gefahr, dass sich Fehler aufgrund von falscher Beschriftung einschleichen. - **Con:** Eher seltener der Fall, da das Datawrangling (s. entsprechendes Tutorial) ja eigentlich schon vorher abgeschlossen sein sollte und die Daten eigentlich in sehr hoher Qualität vorliegen sollten.

```{r d_legends, exercise = TRUE, exercise.setup = "ausreisser5",  exercise.cap = "legends"}
# Factor erstellen (ei Fragen dazu: Wiederhole gerne das Tutorial Vektoren)
einkaufen_recoded$ladenart <- factor(einkaufen_recoded$bioladen, 
                                  levels = c(TRUE, FALSE), 
                                  labels = c("bio", "konven."))

ggplot(einkaufen_recoded, aes(x = verkehrsmittel, fill = ladenart)) +
  geom_bar(position = position_dodge(preserve = "single")) +
  labs(
    title = "Verkehrsmittel und Ladenart",
    y = "Absolute Anzahl der Nutzenden",
    x = "Verkehrsmittel"
  )+
  theme_bw()
```

**Zu 2:** Ist in den allermeisten Fällen das Mittel der Wahl. Die beiden Hauptpunkte sind: Punkte und Titel der Legende verändern. Alles andere (Schriftart und -größe, Position, Ausrichtung, Hintergrund, Umrandung etc. kannst du in den oben vorgeschlagenen Seiten nachschauen). Es folgt eigentlich immer dem gleichen Prinzip: Du fügst deinem ggplot eine weitere Ebene hinzu und innerhalb dieser Ebene legst du Dinge fest. Welche Funktion bzw. Argumente du wählst hängt von deinen Variablen und ästhetischen Attributen ab: diskret oder kontinuierlich? Fill oder Colour? Daraus ergibt sich folgende Kreuztabelle

|                    | `colour`                             | `fill`                            |
|------------------|-----------------------------|--------------------------|
| **diskret**        | `scale_colour_viridis(discrete = T)` | `scale_fill_virdis(discrete = T)` |
| **kontinuierlich** | `scale_colour_virdis()`              | `scale_fill_viridis()` \*         |

\* Steht nur der Vollständigkeit halber hier, ist keinem der vorgestellten geoms sinnvoll einsetzbar. Wird vor allem für Heatmaps verwendet.

\-**2a Punkte verändern:** Wenn du die passende Funktion ausgewählt hast fügst du das Argument `labels = c("label 1", "label 2")` hinzu. Wobei die Sortierung die gleiche Reihenfolge haben sollte, wie die aktuelle. **PRÜFE DAS**, sonst kann es zu schwerwiegenden inhaltlichen Fehlern kommen! -**2b Titel verändern:** In die gleiche Funktion fügst du die Funktion `guide_legend()` mit dem Argument `title = "some title"` ein. - **Zusammenfassung:** - **Pro:** Kein rumgemurkse mit den Daten. Kann für jeden Plot individuell passend verändert werden. - **Con:** Erhöhte Fehlergefahr aufgrund von flaschen Beschriftungen.

```{r d_legends_2, exercise = TRUE, exercise.setup = "d_legends",  exercise.cap = "guide_legend()"}
ggplot(einkaufen_recoded, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar(position = position_dodge(preserve = "single")) +
  scale_fill_viridis(discrete = T,
    labels = c("bio", "konven."),
    guide_legend(title = "Ladenart")) +
  labs(
    title = "Verkehrsmittel und Ladenart",
    y = "Absolute Anzahl der Nutzenden",
    x = "Verkehrsmittel"
  )+
  theme_bw()
```

::: aufgabe
Finde für die Funktionen `scale_colour_viridis(discrete = T)` und `scale_colour_viridis()` eine Anwendungsmöglichkeit in einen der bereits ausgeführten Plots dieses Tutorials und füge diese Ebene hinzu. Füge auch gerne ein Theme deiner Wahl sowie passende Achsenbeschriftungen hinzu.

\*Extraaufgabe: schreibe einen komplett eigenen Plot.
:::

```{r d_legends_3-solution}
ggplot(einkaufen_recoded, aes(x = alter, y = weg, colour = kochen)) +
   geom_point() +
  # \n sagt R, dass du einen Zeilenumbruch möchtest
   scale_colour_viridis(guide_legend(title = "Kochen/ \n Woche")) +
  labs(
    title = "Weg und Alter",
    x = "Alter",
    y = "Weg (in km)"
    ) +
  theme_bw()

 ggplot(einkaufen_recoded, aes(x = verkehrsmittel, y = alter, colour = bioladen)) +
   geom_boxplot(position = position_dodge(preserve = "single")) +
   scale_colour_viridis(discrete = T,
     labels = c("bio", "konven."),
    guide_legend(title = "Ladenart")) +
   labs(
     title = "Genutze Verkehrsmittel und Alter",
     x = "Verkehrsmittel",
     y = "Alter"
   ) +
   theme_bw()
```

```{r d_legends_3, exercise = TRUE, exercise.setup = "d_legends", exercise.cap = "Legenden"}

```

```{r drumherum-quest}
quiz(caption = "Quiz zum Drumherum",
     
question("Was stimmt?",
         answer("Themes sind vorgefertigte Muster (Hintergrund, Schriftart etc.), nach denen Plots gestaltet werden.",
                 correct = T),
         answer("Themes sind Themenfelder, 
                welche inhaltlich in Plotsabgearbeitet werden.",
                 message = "Lies dir den Abschnitt lieber nochmal genauer durch."),
        answer("Labs sind die Beschriftungen eines Plots.",
                 correct = T),
        answer("Labs ist die Laborkennung, 
               in dem die analysierten Daten erhoben wurden.",
                 message = "Lies dir den Abschnitt lieber nochmal genauer durch."),
         answer("Um eine Legende zu verändern, 
                wird der Plot gespeichert und die Legende dann extern mittels Paint
                oder Gimp nach den eigenen Wünschen nachgestaltet.",
                 message = "Da gibt es deutlich galantere Wege. 
                Lies dir den Abschnitt lieber nochmal genauer durch."))
)
```

## 9. Barrierefreiheit

Es mag erstmal überraschen, aber: auch in visuellen Darstellungen ist Barrierefreiheit ein relevantes Thema. Ein nicht zu vernachlässigender Anteil der Bevölkerung kann bestimmte Farben nicht unterscheiden. Deswegen wurden von schlauen Menschen Farbpaletten entworfen, die keine ambivalenten Farben wie rot und grün enthalten, und auch ganz ohne Farbwahrnehmung nur über Helligkeit und Dunkelheit der Farben, also in schwarz weiß funktionieren. Der letzte Punkt ist ebenfalls relevant für alle Plots, die in schwarz weiß (wie bspw. in manchen Journals) abgebildet werden.

Eine der verbreitetesten ist das Paket `viridis`. Es hat auch seine eigene [Hilfeseite](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html), auf der die Verwendung und die Hintergründe gut dokumentiert sind.

Die verfügbaren Farbpaletten sind:

[ ](images/viridis.png){width="50%"}

[source](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)

Hier ein Beispiel in action:

```{r viridis-demo, message=FALSE, warning=FALSE}
library(ggplot2)
library(hexbin)
library(viridis)

dat <- data.frame(x = rnorm(10000), y = rnorm(10000))

p <- ggplot(dat, aes(x = x, y = y)) +
  geom_hex() + coord_fixed() +
  scale_fill_gradientn(colours = viridis(256, option = "D")) +
  theme_bw()

p
```

Und die obenstehende Grafik ist ein gutes Beispiel dafür, wie hell-dunkel Kontraste verwendet werden können. So ist das Ganze in schwarz-weiß immer noch lesbar, was insbesondere für Menschen mit eingeschränkter Farbwahrnehmung klasse ist, denn alles was schwarz weiß gut lesbar ist, ist immer auch colorblind-friendly. Die Farben sind nicht unbeding neu für dich, spätestens seit dem letzten Abschnitt (Legends) bist du mit ihnen vertraut. Der Punkt ist: wir haben dir da schon eine colourblind friendly scale untergemogelt, damit du von anfang an sauber mit Farben in Grafiken umgehst.

In diesem Unterkapitel lernst du neues über die Hintergründe der Farben (erledigt!) und du lernst verschiedene Paletten kennen: auf der [Hilfeseite](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)) sind alle Optionen mit Namen angegeben. Du kannst dich nun für eine Option entscheiden und diese mit dem Argument `option =` und ihrem Namen (`"viridis"` (default), `"magma"`, `"plasma"`, `"inferno"`, `"cividis"`, `"mako"`, `"rocket"` oder `"turbo"`) einfügen.

::: aufgabe
Nutze für jeden der Plots aus dem letzten Unterkapitel (Legends) eine andere viridis Farbpalette.

\*Extraaufgabe: schreibe einen komplett eigenen Plot.
:::

```{r barrierefreiheit-solution}
ggplot(einkaufen_recoded, aes(x = verkehrsmittel, fill = bioladen)) +
  geom_bar(position = position_dodge(preserve = "single")) +
  scale_fill_viridis(discrete = T, option = "cividis",
                     # Titel und Beschriftung der Legende ändern
                     guide = guide_legend(title = "Ladenart"), 
                     labels = c("konven.", "bio")
                     ) +
  labs(
    title = "Verkehrsmittel und Ladenart",
    y = "Absolute Anzahl der Nutzenden",
    x = "Verkehrsmittel"
  )+
  theme_bw()

 ggplot(einkaufen_recoded, aes(x = verkehrsmittel, y = alter, colour = bioladen)) +
   geom_boxplot(position = position_dodge(preserve = "single")) +
   scale_colour_viridis(discrete = T, option = "turbo",
     labels = c("bio", "konven."),
    guide_legend(title = "Ladenart")) +
   labs(
     title = "Genutze Verkehrsmittel und Alter",
     x = "Verkehrsmittel",
     y = "Alter"
   ) +
   theme_bw()

ggplot(einkaufen_recoded, aes(x = alter, y = weg, colour = kochen)) +
   geom_point() +
   scale_colour_viridis(option = "plasma",
     guide_legend(title = "Kochen/ \n Woche")) +
  labs(
    title = "Weg und Alter",
    x = "Alter",
    y = "Weg (in km)"
    ) +
  theme_bw()
```

```{r barrierefreiheit, exercise = TRUE, exercise.setup = "d_legends", exercise.cap = "Barrierefreiheit"}

```

## 10. Becoming a Pro

![](images/pro.webp){width="50%"}

[source](https://www.reddit.com/media?url=https%3A%2F%2Fpreview.redd.it%2Fgggd8zabn6s11.jpg%3Fauto%3Dwebp%26s%3Dd2d26cf405057710034a718c567cdad6d81de099)

Durch dieses Tutorial hast du nun die Grundlagen, um in Zukunft deine Plots ganz nach deinen Wünschen gestalten zu können. Deiner Phantasie sind kaum Grenzen gesetzt. Um zum nächsten Level zu kommen hilft: Recherche! Informiere dich im Internet was für deine Zwecke möglich ist und passe den Beispielcode auf deine Daten an. (Das gilt übrigens für alle Tutorials und Alles, was du hier in diesem Kurs lernst).

In den ersten Tutorials haben wir dir bereits *Cheat Sheets* verlinkt und auch zu Beginn dieses Tutorials die super hilfreiche Seite [R Graph Gallery](https://r-graph-gallery.com/) empfohlen.

**Cheat Sheets** Sind eine fantastische erste Anlaufstelle, wenn du dir Zeit nimmst sie zu verstehen. Sie geben dir für ein bestimmtes Paket einen guten Überblick zu den vielzähligen Funktionen und deren Code. Somit fungieren Sie wie die `Hilfe` Seite einer Funktion oder eines Paketes, das für dich visuell aufbereitet wurde.

Hier kannst du die [von R Studio erstellten Cheat Sheets](https://rstudio.github.io/cheatsheets/) finden. Es gibt aber auch noch weitere *Cheat Sheets* von anderen Instanzen.

::: aufgaberstudio
Hier mal eine besondere Aufgabe: Schau dir das [ggplot Cheat Sheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf) genau an und beantworte dann folgende Fragen.
:::

</br>

```{r question_cheatsheet}
quiz(caption = "Das Cheat Sheet verstehen",
question_checkbox("In der Box zu Basics hast du gelernt, dass diese Funktionen notwendig zur Erstellung einer Grafik sind:",
               answer("`ggplot(data = ...)`",
                      correct = TRUE,
                      message = "Wir brauchen Daten, die wir visualiesieren können."),
               answer("`stat = ...`",
                      message = "Die Nutzung von in der ggplot-Funktion neu berechneten Statistiken ist kein muss."),
               answer("`mapping = aes(...)`",
                      correct = TRUE,
                      message = "Wir brauchen natürlich auch `aes` für ein Koordinatensystem."),
                answer("`geom_...()`",
                       correct = TRUE,
                      message = "Die `geom` Funktion brauchen wir für das Einzeichnen unserer Datenpunkte."),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               correct = "Richtig!",
               incorrect = "Das stimmt leider nicht, probier es noch mal!"),


question_radio("Welche Art von Variablen wird für die Funktion `g + geom_count()` benötigt?",
               answer("Zwei diskrete Variablen", 
                      correct = TRUE, 
                      message = "Das Cheat Sheet ist so aufgebaut, dass die Buchstaben vor den Funktionen (z.B. das `g +` vor `geom_count()`) im Abschnitt `Geoms` für die entsprechenden Skalenniveaus und Anzahl der Variablen stehen."),
               answer("Eine kontinuierliche Variable"),
               answer("Zwei kontinuierliche Variablen"),
               allow_retry = T,
               random_answer_order = T,
               incorrect = "Leider nicht richtig, probier es noch mal!"),

question_radio("Wie kannst du deiner Grafik Achsebeschriftungen hinzufügen?",
               answer("`labs(x = , y = )`",
                      correct = TRUE,
                      message = "Richtig, du kannst für die jeweiligen Variablen auf Achse x und y eine Legende einfügen lassen."),
               answer("`labels(x = , y = )`"),
               answer("`leg(x = , y = )`"),
               allow_retry = TRUE,
               random_answer_order = TRUE,
               incorrect = random_encouragement(language = "de"))
)
```

Noch ein paar Worte zu *ChatGPT*: Schau gut, inwieweit es für dich hilfreich ist. Jetzt wo du die grundlegenden Zusammenhänge verstanden hast kannst du es wahrscheinlich gut nutzen. Meine ganz persönliche Sicht: Seit ich mich für dieses Tutorial nochmal so richtig in ggplot reingearbeitet habe, nutze ich es gar nicht mehr - ich hab (endlich) verstanden, wie die Zusammenhänge funktionieren und bin deutlich schneller und effizienter mit den verlinkten Hilfeseiten und der R Graph Gallery. Sich da einzuarbeiten ist wirklich ein lohnendes Investment!

## Zu guter Letzt: Überblick bekommen

Wie ganz zu Beginn erwähnt, benutzen wir Visualisierungen für zweierlei Zwecke:

-   einmal um einen **Überblick** zu gewinnen
-   am Ende um **Ergebnisse** zu **kommunizieren**

Es lassen sich eigentlich alle Grafiken nuzten, um Ergebnisse zu kommunizieren, aber welche eignen sich dafür einen Überblick zu bekommen, um deine (zunächst unverständlich großen) Daten besser zu verstehen? Hier nur eine kurze Auflistung:

1.  *Histogramme*: Zweck: Zeigt die Verteilung der Daten. Verwendung: Geeignet, um die Form der Verteilung, Zentralität und Streuung zu untersuchen.

2.  *Boxplots*: Zweck: Veranschaulicht die Verteilung und Zentralität der Daten sowie Ausreißer. Verwendung: Besonders hilfreich bei der Identifizierung von Ausreißern.

3.  *Streudiagramme* (Scatter Plots): Zweck: Zeigt die Beziehung zwischen zwei kontinuierlichen Variablen. Verwendung: Ermöglicht die Identifizierung von Mustern, Korrelationen oder Ausreißern.

Dieser Art der Nutzung von Visualisierungen wirst du in späteren Tutorials erneut begegnen, wenn wir diese zur Überprüfung der Voraussetzungen für eine statistische Testgröße verwenden. Jetzt hast du es bereits schon einmal gehört - oder eher *gelesen* - und weißt dann, wenn die Zeit gekommen ist, schon Bescheid was wir zur Verfügung haben.

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

## Credit

Dieses Tutorial wurde gemeinsam von Gesa Graf, Lukas Bruelheide und Marie Klosterkamp verfasst.

### Literaturverzeichnis

<!--  Wird automatisch generiert aus den @autorYYYY-Zitationen und der Bibliothek in ref.json. Das Literaturverzeichnis wird immer ans Ende generiert, deswegen muss das hier die letzte Überschrift bleiben. -->
