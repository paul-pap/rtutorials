---
title: "Indizierung bei Vektoren"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Bestimmte Elemente eines Vektors auswählen
resource_files:
- css/boxes.css
---

```{r setup, include=FALSE}
library(learnr)
# library(gradethis)
set.seed(123)
knitr::opts_chunk$set(echo = FALSE)
```

::: grau-nb
**Hinweis**
Dieses Tutorial ist stark angelehnt an die `swirl`-Lektion 
[Subsetting Vectors](https://github.com/swirldev/swirl_courses/tree/master/R_Programming/Subsetting_Vectors)
innerhalb des Kurses "R Programming". 
:::

## Indizierung

![](images/honeyguide.jpg "indicator indicator, by Wilferd Duckitt (CC BY 2.0)"){width="50%"}

###### Foto: Wilferd Duckitt (CC BY 2.0)

Der *Honeyguide* hat seinen lateinischen Namen *indicator indicator* aus guten 
Grund: Er ist ein Indikator, d.h. **Anzeiger** für den Ort von Bienennestern.

Dieser in Afrika vorkommende Vogel kennt sich gut aus und führt aktiv Menschen zu den 
Nestern der Bienen. Die Menschen ernten den Honig und der *Honeyguide* bekommt eventuell
etwas ab.
([wikipedia](https://en.wikipedia.org/wiki/Greater_honeyguide))

In diesem Tutorial geht es auch um das Anzeigen einer bestimmten Stelle, 
sogenanntes *Indizieren*.

Sie haben bereits gelernt, wie Vektoren erstellt werden und dass sie mehrere Elemente hintereinander enthalten können. Jedes Element hat also eine Position. Im Folgenden lernen Sie, die Elemente anhand ihrer Position oder ihres Inhalts separat aufzurufen. Das heißt in R "Indizierung".

### verschiedene Arten der Indizierung

Es gibt insgesamt 3 verschiedene Arten:

1. Indizierung mit ganzen Zahlen

```{r ganzzahlig, exercise = TRUE}
# Die ersten 6 Einträge der Spalte mpg 
mtcars$mpg[1:6] 
```

2. Indizierung mit Logik

```{r logisch1, exercise = TRUE}
# Alle Autos, die mehr als 25 Meilen schaffen
mtcars$mpg[mtcars$mpg > 25] 
```

3. Indizierung mit Text

```{r logisch2, exercise = TRUE}
# Wie weit kommt ein Honda Civic mit einer Gallone Treibstoff?
mtcars["Honda Civic", ]$mpg 
```

::: aufgabe
**\* Zusatzaufgabe:** Miles per gallon ist ein unübliches und Maß für uns. 

a) Rechnen Sie die Spalte `mpg` in eine neue Spalte `lp100km` um, die den Verbauch in Litern pro 100 km angibt!
b) Wie viel Liter pro 100 km verbraucht der Honda Civic?
:::

```{r zusatz, exercise = TRUE}
# L/100km = 235.214583 / mpg

mtcars$lp100km <- mtcars$mpg
```

```{r zusatz-solution}
# a)
mtcars$lp100km <- 235.214583 / mtcars$mpg

# b) 
mtcars["Honda Civic", ]$lp100km
```

```{r silentsetup}
mtcars$lp100km <- 235.214583 / mtcars$mpg
```

Das war ein kurzer Überblick über die drei verschiedenen Methoden. Es klingt jetzt erst mal technisch, ist es auch. Um R wirklich zu verstehen ist es einfach total hilfreich, zu wissen, wie Indizierung funktioniert, und welche verschiedenen Arten es gibt. Denn die drei verschiedenen Arten funktionieren alle ähnlich, aber unterscheiden sich in ihrem Aufbau fundamental
Der nächste Abschnitt demonstriert das Konzept zunächst mit ganzzahligen Vektoren.

## Indizieren mit ganzzahligen Vektoren

### Anwendungsbeispiel
Der Vektor `x` enthält 30 (hypothetische) Messungen einer Wetterstation. 
Lassen Sie sich `x` anzeigen!


```{r ex}
x <- c(22, 25, 23, 19, 20, 23, 25, 27, 29, 24, rep(1000, 20))
```

```{r x, exercise = TRUE, exercise.setup = "ex"}

```

Sie sehen bereits das Problem: Die letzten 20 Werte sind fehlerhaft, weil das
Messinstrument nicht richtig funktioniert hat.
Wie können wir also nur die ersten 10 Werte auswählen?

Dafür benötigen wir eine neue Funktion, den sogenannten *index operator* `[]`.

```{r ex2, exercise = TRUE, exercise.caption = "Index Operator", exercise.setup = "ex"}
x[1:10]
```

Innerhalb der eckigen Klammern wird ein Vektor angegeben. In diesem Fall 
die Zahlenreihe `1:10`, um die ersten 10 Elemente auszuwählen.

::: grau
#### Verbalisierung

`[]` kann gelesen werden als: "*An der Stelle…*".

Beispiele:\
`x[9]` = `x` *an der Stelle* 9 

`x[1:10]` = `x` *an den Stellen* 1 bis 10
:::

Jetzt sind Sie gefragt:

::: aufgabe
**1.** Wählen Sie nur die 7. Messung aus! 
:::
```{r choose-solution}
x[7]
```

```{r choose, exercise = TRUE, exercise.setup = "ex"}
x[]
```

<details>
<summary><a>▼ \* Exkurs: One-based-counting</a></summary>
::: infobox
Viele Programmiersprachen basieren auf *zero-based-counting*, das heißt, das 
Zählen der Elemente beginnt bei 0. Falls Sie bereits Erfahrung mit einer solchen 
Sprache haben, müssen Sie sich nun umgewöhnen, denn R hingegen verwendet
*one-based-counting*. Dabei bekommt das erste Element auch tatsächlich die
Nummer 1. 
:::
</details>
<br>

::: aufgabe
**2.** Lassen Sie sich nur die Messung von Tag 5 und Tag 2 ausgeben!
:::

```{r selective, exercise = TRUE, exercise.setup = "ex"}
x[]
```

<div id=selective-hint>
Innerhalb von `[]` kann ein Vektor stehen, der die Positionen der auszuwählenden 
Elemente enthält.

Mehrere Zahlen werden mit `c()` zu einem Vektor verknüpft.
</div>

```{r selective-solution}
x[c(5, 2)]
```

::: aufgabe
**3.** Lassen Sie sich die Buchstaben in der Reihenfolge `c`, `b`, `a` ausgeben!
:::

```{r indexing, exercise = TRUE}
# Definieren eines Vektors 'abc'
abc <- c("a", "b", "c")

# Indizierung:
abc[]      
```

```{r indexing-solution}
abc[3:1]
# oder
abc[c(3, 2, 1)]
```

In diesem Fall werden drei Elemente ausgewählt. 
Zu erst die dritte Stelle von `abc`, welche "c"
lautet, dann die zweite ("b") und dann die erste ("a").

So langsam haben Sie vermutlich verstanden, wie es funktioniert. Hier sind noch
ein paar Übungsaufgaben:


::: aufgabe
**4.**
Lassen Sie sich das zweite und das dritte Element von `abc` ausgeben!
:::

```{r application-setup}
abc <- c("a", "b", "c")
```

```{r application, exercise = TRUE}
abc[]
```

<div id=application-hint>
Innerhalb von `[]` kann ein Vektor stehen, der die Positionen der auszuwählenden 
Elemente enthält.

Mehrere Zahlen werden mit `c()` zu einem Vektor verknüpft.
</div>


```{r application-solution}
abc[c(2, 3)]
```

::: aufgabe
**5.** Wählen Sie nur das erste Element aus `abc` aus und speichern Sie das Ergebnis in 
einem neuen Objekt `a`! 

Lassen Sie sich `a` ausgeben, um zu sehen ob es
funktioniert hat.
::: 

```{r a-setup}
abc <- c("a", "b", "c")
```

```{r a-solution}
a <- abc[1]
a
```
```{r a, exercise = TRUE}
abc[]
```

<details>
<summary><a>▼ \* Zusatzwissen: Subsetting mit negativen Zahlen</a></summary>
::: infobox
Mit negativen Zahlen können bestimmte Elemente ausgeschlossen werden. 

```{r neg, exercise = TRUE, exercise.setup = "ex"}
x[-(11:30)]   # schließt Messung 11 bis 30 aus. 
```
:::
</details>
<br>

::: gelb
#### Gut zu wissen

Die Konsole nutzt auch die Index-Schreibweise, um langen Output zu strukturieren: 
Zu Beginn jeder neuen Zeile ist die Nummer des ersten Elements der Zeile in 
eckigen Klammern angegeben.

```{r, echo=TRUE}
1:60
```

:::


### Zusammenfassung
Sehr gut! In diesem Abschnitt haben Sie gelernt, wie Indizierung mit
Zahlenvektoren funktioniert. Das ist nur einer von drei möglichen Wegen. 
Im nächsten Abschnitten werden Sie lernen, mittels logischer Vektoren zu 
indizieren.




## Indizierung mit logischen Vektoren

Bisher haben Sie Textvektoren und Zahlenvektoren kennengelernt. Ein logischer
Vektor sieht so aus:

```{r logidemo, exercise = TRUE}
c(TRUE, FALSE, TRUE)
```

Die Indizierung mit logischen Vektoren sieht so aus:

```{r logindex-setup}
abc <- c("a", "b", "c")
```

```{r logindex, exercise = TRUE}
abc[c(TRUE, FALSE, TRUE)]
```



```{r logiquestion}
question("Was können Sie daraus ableiten?",
  answer("Überall dort, wo FALSE steht, wird ein Element ausgewählt"),
  answer("An allen Positionen, wo TRUE steht, wird ein Element ausgewählt", 
    correct = TRUE),
  answer("Indizierung mit logischen Vektoren ist unlogisch")
)
```

### Bedingungsprüfungen
Logische Vektoren entstehen bei **Bedingungsprüfungen**. 

Beispielsweise könnten wir prüfen, welche Wettermessungen in `x` *nicht* den 
fehlerhaften Wert 1000 enthalten. 

```{r condi, exercise = TRUE, exercise.setup = "ex"}
x != 1000
```

Dieser Code prüft für jedes Element von `x`, ob es der Bedingung
"ungleich 1000" entspricht. Das Ergebnis wird als logischer Vektor ausgegeben.
Nur die ersten 10 Elemente sind TRUE, während die letzten 20 Elemente FALSE sind. 


::: blau-nb
#### Vergleichsoperatoren

Diese Vergleichsoperatoren gibt es in R:

- `<` und `>` : kleiner / größer als
- `<=` und `>=`: kleiner gleich / größer gleich
- `==`: gleich (Achtung, `=` hat eine ganz andere Bedeutung)
- `!=`: ungleich
:::
<br>

::: aufgabe
**Anwendungsaufgabe**

Stellen Sie Bedingungsprüfungen auf, in denen `x` geprüft wird auf...

a) Werte die $\leq 25$ sind. 
b) Werte $= 25$
c) Werte $\geq 25$
:::

```{r leq, exercise = TRUE, exercise.setup = "ex"}
x
```

```{r leq-solution}
# a)
x <= 25

# b) 
x == 25

# c)
x >= 25
```

Perfekt! Sie sind nun so weit, mit Bedingungsprüfungen zu indizieren. 

### Indizierung 

Wir möchten nun alle Elemente von `x` auswählen, die ungleich 1000 sind.

```{r neq, exercise = TRUE, exercise.setup = "ex"}
x[x != 1000]  # Indizieren mit Bedingungsprüfung
```

::: grau
#### Verbalisierung
Lies: `x[x != 1000]` = `x` *an der Stelle wo* "`x` ungleich 1000"
:::
<br>
Hinter den Kulissen wird zuerst die Bedingungsprüfung `x != 1000` evaluiert, denn
Code wird immer von innen nach außen ausgeführt. 

Das Ergebnis der Prüfung ist ein logischer Vektor:
```
TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
```

Dann findet die Indizierung mittels dieses logischen Vektors statt. 

Als Ergebnis erhalten wir alle Elemente von `x`, die ungleich 1000 sind. 

### Übungsaufgaben

Jetzt sind Sie dran:

::: aufgabe
**1.**
Lassen Sie sich die Messungen in `x` ausgeben, die kleiner als 20 sind!
:::

```{r filter, exercise = TRUE, exercise.setup = "ex"}
x[]
```

```{r filter-solution}
x[x < 20]
```


::: aufgabe
**2.**
Mit der Funktion `rnorm()` können wir $n$ zufällige Ziehungen aus einer
Standardnormalverteilung simulieren. 

a) Lassen Sie sich x anzeigen!

b) Lassen Sie sich nur die Elemente anzeigen, die größer als 0 sind.
:::

```{r rnorm-solution}
x        # Anzeigen
x[x > 0] # Nur Werte > 0 anzeigen
```

```{r rnorm, exercise = TRUE}
x <- rnorm(100)  # Ziehung von 100 Werten
```

### Verknüpfung von Bedingungen

Nun haben Sie bereits Vergleichsoperatoren kennengelernt, um Bedingungsprüfungen zu erstellen.
Was ist aber, wenn ich zwei Bedingungsprüfungen verknüpfen möchte?

To be continued... logische Operatoren & und |

Super! Sie haben diese wichtige Art von Indizierung gemeistert.

## Indizierung mit Textvektoren

Um diese Art des Subsettings zu verstehen, müssen wir uns zunächst mit 
Attributen beschäftigen.

…… to be continued. 

## Anwendungsaufgaben
::: aufgabe

a.  Erstellen Sie eine absteigende Zahlenreihe von 100 bis 1. Geben Sie der Reihe den Namen x.

b.  Addieren Sie das dritte und siebte Element des Vektors x! Benennen Sie das Ergebnis mit y.

c.  Lassen Sie sich y ausgeben.
:::

```{r anw-hint}
# Zahlenreihen rückwärts: die höhere Zahl nach vorne stellen.
# Addieren ganz simpel mit +
```

```{r anw-solution}
x <- 100:1
y <- x[3] + x[7]
y
```

```{r anw, exercise = TRUE, exercise.caption = "Indizierung"}

```

::: grau-nb
Hinweis: Falls beim Wert von `y` ein `L` dahinter steht, ist völlig normal. Das `L` steht für *Long* und bezeichnet einen Datentyp.
:::


