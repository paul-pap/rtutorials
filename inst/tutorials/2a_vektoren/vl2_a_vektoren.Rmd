---
title: "Vektoren"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Einführung in Assignment und Vektoren
resource_files:
- css/boxes.css
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(learnr)
library(modeest)
knitr::opts_chunk$set(echo = FALSE)
```

## Was Sie in diesem Tutorial lernen:

Im letzten Tutorial hast du dich spielerisch mit der allgemeinen
Syntax von Funktionen in R beschäftigt. Dieses Tutorial baut darauf auf:

-   Wie erstelle ich ein Objekt in R? (Assignment)

-   Was ist das Environment?

-   Wozu werden Vektoren benötigt?

-   Wie kann ich auf einzelne Elemente eines Vektors zugreifen?
    (Indizierung)

## kurze Wiederholung

```{r q1, echo=FALSE}
question("Wie kennzeichnen Sie einen Kommentar in R?",
  answer("`#` mit der Raute", correct = TRUE),
  answer("`;` mit einem Semikolon "),
  answer("`>` mit dem Größer-als-Zeichen"),
  answer(" `“` mit Anführungszeichen"),
  allow_retry = TRUE
)
```

Außerdem:

-   Text wird durch Anführungszeichen `"` gekennzeichnet. Auch einfache Anführungszeichen `'` sind möglich.

-   Argumente werden durch Kommata getrennt (Argument1 `,` Argument2)

-   Laden von Paketen mit `library()`

-   Installieren von Paketen mit `install.packages()`

-   Hilfe wird über F1 / `?`Funktionsname / `help()` aufgerufen

-   R Skript = Drehbuch/ Choreografie für Code 

-   R Notebook = gut lesbare Mischung aus Code, Erläuterungen und
    Ergebnissen

## R als Taschenrechner

:::{.aufgabe}
Fangen wir einfach an:

Berechne 2 + 3 im Codeblock!
:::

```{r rechner, exercise = TRUE}

```

```{r rechner-solution}
2 + 3
```

Das Ergebnis wird nicht gespeichert, sondern einfach nur ausgegeben - es
ist *printed and lost*.

Aber wie lässt sich das Ergebnis speichern, um damit im weiteren Verlauf
zu arbeiten?

Das funktioniert folgendermaßen:

```{r assignment_x, exercise = TRUE}
x <- 2 + 3
```

Hier wird beim Ausführen des Codes nichts ausgegeben. Das
liegt daran, dass der Wert von `2 + 3` in der Variable `x` gespeichert
wurde. 

:::{.aufgabe}
Um zu sehen, was die Variable `x` nun enthält, tippe einfach `x`:
:::

```{r x, echo = FALSE}
x <- 2 + 3
```

```{r x_print, exercise = TRUE, exercise.setup = "x"}

```

```{r x_print-solution}
x
```

Sehr gut! Im nächsten Abschnitt erfährst du mehr über die Zuweisung mit
`<-`.

## Assignment

Mithilfe des *assignment operators* `<-` bekommt ein Name einen Wert
zugewiesen. So können Variablen erstellt werden.

``` r
x <- 2 + 3
# Variablenname <- Wert
```

::: grau
#### Verbalisierung

Oft ist es hilfreich, Code zu verbalisieren. Hier sind einige
Möglichkeiten, wie der Pfeil ausgesprochen werden kann:

Lesen Sie in Ihrem Kopf:

-   `x` *bekommt den Wert von* `2 + 3`

-   und von rechts nach links, in der Pfeilrichtung:

    `2 + 3` *wird auf* `x` *geschrieben*.
:::
<br>

::: aufgabe
Multipliziere nun `x` mit 2!
:::

```{r y_creation, exercise = TRUE, exercise.setup = "x"}

```
<br>
```{r y_creation-solution}
x * 2
```
<br>

::: aufgabe
Speichere nun `x * 2` in einem neuen Objekt `y`!
:::

```{r y_saving, exercise = TRUE, exercise.setup = "x"}

```

```{r y_saving-solution}
y <- x * 2
```

::: blau-nb
**Tipp**: Nutze die Tastenkombination `Alt` + `-`, um den
*assignment operator* `<-` zu erzeugen!

Das hat den Vorteil, dass der Pfeil automatisch von Leerzeichen umgeben
wird.
:::
<br>

::: gelb

**Achtung mit Leerzeichen:**

`x < -2 + 3` hat eine sehr andere Bedeutung als   `x <- 2 + 3`.

Ersteres heißt: "Ist `x` kleiner als `-2 + 3`?", letzteres bedeutet:
"Definiere `x` als `2 + 3`".
:::
<br>

::: aufgabe
Lasse dir nun `y` ausgeben!
:::
```{r y_print, exercise = TRUE, setup.chunk = "y_saving-solution"}

```

```{r y_print-setup}
y
```

::: grau-nb
Übrigens:

Der Pfeil funktioniert auch in umgedrehter Form: `5 -> x`, das ist aber
unkonventionell und wird schnell unübersichtlich.
:::

### printed and lost

Wie bereis erwähnt ist alles, was nicht benannt wird, "*printed and
lost*".\
Das heißt, die Rechenaufgabe wird ausgewertet und das Ergebnis
ausgegeben, aber nirgends gespeichert.

```{r printed, echo=TRUE}
5 + 5       # Ergebnis ist "printed and lost"
x <- 5 + 5  # Ergebnis speichern
x           # Ergebnis ausgeben
```

### Überschreibung

Bereits existierende Variablen werden ohne Warnung überschrieben, wenn
sie neu definiert werden:

```{r overwrite, exercise = TRUE, eval=TRUE}
z <- 1
z
z <- 5
z
```

### Hinweise zu Objektnamen

#### formale Kriterien

-   R akzeptiert keine Leerzeichen in Objektnamen.

-   Namen dürfen nicht mit einer Zahl beginnen.

-   Namen sind *case-sensitive*, das heißt, Groß- und Kleinschreibung
    spielt eine Rolle. (x ≠ X)

#### stilistische Kriterien

Gute Namen:

-   **sind leicht zu tippen**

-   verwenden **konsistent** `_` oder `.` oder `-` als Leerzeichen

-   sind **konsequent** kleingeschrieben (hilft Verwechslungen zu vermeiden)

-   sind nicht identisch mit internen Objekten

    -   `T` und `F` sind z.B. schlechte Namen (stehen intern für TRUE
        und FALSE)

::: vorteile
##### Beispiele guter Namen

``` r
a
alter
alter_gruppe_1
alter-gruppe-1
alter.gruppe.1
```
:::

::: nachteile
##### Beispiele schlechter Namen

``` r
aLteR
ALTER
Alter_gruppe.1
```
:::

## Environment

Environment bedeutet Umgebung. Hier erscheinen alle definierten Objekte,
und alles was sich in der Umgebung befindet, kann von R verwendet
werden.

![](images/environment.png)

Es können natürlich nur Objekte aufgerufen werden, die auch vorher definiert
`<-` wurden und deswegen in der Umgebung verfügbar sind. Ansonsten
bekommst du folgenden Fehler:

```{r def, message=TRUE, warning=TRUE, exercise=TRUE, exercise.caption="Fehlermeldung"}
obj           # nicht vorher definiert, deswegen Fehler
```

Das lässt sich dadurch lösen, dass du das Objekt vorher definierst:

```{r def2, exercise = TRUE}
obj <- 100
obj
```

### wichtige Einstellung

![](images/settings.png)

::: aufgaberstudio

Setze bitte die RStudio-Einstellungen unter Tools / Global Options
auf diese Werte! Dadurch wird das Environment mit dem Beenden von
RStudio automatisch gelöscht und nicht zwischen Sitzungen gespeichert.
:::
<br>
Das soll dazu animieren, alle Objekte die benutzen werden auch
tatsächlich selbst zu definieren.

Das dient der Replizierbarkeit - Stell dir vor, du hast `x` gar
nicht definiert, die Berechnungen werden aber trotzdem ohne Warnung
ausgeführt, weil noch ein anderes `x` aus der letzten Sitzung
zwischengespeichert ist. Dann bekommst du falsche Ergebnisse und merkst
es eventuell nicht.


## Vektoren

Es ging bereits die ganze Zeit um Vektoren. Zum Beispiel
ist `obj` ein Vektor mit der Länge 1 - enthält also nur **eine** Zahl.

```{r, echo=TRUE}
obj <- 100
obj
```

Vektoren sind die elementarste Kategorie von Objekten in R und werden
sehr häufig gebraucht. Andere Objekttypen werden in einem eigenen
Tutorial vorkommen und bauen darauf auf.

Das Nützliche an einem Vektor ist, dass er mehrere Werte enthalten kann.

Beispielsweise die Ausprägungen des Merkmals "Alter" bei einer Befragung
von 4 Personen:

```{r, echo=TRUE}
alter <- c(20, 23, 50, 11)
alter
```

### neue Funktion: `c()`

Um Vektoren zu erstellen, die mehr als einen Wert enthalten, brauchen
Sie die Funktion `c()`.

-   *c* wie *combine* oder *concatenate* (verketten)

-   kombiniert mehrere Werte zu einem Vektor

-   wie in jeder Funktion sind die Argumente (Werte) durch Kommata
    getrennt

-   das Dezimalzeichen in R ist der Punkt!

::: aufgabe
**1.** Verkette 1.5, 2.5 und 3 mithilfe von `c()`!
:::

```{r concatenate, exercise = TRUE}
c()
```

```{r concatenate-solution}
c(1.5, 2.5, 3)
```

::: aufgabe
**2.** Mit `c()` lassen sich auch mehrere Vektoren aneinander binden. Kombiniere `x`, `y` und `z` zu einem neuen Vektor!
:::

```{r vectorc, exercise = TRUE}
# x, y und z definieren
x <- 5     
y <- 2 * x
z <- y / x

# x, y und z zu einem neuen Vektor verketten
c()

```

```{r vectorc-solution}
c(x, y, z)
```

Sehr gut! Als nächstes wird es daraum gehen, wie das Rechnen mit Vektoren
funktioniert.

## Rechnen mit Vektoren

Betrachte das folgende Beispiel. Welchen Schluss kann daraus
über das Rechnen mit Vektoren gezogen werden?

```{r vecmath, exercise = TRUE}
vec <- c(1, 2, 3) 
vec 
vec + 1
```

Die Rechenoperation wird mit jedem einzelnen Element des Vektors
durchgeführt!

Als Ergebnis steht ein neuer Vektor der die Ergebnisse der einzelnen
Berechnungen enthält. `vec` wird dadurch nicht verändert.

Dass Funktionen (wie z.B. `+`) auf jedes Element eines Vektors
angewendet werden, ist eine fundamentale Erkenntnis, die Sie noch sehr
häufig benötigen werden. Das Konzept dahinter heißt **Vektorisierung**
und ist ein Bestandteil der Mächtigkeit von R.

```         
vec + 10
```

```{r vecq}
question( "Was erwartest du als Ergebnis dieser Berechnung?",
  answer("Einen Vektor der Länge 1 mit dem Wert 15"),
  answer("Einen Vektor der Länge von `vec`, wo jedes Element mit 10 addiert 
   wurde", correct = TRUE),
  answer("Einen leeren Vektor"),
  answer("Einen Vektor mit 13 Elementen: 3 aus dem ursprünglichen plus 10 dazugefügte"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

Im folgenden ein paar weitere Beispiele.

### Vektor + Vektor

Was passiert, wenn zwei Vektoren gleicher Länge addiert werden?

```{r vecvec-setup}
vec <- c(1, 2, 3)
```

```{r vecvec, exercise = TRUE}
vec + vec
```

::: infobox
Die Rechenoperation wird jeweils zwischen den Elementen durchgeführt,
die an der gleichen Position stehen. 

(1 + 1, 2 + 2, 3 + 3)

(erstes Element + erstes Element, zweites + zweites Element, drittes + drittes ... )
:::

### Vektoren unterschiedlicher Länge

```{r recycl, exercise = TRUE}
v <- c(1, 2, 3, 4, 5, 6)
z <- c(1, 2)
v + z
```

::: infobox
Wenn zwei Vektoren unterschiedlicher Länge verrechnet werden, wird der
kürzere Vektor automatisch so lange wiederholt, bis die Länge des
anderen Vektors erreicht ist. Dieses Konzept heißt auch **Recycling**.
:::
<br>

Letztlich geschieht dieser Mechanismus auch bei unserem ersten Beispiel
von Rechnen mit Vektor + Zahl (`vec + 1`), weil die Zahl eigentlich auch
nur ein Vektor der Länge 1 ist.

### Fehlermeldung

Entsteht beim Recycling ein "Überstand", weil die beiden Vektoren keine
Vielfachen voneinander sind, wird die Berechnung trotzdem durchgeführt,
allerdings mit einer Warnung:

```{r warn, exercise = TRUE, warning=TRUE, exercise.caption="Warnmeldung"}
v <- c(1, 2, 3, 4, 5, 6)
z <- c(1, 2, 3, 4, 5)
v + z
```

Sehr gut! du hast jetzt bereits die wichtigsten fundamentalen
Bestandteile der Programmiersprache R in Aktion kennengelernt.


## Zahlenreihen

Um eine Zahlenreihe zu erstellen, verwenden Sie den *colon operator* `:`

```{r, echo=TRUE}
1:10
```

Der *colon operator* erzeugt als Ergebnis einen Vektor, der eine
ganzzahlige Zahlenreihe enthält.\
Wir könnten das selbe Ziel auch mit `c()` erreichen, was aber sehr
umständlich wäre:

```{r, echo=TRUE}
c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```
<br>

:::aufgabe
**Anwendung**

Erstelle einen Vektor namens `z`, der eine Zahlenreihe von 1 bis
1000 enthält! 

Lass dir daraufhin `z` ausgeben.
:::

```{r colon, exercise=TRUE, exercise.caption="colon operator"}

```

```{r colon-solution}
z <- 1:1000
z
```

## Textvektoren

Vektoren können nicht nur Zahlen enthalten, sondern unter anderem auch
Text.

Texteingabe wird für durch `"Anführungszeichen"` gekennzeichnet. 
Achtung! Es sollten genau diese Anführungszeichen sein `" "`, die normalerweise bei QWERTZ-Tastaturen mit `Shift` + `2` erreichbar sind. Es darf kein `„ “` oder `» «` sein, da das nicht erkannt wird. 

::: aufgabe
Das ist schon das vierte Tutorial, und du hast noch kein "Hello World"-Programm geschrieben... Das wird jetzt nachgeholt. 

Schreibe ein Programm, das den Text `Hello World!` als Ergebnis ausgibt! 
:::

```{r charvec, exercise = TRUE, exercise.cap = "Hello World!"}

```

```{r charvec-solution}
"Hello World!"
# Erstaunlich einfach, oder?

# Es geht natürlich auch umständlicher mit Zwischenspeichern:
text <- "Hello World!"
text
```

"Hello World" ist ein Textvektor der Länge 1, das heißt, dass er nur ein Element enthält. Sollen mehrere Texte in einem Vektor kombiniert werden, wird wieder `c()` benötigt. 

::: aufgabe
Kombiniere die Texte:

- "Hund"
- "Katze"
- "Maus"

zu einem Vektor namens `tiere`. 

Lasse dir den Vektor dann anzeigen.
:::

```{r char_animals, exercise = TRUE, exercise.cap = "Textvektor erstellen"}

```

```{r char_animals-solution}
tiere <- c("Hund", "Katze", "Maus")
tiere
```

### Länge bestimmen

```{r lengthquiz}
question_numeric("Welche Länge hat der Vektor `tiere`? Anders gesagt, wie viele Elemente enthält er?",
                 answer(3, correct = TRUE),
                 allow_retry = TRUE)
```

Die Länge eines Vektors kann mit der Funktion `length()` bestimmt werden. Jetzt konntest du die Anzahl der Elemente noch selbst zählen, aber die meisten Daten mit denen im Alltag gearbeitet wird, sind dafür zu groß. 

::: aufgabe
Ermitteln Sie nun noch mal auf programmatischem Weg die Länge Ihres eben erstellten Vektors `tiere`! Nutzen Sie die Funktion `length()`!
:::

```{r tiere}
tiere <- c("Hund", "Katze", "Maus")
tiere
```

```{r lengthex, exercise.setup = "tiere", exercise = TRUE, exercise.cap = "Länge eines Vektors bestimmen"}

```

```{r lengthex-solution}
length(tiere)
```

### Fehlermeldung: Mathe mit Textvektoren

Solltest du irgendwann mal versuchen, eine numerische Rechnung mit einem Textvektor durchzuführen, gibt R eine Fehlermeldung aus. 

:::aufgabe
Mach dich mit der Fehlermeldung vertraut! 
:::

```{r matherror, exercise = TRUE, exercise.cap = "Fehlermeldung", exercise.setup = "tiere"}
tiere + 1
```

> "non-numeric argument to binary operator"

bedeutet so viel wie: Keine Zahl eingegeben, wo eigentlich eine Zahl für erwartet wurde. Der „binary operator“ ist hier das `+`.

Perfekt! Jetzt bist du gewappnet, falls es dir diese Meldung in Zukunft unterkommen sollte. 


## atomic vectors

Nun zu einer elementaren Eigenschaft von Vektoren:

Betrachte dazu dieses Beispiel:

```{r coercion, exercise = TRUE}
c(1, 2, 3, 4)
c(1, 2, 3, "vier")  # Die ausgegebenen Zahlen stehen in Anführungszeichen
```

::: infobox
Achtung! Vektoren können immer nur Daten des gleichen Typs enthalten! Also entweder Text oder Zahlen. Dazu wird auf Englisch gesagt, es sind *atomic vectors*. 

Sobald auch nur ein einziges Element eines Zahlen-Vektors Text ist, wird der
ganze Vektor zu einem Textvektor umgewandelt und die Zahlen stehen nicht mehr für
Berechnungen zur Verfügung. Diese automatische Umwandlung heißt *coercion*.
:::
<br>

Der im letzten Abschnitt vorgestellte Fehler
`non-numeric argument to binary operator` entsteht oft, wenn numerische Vektoren irgendwo automatisch in Textvektoren umgewandelt werden. 

::: aufgabe
Führe den Code aus. Die Zahlen in `id` werden in Text *coerced* und die Berechnung schlägt fehl. 

Ändere den Code, so dass die Berechnung fehlerfrei ausgeführt werden kann!
:::

```{r coercion_error, exercise = TRUE, exercise.cap = "Fehler durch Mathe mit Textvektor"}
id <- c(1, 2, 3, "4")
id + 1
```

```{r coercion_error-solution}
id <- c(1, 2, 3, 4)
id + 1

# ohne die Anführungszeichen kann der Text als Zahl erkannt werden.
```

## Typen und Klassen

![](images/class.png){width="50%"}

Wie es im Fantasy RPG (Role Play Game) deiner Wahl in der Regel die Auswahl aus verschiedenen Klassen (Ritter\*in, Heiler\*in, Zauber\*in etc.) und Rassen (Mensch, Elfe, Zwerg etc.) gibt haben auch in der Informatik verschiedene Klassen und Typen. **Achtung: zwar gibt es auch in anderen Programmiersprachen Klassen und Typen, doch unterscheiden diese sich ggf. von denen in R.** Das Bild von Klasse und Rasse ist rein methaphorisch für eine grundlegende Idee der Zusammenhänge zu verstehen.

Die *Datentypen* sind sowas wie die "Rasse". Also wie sieht ein Chracter aus (Zwerg, Elfe, Mensch) bzw. ein Dateneintrag: Zahlenart, Buchstabe, binär etc. Die *Objektklassen* entsprechen grob den "Rassen" in RPGs. Also wie sind die Charaktere organisiert: in Heiler\*innengilden, Ritter\*innenorden, Hofzauber*in etc. bzw. in Objekten: numerisch, Liste, Fakto etc.

Auf dem Level, auf dem wir R nutzen ist die ganz genaue Unterscheidung zwischen Typen und Klassen nicht wichtig. Nur gut, es einfach schonal gehört zu haben, da hier manchmal Probleme auftauchen die sich dann einfacher lösen lassen. 


### Typen


Es gibt *atomic vectors* in insgesamt sechs Datentypen, von denen wir aber nur vier wirklich verwenden. Aber damit du es einmal gesehen hast, werden der Vollständigkeit halber einmal alle gezeigt. 

1. numeric: Typ **integer**
2. numeric: Typ **double**
3. **character**
4. **logical**
5. (complex)
6. (raw)

#### Unterschied `double` und `integer`

Sowohl `double` als auch `integer` beinhalten Zahlen. Wo ist nun der Unterschied und warum gibt es ihn?


**Double** sind Fließkommazahlen bzw. Dezimalzahlen, auch *floating point numbers*.

**Integer** sind ganze Zahlen. 

Das ist wichtig zu erwähnen, denn das ist krass: Computer runden anders als wir Menschen. Menschen denken *dezimal* und Computer *binär*. Für uns sieht eine `0.1` so aus: 0.1 bzw. 1/10. Für einen Rechner sieht eine `0.1` so aus: $$0.0 \overline{0011}$$. Allerdings können Rechner pro Zahl nur 32 bzw. 64 Ziffern speichern, danach wird die Zahl einfach abgeschnitten. Das führt unweigerlich zu Fehlern. 

```{r}

```


### Präzision

Siehe R Kurs 2022, **Präsentation 3: Datentypen** Füge Sachen aus der zugehörigen Folie ein (25)

### Datentyp eines Vektors bestimmen

mit `typeof()`

Übung didaktisch noch ändern / übersichtlicher machen, mehr eigenanteil, vielleicht Quiz einfügen. Erklären wie 1L ein `integer` erzeugt. Vielleicht. Erklären was `NA` ist? Vielleicht.

- Erklären, dass Zahlenreihen immer Integer erzeugen. 
- Erklären, dass der Unterschied für uns eigentlich egal sein kann, dass es nur schon mal gesehen sein sollte. Hauptsache Unterschied "numeric" und "character" und "logic" ist klar. 

```{r typeof, exercise = TRUE, exercise.cap = "Datentyp bestimmen"}
typeof(TRUE)
typeof(1+10i)
typeof(1:100)
typeof(5.78)
typeof(1)
typeof(1L)
typeof(NA)
typeof("1")
typeof("Hello World")
```

### Umwandlungen

`as.numeric()`, `as.character`, `as.integer()`, `as.logical()`... Erklären. 

```{r as, echo = TRUE}
as.logical(c(1, 0))
as.character(5)
as.integer(5.999)
as.numeric("5")
as.numeric("fünf")
```

NAs erklären. Eventuell in eigenem Kapitel

## Abschlussquiz

```{r abschlussquiz}
quiz(caption = "Teste dein Wissen!",
     question_checkbox("Warum sollte die Option, das Environment auch zwischen
                       den Sitzungen zu speichern, deaktiviert werden?",
                    answer("Um uns das Leben nicht unnötig leicht zu machen.",
                           message = "Alles in R ist mit dem Ziel entstanden, 
                           das Leben von Forschenden etwas leichter zu machen,
                           auch wenn es manchmal nicht so scheint."),
                    answer("Um Replizierbarkeit zu fördern.", 
                           correct = TRUE,
                           message = "Wenn alle Objekte (z.B. Variablen), die 
                           für ein Skript nötig sind, immer im Skript definiert
                           werden, kann es nicht zu Verwechslungen kommen und 
                           auch andere, die das Skript bekommen, können es
                           ausführen, ohne zu wissen was alles vorher in deinem
                           Environment war."),
                    answer("Um nicht ausversehen mit alten Werten aus der 
                           letzten Sitzung zu rechnen.", 
                           correct = TRUE, 
                           message = "Wenn du in einer vorherigen Sitzung `x`
                           definiert hast, und in der neuen Sitzung an einem
                           anderen Skript arbeitest, wo es auch eine Variable
                           namens `x` gibt, könntest du ausversehen mit den
                           falschen Werten arbeiten, wenn `x` 
                           zwischengespeichert wird."),
                    answer("Um Arbeitsspeicher zu sparen und Abstürze zu
                           verhindern.", 
                           message = "Diese Option blockiert keinen
                           Arbeitsspeicher, wenn sie aktiviert sind"),
                    answer("Um nicht immer wieder das ganze Skript ausführen zu
                           müssen, um an meine Berechnungsergebnisse 
                           zu kommen.", 
                           message = "Selbst wenn das ganze Skript sehr
                           rechenintensiv ist, meinetwegen 3 Tage auf einem
                           Super-Computer laufen muss um die Ergebnisse zu
                           erhalten, würdest du diese nicht im Environment
                           speichern wollen, sondern dann lieber am Ende des
                           Skripts mit einem Befehl in eine Datei auf der
                           Festplatte schreiben."),
                    random_answer_order = TRUE),
     question_text("Wie heißt dieser Operator `<-` auf Englisch?",
                   answer("assignment operator", correct = TRUE),
                   answer("Assignment Operator", correct = TRUE)),
     question_radio("Worauf könnte dieser Fehler hinweisen? \n`non-numeric argument to binary operator`",
                    answer("Dass einer Funktion wie z.B. `+` oder `-`, die Zahlen zum Rechnen braucht, Text als Input gegeben wurde.", correct = TRUE),
                    answer("Dass einer Funktion die Text erwartet, fälschlicherweise Zahlen als Input gegeben wurden"),
                    answer("Dass der PC so kaputt ist, dass nicht einmal mehr die Grundrechenarten funktionieren."))
     
# Noch mehr Fragen erstellen

     )
```

## Learnings heute

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

Du hast gelernt, wie du Variablen Daten zuweisen kannst.

Variablen sind in R repräsentiert als Vektoren. Vektoren sind der fundamentale Objekttyp in R, auf dem alle anderen Objekte wie z.B. Tabellen aufbauen. Ihr Vorteil ist, dass sie viele Elemente enthalten können.

Beim Rechnen mit Vektoren hast du das Konzept "Recycling" kennengelernt,und erahnst ungefähr, was "Vektorisierung" ist - dass vektorisierte Funktionen wie `+` auf jedes Element eines Vektors einzeln angewendet werden, und als Ergebnis auch wieder ein Vektor steht.

Beim Assigment hast du gelernt, Leerzeichen zu verwenden um den Assignment Operator `<-`. 

Das Dezimaltrennzeichen in R ist der Punkt.
Kommata werden verwendet, um Werte in Aufzählungen voneinander zu trennen.

Gute Objektnamen sind konsistent und kleingeschrieben und dürfen keine 
Leerzeichen enthalten oder mit einer Zahl beginnen.

Im Environment werden die erstellten Objekte der laufenden Sitzung angezeigt. Bei Beenden von RStudio werden sie gelöscht, was die empfohlene Einstellung ist. So wird Replizierbarkeit trainiert: Nicht die erstellten Variablen werden aufbewahrt, sondern das Rezept um sie zu erstellen - in Form eines Skripts.

### Diese neuen Konzepte kennen Sie nun:

-   Assignment `<-`

-   Environment

-   Vektoren

-   Recycling und Vektorisierung

-   Zahlenreihen mit `:`

### neue Funktionen

| Code  | Beschreibung         |
|-------|----------------------|
| `c()` | combine, Vektor erstellen |
| `<-`  | assignment operator: Objekte speichern |
| `:`   | colon operator: Zahlenreihen erstellen |
| `typeof()` | Datentyp bestimmen |
| `length()` | Länge eines Vektors |
| `as.numeric()` | Umwandlung in Zahlenvektor |
