---
title: "Arbeit mit Tabellen"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: yes
    df_print: default
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Was sind Data Frames? Das Indizieren mit $-Operator wird geübt. 
resource_files:
- css/boxes.css
editor_options:
  markdown:
    canonical: true
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(nycflights13)
knitr::opts_chunk$set(echo = TRUE)
```

## Data Frames {data-progressive="TRUE"}

### Einführung

Dieses Kapitel zeigt dir die Objektklasse, mit welcher du hauptsächlich arbeiten wirst. Ein *Data Frame* ist die Struktur, mit der **Tabellen** in R repräsentiert werden.

Wenn du mit Tabellen in R zu tun haben wirst - und das wird oft sein - wird es sich meist um *Data Frames* oder eine spezielle Unterform davon, *Tibbles*, handeln. Beides wirst du in diesem Tutorial kennenlernen.

Dass Du den Umgang mit Tabellen in R lernst, ist essentiell, da die meisten Daten auf dieser Welt irgendwie in Tabellen dargestellt werden.

Im Tutorial "Vektoren" hast du gelernt, dass Vektoren Variablen darstellen und mehrere Werte enthalten können.

In nächsten Abschnitt lernst du, wie du mehrere Vektoren in einer Tabelle zusammenbringen kannst.

::: blau-nb
Übrigens: Wir verwenden hier für die Eindeutschung "der" Data Frame, die innerliche Begründung lautet: *Frame* = Rahmen, "der" Rahmen :)
:::

### Beispiel

Schauen Sie sich die Vektoren `alter` und `tier` im Codeblock an: Sie enthalten jeweils drei Elemente.

Führen Sie den Code aus, um daraus einen Data Frame zu erstellen und anzuzeigen.

```{r dataframe, exercise = TRUE, exercise.caption = "Data Frame erstellen"}
alter <- c(14, 7, 1)
tier <- c("Hund", "Katze", "Maus")

df <- data.frame(alter, tier)
df
```

<br>

::: infobox
Neue Funktion: `data.frame()`

Erstellt aus einzelnen Vektoren eine Tabelle. Die Vektoren müssen gleich lang sein.
:::

### Prinzip

Die Idee eines Data Frames ist, einen Haufen Vektoren gleicher Länge zu nehmen und damit eine Tabelle zu bauen. Dabei ist **jede Spalte ein Vektor**. Anders ausgedrückt: jede Spalte ist eine Variable.

Das ist eine wichtige Grundstruktur, die du dir merken solltest, denn es bedeutet dass für die Spalten einer Tabelle die gleichen Mechanismen greifen wie bei Vektoren.

::: gelb
**Disclaimer**

In der Praxis wirst du zur Dateneingabe ein grafisches Programm wie Excel verwenden, und die fertige Tabelle dann für die Verwendung mit R importieren. Das wirst du im Tutorial "Datenimport" lernen.

Wir fokussieren uns hier auf das Hantieren mit Data Frames, denn egal wie du die Tabelle erstellt hast - durch Import aus Excel oder Zusammensetzen einzelner Vektoren, es wird immer ein Data Frame sein in R.

Wenn im Folgenden immer wieder kleine Data Frames aus Vektoren erstellt werden, dient das nur dazu, Beispiele zu konstruieren um den Umgang zu erlernen, aber nicht weil das die übliche Methode ist, wie Daten in R eingegeben werden.
:::

### Neu = Alt

Eine in R übliche Konvention für Namensgebungs-Situationen ist die Reihenfolge `NEW = OLD`.

Bei der Verwendung von `data.frame()` kommen wir in eine solche Situation, weil wir während der Erstellung Spaltennamen vergeben können. Betrachte dazu das folgende Beispiel, wo wir eine Tabelle mit Daten über eine WG erstellen.

Schon beim Assignment, was ja auch eine Namensgebungs-Situation ist, gilt: Links steht immer der neue Name, rechts immer der alte Name oder Inhalt.

Achte auf die Argumente von `data.frame()`: Dort gilt das gleiche Schema. Die "neuen" Spaltennamen stehen jeweils auf der linken Seite des Gleichheitszeichens, der "alte" Name des bereits vorhandenen Vektors auf der rechten.

```{r new_is_old, exercise = TRUE, exercise.caption = "Neu ist Alt"}
# Mitbewohnis in einer WG

# Schema: neu <- alt
x <- c("Amadou", "Mira", "Luisa", "Alex")
y <- c(2000, 2001, 1990, 1995)
z <- 5.23 

# 2. Data Frame erstellen und dabei Spalten benennen. Gleiches Schema:

wg <- data.frame(
  name = x, 
  jahrgang = y, 
  grundpreis = z) 
wg
```

Das ist gut zu wissen, denn dieses Schema gilt als Konvention für die meisten Bennennungssituationen in R.

#### Lerntest

Hast du im Tutorial "Vektoren" gut aufgepasst?

Eigentlich hast du eben gelernt, alle Vektoren müssen gleich lang sein um einen Data Frame zu erstellen. Warum funktioniert es oben trotzdem, obwohl Vektor `z` nur Länge 1 hat und nicht ebenfalls 4?

```{r recyc-quiz, echo = FALSE}
learnr::question_radio(
  "Das liegt ...",
  answer("am Konzept der Vektorisierung, was bedeutet, dass eine Funktion die einen Vektor als Input bekommt auch einen Vektor der gleichen Länge als Output gibt",
         message = "Vektorisierung ist nicht die Ursache hier, aber die Beschreibung ist korrekt."),
  answer("an R's Eigenart, dass kürzere Vektoren ohne Warnung „recycelt“ werden, wenn die Länge des längeren ein Vielfaches des kürzeren ist", 
         correct = TRUE,
         message = "Das Konzept des Recycling ist hier die Ursache. Sollte ein Vektor aber kein Vielfaches des anderen sein, gibt es bei der Erstellung von Data Frames einen Fehler."),
  answer("daran, dass es ein Fehler in der Software ist, der seit den 90ern nicht behoben wurde",
         message = "Manche Leute sehen das so, weil es still und leise passiert,
         aber es ist so gewolltes Verhalten von den Entwickler*innen."),
  answer("daran, dass das Dezimaltrennzeichen der Punkt ist",
         message = "Das stimmt für sich genommen, ist aber nicht die Ursache"),
  answer("daran, dass Vektoren immer nur einen einzigen Datentyp enthalten dürfen",
         message = "Das stimmt für sich genommen, ist aber nicht die Ursache"),
  allow_retry = TRUE
)
```

### Eine neue Spalte hinzufügen

Nun wollen wir noch die Zimmergröße der WG-Mitbewohnis mit erfassen. Ein einfacher Weg, dem Data Frame eine neue Spalte hinzuzufügen, ist der `$`-Operator.

Sieh dir folgendes Beispiel an:

```{r wg_setupchunk, echo=FALSE}
x <- c("Amadou", "Mira", "Luisa", "Alex")
y <- c(2000, 2001, 1990, 1995)
z <- 5.23 
wg <- data.frame(
  name = x, 
  jahrgang = y, 
  grundpreis = z) 
```

```{r dollar, exercise.setup = "wg_setupchunk", exercise = TRUE}
wg$quadratmeter <- c(12, 14, 20, 15)
wg
```

Auch hier gilt wieder das Schema `Neu <- Alt`.

::: aufgabe
Du bist dran!

Erstelle mittels `$` im `wg`-Datensatz eine neue Spalte `balkon`, die angibt ob die Zimmer Zugang zu einem Balkon haben. Gib erfundene Werte ein. `TRUE` bedeutet "mit Balkon", `FALSE` "ohne Balkon".

Lasse dir `wg` danach anzeigen, um zu überprüfen ob die neue Spalte da ist.
:::

```{r balkon, exercise = TRUE, exercise.setup = "dollar", exercise.caption = "Balkon"}

```

```{r balkon-solution}
wg$balkon <- c(TRUE, FALSE, FALSE, FALSE)
wg
```

<br>

#### auf Spalten zugreifen

Du kannst `$` nicht nur verwenden, um neue Spalten zu erstellen, sondern auch um dir Spalten einzeln ausgeben zu lassen und damit Berechnungen anzustellen.

Teste mal, was der folgende Code zurückgibt.

```{r name, exercise = TRUE, exercise.caption = "Ausgabe mit $", exercise.setup = "balkon"}
wg$name
```

Preisfrage:

```{r preisfrage, echo = FALSE}
learnr::question_radio("Was vermutest du: Was wird ausgegeben durch `wg$name`?",
                       answer("Ein Data Frame",
                              message = "Es ist kein Data Frame, weil die Werte dann untereinander in einer Spalte ausgegeben würden und nicht nebeneinander."),
                       answer("Ein Vektor",
                              correct = TRUE,
                              message = "Genau. Es ist ein Vektor, denn bei einem Data Frame würden die Werte untereinander in einer Spalte ausgegeben statt horizontal."),
                       allow_retry = TRUE)
```

### Berechnungen mit Spalten

Jetzt wo du weißt, wie du auf eine Spalte zugreifen kannst, üben wir das ein bisschen.

::: aufgabe
a)  Versuche auf die Spalte *quadratmeter* zuzugreifen und sie dir anzeigen zu lassen.
b)  Greife gleichzeitig auf den zweiten und dritten Eintrag für die Spalte *jahrgang* und lasse sie dir anzeigen.
:::

```{r spaltengriff, exercise = TRUE, exercise.setup = wg_setupchunk}

```

```{r spaltengriff-solution}
# Auf 'quadratmeter' zugreifen und anzeigen lassen
wg$quadratmeter

# In der Spalte 'jahrgang' auf den 2 - 3 Eintrag zugreifen
wg$jahrgang[2:3]
```

::: aufgabe
Berechne eine neue Spalte namens `miete`, in dem du den Quadratmeterpreis `grundpreis` mit der Zimmergröße `quadratmeter` multiplizierst.

Lasse dir dann die gesamte Tabelle anzeigen!
:::

```{r wg_setupchunk_2, echo=FALSE}
x <- c("Amadou", "Mira", "Luisa", "Alex")
y <- c(2000, 2001, 1990, 1995)
z <- 5.23 
wg <- data.frame(
  name = x, 
  jahrgang = y, 
  grundpreis = z) 

wg$quadratmeter <- c(12, 14, 20, 15)
wg$balkon <- c(TRUE, FALSE, FALSE, FALSE)
```

```{r miete, exercise = TRUE, exercise.setup = "wg_setupchunk_2", exercise.caption = "Miete"}

```

```{r miete-solution}
wg$miete <- wg$grundpreis * wg$quadratmeter
wg
```

Da die einzelnen Spalten fundamental Vektoren sind, ist alles genau wie beim Rechnen mit Vektoren. Du verwendest `$`, um bestimmte Spalten aus dem Data Frame einzeln als Vektoren zu adressieren.

<!-- Die Aufgabe ist ganz ohne ifelse oder sum() oder sonstigen Hilfen echt schwer, daher erstmal weglassen -->

<!-- ::: aufgabe -->

<!-- Für dieses Beispiel haben Amadou und Luisa beide einen Balkon. Dies soll sich auch in deren Miete widerspiegeln.  -->

<!-- a) Überlege dir einen fairen Anteil an Miete, den die Beiden für ihren Balkon draufzahlen. Z.B. 10% -->

<!-- c) Erstelle eine Berechnung mit wg$miete, welche die Miete für   -->

<!-- ::: -->

<!-- ```{r balkon_preise-setup} -->

<!-- x <- c("Amadou", "Mira", "Luisa", "Alex") -->

<!-- y <- c(2000, 2001, 1990, 1995) -->

<!-- z <- 5.23  -->

<!-- wg <- data.frame( -->

<!--   name = x,  -->

<!--   jahrgang = y,  -->

<!--   grundpreis = z)  -->

<!-- wg$quadratmeter <- c(12, 14, 20, 15) -->

<!-- wg$balkon <- c(TRUE, FALSE, TRUE, FALSE) -->

<!-- wg$miete <- wg$grundpreis * wg$quadratmeter -->

<!-- wg$name -->

<!-- wg$miete -->

<!-- ``` -->

<!-- ```{r balkon_preise, exercise = TRUE, exercise.setup = "balkon_preise", exercise.caption = "Balkon Preise"} -->

<!-- ``` -->

Super! Nun hast du `$` schon mal einfach so verwendet, ohne zu erfahren, warum das eigentlich geht. Im nächsten Kapitel erfährst du mehr über die technischen Hintergründe des Indizierens mit `$`, wenn dich das interessiert.

## Listen und der `$`-Operator {data-progressive="TRUE"}

Wir werden in diesem Kapitel vom Allgemeinen auf das Spezifische schließen, das heißt, du lernst eventuell mehr als du müsstest, hast danach aber eine bessere Ausgangslage, um auch andere spezifische Situationen einzuordnen.

In diesem Kapitel hast du die Chance im Schnelldurchlauf zu verstehen:

-   warum ein Data Frame eine Art von Liste ist
-   was eine Liste in R ist
-   dass Listen `$` zum Indizieren verwenden
-   und deshalb auch Data Frames `$` zum Indizieren verwenden.

### Warum ein Data Frame eine Liste ist

Einen Data Frame kannst du als einen Vektor auffassen, der als Teilemente andere Vektoren enthält (s. Tutorial "Vektoren"). Die grundlegende Datenstruktur in R dafür heißt *Liste*.

Die Listen-Artige Struktur eines Data Frames wird deutlich, wenn wir uns die Struktur mit `str()` anzeigen lassen:

```{r str, exercise = TRUE, exercise.setup = "dollar"}
str(wg)
```

Wir werden informiert über:

-   Die Objektklasse (`data.frame`)

-   Die Anzahl an Variablen (4)

-   Anzahl von Beobachtungen (*observations*) je Variable (`4 obs.`)

-   Den Datentyp der einzelnen Variablen:

    -   `chr` für *character* (Text)
    -   `num` für *numeric* (Zahlen)

<br>

Noch deutlicher wird es, wenn wir mit `typeof()` nach dem zugrunde liegenden Datentyp von `wg` fragen.

```{r typeof, exercise = TRUE, exercise.setup = "dollar"}
typeof(wg)
```

### Was eine Liste in R ist

Eine Liste kann verstanden werden als ein "allgemeiner Vektor", welcher normale Vektoren enthalten kann - und sogar andere Listen (das wird dann aber schnell sehr unübersichtlich).

Ein ganz zentraler Punkt: Während normale Vektoren *atomic* sind, also immer nur Daten des gleichen Typs beherbergen können, können Listen gemischte Daten enthalten.

Hier ein Beispiel:

```{r list_example, exercise = TRUE, exercise.setup = "dollar"}
# named vector:
named_vec <- c(
  aepfel = 10,
  birnen = "zwanzig",
  pflaumen = 30)

# Liste:
named_li <- list(
  aepfel = 10,
  birnen = "zwanzig",
  pflaumen = 30)

named_vec
named_li
```

Der Vektor (oben im Output) kann nur Daten eines einzigen Typs enthalten. Da er den Text "zwanzig" enthält, werden die Zahlen automatisch auch zu Text umgeformt und mit Anführungszeichen umgeben. (Siehe auch Tutorial "Vektoren").

Die Liste (unten) hingegen kann problemlos Text und Zahlen gleichzeitig aufnehmen.

Ein weiterer Vorteil von Listen ist, dass sie auch Elemente unterschiedlicher Länge enthalten darf.

Data Frames sind dann eine spezielle Art von Liste - das charakterisierende Merkmal ist, dass alle Elemente die gleiche Länge haben müssen, während das für Listen generell nicht so sein muss. Und Data Frames werden anders ausgegeben als Listen.

### Listen verwenden `$` zum Indizieren

`$` ist speziell für das Indizieren bei benannten Listen gedacht, deswegen haben wir im letzten Abschnitt auch Namen für die Elemente der Liste vergeben.

Sagen wir mal, wir interessieren uns dafür, was das Listenelement "birnen" so enthält:

```{r list_indexing, exercise = TRUE, exercise.setup = "list_example"}
named_li$birnen
```

<br>

::: aufgabe
Finde heraus, was das Listenelement namens "pflaumen" aus der Liste `named_li` enthält! Verwende dafür den `$`-Operator.
:::

```{r dollar_exercise, exercise = TRUE, exercise.setup = "list_example"}

```

```{r dollar_exercise-solution}
named_li$pflaumen
```

`$` ist für uns ein werkzeug, um Bestandteile einer Liste mit ihrem Namen aufzurufen. Das ist Hintergrundwissen, dass du nur benötigst, um Verbindungslinien zu ziehen zu anderen Situationen, in denen der `$`-Operator auch auf den Plan tritt.

Wenn du andere Objektklassen kennenlernst, die auch fundamental Listen sind, wie zum Beispiel `fit`-Objekte (siehe Tutorial "Regression"), wird für dich das Erscheinen von `$` Sinn ergeben.

### Data Frames verwenden `$` zum Indizieren

Du hast gelernt: - Data Frames sind der Struktur nach benannte Listen - benannte Listen verwenden `$` zum Indizieren - Folglich verwenden Data Frames `$` zum Indizieren.

Um das Ganze etwas praktischer zu gestalten, verwenden wir nun mal einen realen Datensatz, der als Data Frame mit im `rtutorials`-Paket enthalten ist.

Erfasst sind dort die tägliche Maximaltemperatur in Grad Fahrenheit, und die Anzahl von durch Überhitzung verursachten Notaufnahme-Fällen in den Krankenhäusern von New York für den jeweiligen Tag.

Um dir einen Überblick über die den Datensatz zu verschaffen, ist es stets ratsam, diesen zunächt anzeigen zu lassen

```{r heated}
rtutorials::heated
```

## Indizierung bei Data Frames

Um gezielt eine bestimmte Spalte anzusteuern, benötigen Sie den `$`-Operator.

(Beispiel einfügen)

(Exercise einfügen)

An sich können Sie für die Spalten die gleichen Mechanismen verwenden wie für Vektoren, denn es *sind* Vektoren.

(Beispiel einfügen)

(Exercise)

Bemerken Sie, dass bei Data Frames der Output beim Indizieren mit dem `$`-Operator immer ein Vektor ist.

Es gibt noch eine andere Methode, die bei Data Frames immer auch einen Data Frame zurückgibt.

Das ist ein wichtiger Unterschied!

### Subsetting mit `[ , ]`

Um nicht nur eine einzelne Spalte herausgreifen zu können, sondern auch mehrere, können wir wieder den Index-Operator nutzen `[]`. Der funktioniert bei Data Frames eigentlich genau wie bei Vektoren, allerdings haben wir nun zwei mögliche Dimensionen: Zeilen und Spalten - anstatt vormals nur einer Dimension bei Vektoren.

Deswegen brauchen wir für Data Frames auch zwei Positionsangaben, mit einem Komma getrennt:

`[Zeilen, Spalten]`

(Beispiel einfügen)

(Exercise)

Bemerken Sie, dass Sie mit `[ , ]` immer einen Data Frame zurückbekommen, während Sie mit `$` nur den jeweiligen Vektor ausgegeben bekommen der die Spalte darstellt.

### Learnings

Data Frames sind Listen von gleichlangen Vektoren.

## Tibbles

Tibbles sind eine spezielle Art von Data Frame, die etwas nutzerfreundlicher ist.

Hier ist ein Beispiel: 2022 hat der Fachbereich 14 der Uni Kassel eine groß angelegte Umfrage über die Nutzung des Neun-Euro-Tickets durchgeführt. `net` steht für Neun-Euro-Ticket und ist ein Datensatz, welcher im rtutorials-Paket enthalten ist und einen Ausschnitt aus der Umfrage enthält:

-   `alter` (selbsterklärend)
-   `nutzung`: die Gesamtanzahl von Tagen pro Monat, an denen das Ticket genutzt wurde.

Lassen Sie sich den Datensatz `net` ausgeben!

```{r net, exercise = TRUE, exercise.caption = "Neun-Euro-Ticket"}
rtutorials::net
```

Wir erfahren schon in der ersten Zeile: Es handelt sich um eine Tibble. (Eindeutschung unserer Meinung nach "die", weil abgeleitet von *table* -\> "die" Tabelle :)

-   Es werden nur die ersten 10 Zeilen gedruckt beim Ausgeben.
-   Fehlende Werte `NA`s sind rot gekennzeichnet (funktioniert hier im Tutorial nicht, nur in der Konsole von RStudio)
-   Der Datentyp jeder Spalte ist unter den Spaltennamen vermerkt (in diesem Fall beide Spalten `double`, also numerisch)

```{r netquest, echo = FALSE}
learnr::question_numeric("Wie viele Zeilen hat der Datensatz? Wenn jede Zeile eine Versuchsperson ist, wie viele Personen haben an der Studie teilgenommen?",
                         answer(2446, correct = TRUE, message = "Die Zeilen einer Tabelle in R stehen üblicherweise für die Beobachtungen. Unsere Beobachtungseinheit hier ist Versuchsperson, das heißt, eine Zeile ist eine Versuchsperson."),
                         allow_retry = TRUE)
```

Nun konvertieren wir `net` zu einem klassischen Data Frame. So können wir die Unterschiede noch besser sehen. Was passiert, wenn wir uns `net` als Data Frame ausgeben lassen?

```{r netdf, exercise=TRUE, exercise.caption="Neun-Euro-Ticket als Data Frame"}
as.data.frame(rtutorials::net)
```

Der Output wird unfassbar lang und für das menschliche Auge sehr unübersichtlich. Tibbles sind also einfach etwas freundlicher und praktischer im Umgang.

Sie können jeden Data Frame über die Funktion `as_tibble()` in eine Tibble umwandeln.

Sie stammt aus dem Paket `tibble`, was Teil des Tidyverse ist. Dann ist hier vermutlich auch die richtige Stelle, um Sie mit dem Tidyverse bekannt zu machen.

## Tidyverse

Was ist das Tidyverse? Es ist ein Universum von Paketen, die sich einem bestimmten Ziel widmen, nämlich R für *Data Science* zu nutzen. Dazu gehört vor allem die Arbeit mit Tabellen und Daten.

Dabei hat sich eine Art Dialekt gebildet, der das Ziel hat, übersichtlich zu sein und konsistent und nutzerfreundlich. In den meisten Fällen werden Tidyverse-Funktionen diesem Anspruch gerecht und deswegen macht es auch Sinn, sie zu nutzen.

Trotzdem ein Wort der Warnung: Alles, was mit Tidyverse-Paketen möglich ist, lässt sich auch mit base R erreichen. Es wäre nicht so schlau, die "Basis" zu vergessen, und nur noch Tidyverse zu lernen. Tidyverse schreibt selbst auf seiner [Website](https://www.tidyverse.org/), es sei ein „opinionated R Package". Das heißt, es vertritt eine klare Meinung darüber, was eigentlich *tidy*, also aufgeräumt sein, für R bedeutet. Letztlich kann das Tidyverse nicht alles und nicht alle sind überzeugt davon, weswegen wir Ihnen ab jetzt an manchen Stellen parallel sowohl die base R-Lösung und die Tidyverse-Variante beibringen werden. Manche R-Kurse entscheiden sich, um nicht zu verwirrend zu sein, nur noch Tidyverse zu lehren, beispielsweise @ismay2022 oder @wickham2016. Wir denken jedoch, dass Sie base R zumindest auch schon einmal gesehen haben sollten.

Folgende Pakete gehören zum Tidyverse:

(Hex-Sticker von tidyverse hinzufügen über das hexsticker Paket)

-   `ggplot2`: konsistente *Grammar of Graphs* für Visualisierungen
-   `dplyr`: *Data Plyers* "Datenzange"
-   `tidyr`: Daten in ein *tidy*-Format bringen
-   ... und noch einige mehr, unter anderem `tibble`.

Alle diese Pakete können entweder einzeln installiert werden oder alle auf einmal, indem das Schirmpaket `tidyverse` installiert wird.

Ein Beispiel für die Design-Richtlinien, nach denen sich Tidyverse-Funktionen richten müssen, ist keine Punkte zu verwenden in Funktionsnamen (wie z.B. base R: `as.data.frame()`), sondern Unterstriche wie in `as_tibble()`. Das ist ein klassisches Zeichen, dass wir uns im Tidyverse bewegen.

## Data Manipulation Tasks

Der erste Anwendungsfall, in denen wir Ihnen sowohl Tidyverse- als auch base R-Varianten vorstellen möchten, ist das Reduzieren eines Datensatzes auf bestimmte Spalten.

Die Ausgangslage ist: Wir haben einen Datensatz mit unübersichtlich vielen Variablen (Spalten), und möchten davon bestimmte auswählen.

Als Beispiel sollte uns im Folgenden der `nycflights13::flights`-Datensatz dienen. Viele Erklärungen und Lehrbücher aus dem Tidyverse diese Daten als Referenz, deswegen ist es gut, wenn Sie sich damit vertraut machen.

#### `flights`

... ist einer von fünf Datensätzen aus dem `nycflights13`-Paket. Darin sind reale Daten aller Flüge enthalten, die im Jahr 2013 von einem der drei großen Flughäfen New Yorks abflogen - JFK (John F. Kennedy Airport), LGA oder EWR (Newark). Vor allem liegt der Fokus auf Verspätungen und Pünktlichkeit.

Die anderen Datensätze aus dem Paket bieten zusätzliche Informationen, von Nachschlage-Tabellen für...

-   Airline-Abkürzungen (`airlines`)

<!-- -->

-   Flugzeugtypen (`planes`)

-   Flughafenkürzel (`airports`)

bis zu stündlichen Wetterdaten des ganzen Jahres für alle drei Flughäfen (in `weather`).

Hier haben Sie die Möglichkeit, sich `flights` ausgeben zu lassen. Für Ihren Komfort haben wir das Paket `nycflights13` bereits geladen, aber wenn Sie die Daten außerhalb des Tutorials aufrufen möchten, müssten Sie das vorher tun.

```{r flightsout, exercise = TRUE, exercise.caption = "flights"}
flights
```

```{r flightsquiz, echo = F}
quiz(
  question_numeric("Wie viele Beobachtungen enthält der `flights`-Datensatz?",
  answer(336776, correct = TRUE, message = "Entweder Sie nutzen `nrow()` oder Sie lesen es beim Output in der allerersten Zeile ab: `A tibble: 336,776 x 19`"),
  allow_retry = TRUE),
  question_numeric("Wie viele Variablen enthält `flights`?",
    answer(19, correct = TRUE),
    allow_retry = TRUE)
  )
```

### Bestimmte Variablen auswählen

#### Tidyverse-Approach

Dafür verwenden wir das Paket `dplyr`, was so viel bedeutet wie *Data Plyers*, "Datenzange". Es ist im Tidyverse enthalten und wird mit geladen, wenn Sie `library(tidyverse)` laden, Sie können es aber auch einzeln laden mit `library(dplyr)`. Für Ihren Komfort haben wir das im Tutorial schon erledigt für Sie.

Um nun lediglich die zurückgelegte Strecke (`distance`) und die Zeit in der Luft (`air_time`) anzeigen zu lassen, gehen Sie wie folgt vor:

```{r}
flights |> select(distance, air_time)
```

Dabei dürfte Ihnen vor allem diese Funktion ins Auge fallen: `|>`, der Pipe-Operator.

"Pipes" gibt es in vielen Programmiersprachen, das heißt, was Sie hier als Konzept lernen, ist auf jeden Fall übertragbar auf andere Kontexte.

Bei der *Pipe*, "Röhre", wird etwas Schritt für Schritt verarbeitet und dabei wird der Output von einer Station als Input an die nächste weitergegeben, wie auf einem Förderband in einer Industrieanlage, oder in einer Röhre eben.

```{r}
# Pipe-Schreibweise
c(1, 2, 3, 4, 5) |> mean()

# ohne Pipe
mean(c(1, 2, 3, 4, 5))
```

Pipes helfen, den Code lesbarer zu machen und komplizierte Verschachtelungen oder unnötige Zwischenspeicher-Schritte zu ersetzen.

## 

Achtung: Der folgende Absatz passt konzeptuell nicht so ganz rein und braucht vielleicht ein eigenes Tutorial? Ich hab das vorher mal als Idee geschrieben, es ist also alt. Viele Sachen doppeln sich. Bitte irgendwo unterbringen :)

## Von der Datenerhebung zur Analyse

Es klingt banal, aber wenn die Daten aufgeräumt sind, ist bereits die größte Hürde geschafft. Einen Großteil der Zeit von Datenanalyse verbringen Forschende damit, Daten in die richtige Form zu bringen. Die Auswertung selbst geht dann oft vergleichsweise schnell.

Den ganzen Aufräumprozess können Sie erleichtern, wenn Sie die Daten von Anfang an so organisieren, dass R gut damit umgehen kann.

Aber was gibt es eigentlich für Formen in denen Daten sein können?

## 

Gleiche Daten, aber anders organisiert:

```{r}
df <- trees |> tibble::rowid_to_column(var = "id")
library(dplyr)
library(tidyr)
df |> pivot_longer(cols = !id, names_to = "variable")

df |> arrange(Height) |> pivot_wider(id_cols = "id", names_from = "Height",
                                     names_prefix = "Height=", values_from = "Volume")
```

## 

## Datenerhebung

Wir beginnen damit, Daten zu erheben. Im Wintersemester 2022/23 haben 8 Studierende sich vor Bioläden in und um Kassel gestellt und den Kund_innen Fragen gestellt - zum Beispiel zum Lieblingsessen, wie oft sie selbst kochen und wie weit der Weg bis zum Laden war.

Die Antworten wurden mitgeschrieben und später in Excel oder OpenOffice eingetippt. Damit die Analyse in R später gut funktioniert, müssen die Daten in einer speziellen Form eingegeben werden:

```{r}
knitr::include_graphics(path = "images/clean.png")
```

::: grau-nb
Merke: Beobachtungen sind immer die Zeilen, und Variablen immer die Spalten.
:::

##### Variablen

Variablen sind die unterschiedlichen Fragen, die wir gestellt haben. Zum Beispiel:

-   Wie alt sind Sie? -\> Variable: Alter

-   Wie weit war Ihr Weg in km? -\> Variable: Weg

##### Beobachtungen

Beobachtungen sind hier die einzelnen Personen, denen die Fragen gestellt wurden. Eine Person ist dabei eine Beobachtung.

##### tidy data

Das oben vorgestellte Konzept wurde unter dem Namen "*tidy data"* formalisiert.

Hier sind drei wichtige Grundregeln für *tidy data* nach @wickham2016:

<div>

> 1.  Jede Variable braucht ihre eigene Spalte.
>
> 2.  Jede Beobachtung braucht ihre eigene Zeile.
>
> 3.  Jeder Wert braucht seine eigene Zelle.

</div>

Mit diesen drei Grundregeln werden Sie weniger Kopfschmerzen bei der Analyse von Daten mit R bekommen.

Schauen Sie sich im nächsten Abschnitt an, wie Sie einen mitgelieferten Datensatz aufrufen können!

## Beispieldatensätze

R enthält einige vorinstallierte Datensätze. Außerdem können Beispieldatensätze in Paketen, die Sie laden bereitgestellt werden.

Der von den Studierenden erhobene Datensatz befindet sich in diesem Tutorialpaket und heißt `einkaufen`. Um darauf zuzugreifen, rufen Sie ihn beim Namen:

```{r beispieldaten, exercise = TRUE}
einkaufen

```

::: grau-nb
Der obige Code funktioniert nicht. Das liegt daran, dass der Datensatz aus dem Paket `rtutorials` stammt, dieses Paket im Tutorial-Codeblock aber nicht geladen ist - eine gute Übung für die Praxis, wo es ständig passiert, das Pakete nicht geladen sind. Die Fehlermeldung: "Object not found" ist häufig ein Hinweis darauf, und kann auf zwei Arten gelöst werden:

**Die zwei Schreibweisen, um auf Inhalte aus Paketen zuzugreifen**

-   Um alle Inhalte des Pakets für die aktuelle Sitzung verfügbar zu machen, verwenden Sie `library(Paketname)`. Dann können Sie die Objekte (z.B. Beispieldatensätze) direkt beim Namen aufrufen:\
    \
    `library(rtutorials)`

    `einkaufen`

-   Um nur ein einziges Objekt aus dem Paket aufzurufen, ohne vorher das gesamte Paket zu laden, verwenden Sie `Paketname::Objektname`. Beispiel:\
    `rtutorials::einkaufen`
:::

In dem folgenden Tutorial "Datenimport" wirst du lernen, wie du selbst deine Daten in einen R Datensatz verwandeln kannst. Dann kannst du endlich deinen eigenen Daten erforschen.

## Abschlussquiz

```{r abschlussquiz_01, echo = FALSE}
learnr::question_radio("Was vermutest du: Was wird ausgegeben durch `wg$name`?",
                       answer("Ein Data Frame",
                              message = "Es ist kein Data Frame, weil die Werte dann untereinander in einer Spalte ausgegeben würden und nicht nebeneinander."),
                       answer("Ein Vektor",
                              correct = TRUE,
                              message = "Genau. Es ist ein Vektor, denn bei einem Data Frame würden die Werte untereinander in einer Spalte ausgegeben statt horizontal."),
                       allow_retry = TRUE)
```

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

Du hast gelernt: - Data Frames sind der Struktur nach benannte Listen - benannte Listen verwenden `$` zum Indizieren - Folglich verwenden Data Frames `$` zum Indizieren.

-   `$` ist ein Werkzeug, um Bestandteile einer Liste mit ihrem Namen aufzurufen.

### Diese neuen Konzepte kennst du nun:

-   

    ```         
    Stichpunktartige Beschreibung
    ```

### Neue Funktionen

eine Tabelle mit den wichtigesten Codes des Tutorials \| Code \| Beschreibung \| \|----------------\|----------------------------------------\| \| `[ ]` \| Indizierung \| \| `&` \| UND-Operator für logische Indizierung \|

## Credit

<!-- vielleicht in diese Richtung? -->

Dieses Tutorial wurde (größtenteils) von Lukas Bruelheide sowie in Teilen von Marie Klosterkamp geschrieben.

ggf.: Bei der Erstellung (u.a. der Beispiele, Aufgaben und Zusammenfassung) wurde teilweise von ChatGPT gebrauch gemacht.

